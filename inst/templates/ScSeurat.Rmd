---
title: "`r if (exists('reportTitle')) reportTitle else 'SUSHI Report'`"
output: 
  html_document:
    mathjax: https://fgcz-gstore.uzh.ch/reference/mathjax.js
    self_contained: true
    includes:
      in_header: !expr system.file("templates/fgcz_header.html", package="ezRun")
    css: !expr system.file("templates/fgcz.css", package="ezRun")
editor_options: 
  chunk_output_type: inline
---

# {.tabset}

## Quality control

`r format(Sys.time(), '%Y-%m-%d %H:%M:%S')`

```{r setup, include=FALSE, echo=FALSE}
# input for this report: sce
library(clustree)
library(kableExtra)
library(htmltools)
library(DT)
library(NMF)
library(pheatmap)
library(viridis)
library(cowplot)
library(scran)
library(RColorBrewer)
library(plotly)
library(tidyverse)
library(SingleR)
library(scater)
library(Seurat)
library(AUCell)
library(ezRun)
library(HDF5Array)
library(enrichR)
library(patchwork)
library(SCpubr)
library(dplyr)
library(cellxgenedp)
library(qs2)
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, knitr.table.format = "html")

# clusterInfoFile <- "clusterInfos.xlsx" # -- not used
posMarkers <- readxl::read_xlsx("posMarkers.xlsx")
param <- readRDS("param.rds")
scData <- qs_read('scData.qs2', nthreads=param$cores)
output <- readRDS("output.rds")
scData$qc.doublet <- scData$doubletClass %in% "doublet"
allCellsMeta <- readRDS("allCellsMeta.rds")
species <- getSpecies(param$refBuild)
if (file.exists("aziResults.rds")){
  aziResults <- readRDS("aziResults.rds")
  scData <- AddMetaData(scData, aziResults)
} else {
  aziResults <- NULL
}

if (file.exists("cellxgeneResults.rds")){
  cellxgeneResults <- readRDS("cellxgeneResults.rds")
  scData <- AddMetaData(scData, cellxgeneResults)
} else {
  cellxgeneResults <- NULL
}

if (file.exists("singler.results.rds")){
  singler.results <- readRDS("singler.results.rds")
} else {
  singler.results <- NULL
}
if (file.exists("cells.AUC.rds")){
  cells.AUC <- readRDS("cells.AUC.rds")
} else {
  cells.AUC <- NULL
}
if (file.exists("enrichRout.rds")){
  enrichRout <- readRDS("enrichRout.rds")
  if(length(enrichRout) == 1){ ##enrichR call creates empty file
    enrichRout <- NULL 
  }
} else {
  enrichRout <- NULL
}
if (file.exists("cellsPerGeneFraction.rds")){
  cellsPerGeneFraction <-  readRDS("cellsPerGeneFraction.rds")
} else {
  cellsPerGeneFraction <- NULL
}

# Load scType results
if (file.exists("sctype_results.rds")){
  sctype_results <- readRDS("sctype_results.rds")
  sctype_available <- TRUE
} else {
  sctype_results <- NULL
  sctype_available <- FALSE
}

# Load Azimuth Pan-Human results
if (file.exists("azimuth_results.rds")){
  azimuth_results <- readRDS("azimuth_results.rds")
  azimuth_available <- TRUE
} else {
  azimuth_results <- NULL
  azimuth_available <- FALSE
}

# Create shared color palette for all annotation methods (Azimuth, Azimuth Pan-Human, Cell x gene, scType)
# Start with Seurat's first 12 default colors, then add palettes without black colors
shared_colors <- c(
  scales::hue_pal()(12),                               # 12 Seurat default colors
  DiscretePalette(n = 26, palette = "alphabet2"),     # 26 colors (no black)
  DiscretePalette(n = 36, palette = "polychrome"),    # 36 colors
  DiscretePalette(n = 24, palette = "stepped"),       # 24 colors
  DiscretePalette(n = 26, palette = "alphabet2"),     # 26 colors (repeat)
  DiscretePalette(n = 36, palette = "polychrome")     # 36 colors (repeat)
)
# Remove names to ensure unnamed vector
names(shared_colors) <- NULL

# Process the posMarkers
posMarkers$gene = as.factor(posMarkers$gene)
# make sure the loaded cluster uses proper integer ordering if all levels are integer!
clusterSet <- posMarkers$cluster %>% as.integer() %>% unique() %>% sort(na.last=TRUE)
if (any(is.na(clusterSet))){
  posMarkers$cluster = as.factor(posMarkers$cluster)
} else {
  posMarkers$cluster = factor(posMarkers$cluster, levels=clusterSet)
}

var_height = 1 #This ensures that chunks that use the length of this variable to set the fig size, don't fail.
clusterNameNChar = max(nchar(levels(Idents(scData))))
```


```{r prepare QC}
xxAll <- SingleCellExperiment(colData = allCellsMeta)
xxAll$discard <- !xxAll$useCell
```


### QC diagnostic plots

```{r QC plots line 1, fig.height=4, fig.width=8}

xxAll$genePerCount <- xxAll$nFeature_RNA / xxAll$nCount_RNA 


plot1 <- plotColData(
  xxAll, x = "Sample", 
  y = "nCount_RNA", 
  colour_by = "discard"
) +
  scale_y_log10() +
  labs(title = "UMI counts",
       x = "",
       y = "UMI counts per spot") +
  theme(
    legend.position = "top",
  )

plot1 + plot_layout(ncol=2)

```

```{r 2nd line of plots, fig.width=8, fig.height=4}

plot2 <- plotColData(
  xxAll,
  x = "Sample",
  y = "genePerCount",
  colour_by = "discard"
) +
  labs(
    title = "Detected genes",
    x = "",
    y = "Detected genes"
  ) +
  theme(
    legend.position = "none", 
  )


plot3 <- plotColData(
  xxAll,
  x = "nCount_RNA",
  y = "genePerCount",
  colour_by = "discard",
) +
  scale_x_log10() +
  scale_y_log10() +
  labs(
    title = "",
    x = "UMI counts",
    y = "Detected genes"
  ) +
  theme(
    legend.position = "none", 
  )

plot2 + plot3


```

```{r 3d line of plots, fig.width=8, fig.height=4}

plot4 <- plotColData(
  xxAll,
  x = "Sample",
  y = "percent_mito",
  colour_by = "discard"
) +
  labs(
    title = "Mito percent",
    x = "",
    y = "Mitochondrial reads %"
  ) +
  theme(
    legend.position = "none"
    )


plot5 <- plotColData(
  xxAll,
  x = "nCount_RNA",
  y = "percent_mito",
  colour_by = "discard"
) +
  scale_x_log10() +
  labs(
    x = "UMI counts",
    y = "Mitochondrial reads %"
  ) +
  theme(
    legend.position = "none"
  )


plot4 + plot5


```


```{r 4th line of plots, fig.width=8, fig.height=4}

plot6 <- plotColData(
  xxAll,
  x = "Sample",
  y = "percent_riboprot",
  colour_by = "discard"
) +
  labs(
    x = "",
    title = "Ribosomal percent",
    y = "Ribosomal protein reads %"
  ) +
  theme(
    legend.position = "none"
  )

plot7 <- plotColData(
  xxAll,
  x = "nCount_RNA",
  y = "percent_riboprot",
  colour_by = "discard"
) +
  scale_x_log10() +
  labs(
    x = "UMI counts",
    y = "Ribosomal protein reads %"
  ) +
  theme(
    legend.position = "none"
  )

plot6 + plot7


```


```{r  5th line of plots, fig.width=8, fig.height=4}

plot8 <- plotColData(
  xxAll,
  x="Sample", 
  y="doubletScore", 
  colour_by = "discard"
) +
  labs(
    title = "Doublet score",
    y = "Doublet score"
  ) +
  theme(
    legend.position = "none",
    axis.ticks.y = element_blank(),
    axis.ticks.x = element_blank()
  )

plot9 <- plotColData(
  xxAll,
  x="nCount_RNA", 
  y="doubletScore",
  colour_by = "discard"
) +
  labs(
    x = "UMI counts",
    y = "Percent ribosomal protein reads"
  ) +
  theme(
    legend.position = "none"
  )

plot8 + plot9


```


<br/>

### Cell filtering

::: {.row}
::: {.col-md-6}

```{r low quality cells, fig.align='center'}
library(UpSetR)
qcList <- lapply(allCellsMeta[ ,grep("^qc", colnames(allCellsMeta))], function(x){rownames(allCellsMeta)[x]})
qcList <- qcList[sapply(qcList, length) > 0]
if (length(qcList) > 1){
  UpSetR::upset(fromList(qcList), nsets = 5)
}
```
:::

::: {.col-md-6}
```{r qc table, echo=FALSE, fig.align='center'}
qcStats <- ezFrame("Number of Cells"=integer(0), 
                   "Min Pass Value"=integer(0), 
                   "Max Pass Value"=integer(0), 
                   Fraction = integer(0))
qcStats[ "Library Size", ] <- c(
  c(sum(allCellsMeta$qc.lib), range(allCellsMeta$nCount_RNA[allCellsMeta$useCell])) %>% as.integer(),
  round(sum(allCellsMeta$qc.lib)/nrow(allCellsMeta), 2)
)
qcStats[ "Expressed genes", ] <- c(
  c(sum(allCellsMeta$qc.nexprs), range(allCellsMeta$nFeature_RNA[allCellsMeta$useCell])) %>% as.integer(),
  round(sum(allCellsMeta$qc.nexprs)/nrow(allCellsMeta), 2)
)
qcStats[ "Mitochondrial Percent", ] <- c(
  c(sum(allCellsMeta$qc.mito), range(allCellsMeta$percent_mito[allCellsMeta$useCell])) %>% as.integer(),
  round(sum(allCellsMeta$qc.mito)/nrow(allCellsMeta), 2)
)
qcStats[ "Ribosomal protein Percent", ] <- c(
  c(sum(allCellsMeta$qc.riboprot), range(allCellsMeta$percent_riboprot[allCellsMeta$useCell])) %>% as.integer(),
  round(sum(allCellsMeta$qc.riboprot)/nrow(allCellsMeta), 2)
)
qcStats[ "Doublets", ] <- c(
  sum(allCellsMeta$qc.doublet), 
  NA, 
  NA, 
  round(sum(allCellsMeta$qc.doublet) / nrow(allCellsMeta), 2)
)
qcStats[ "Empty Droplets", ] <- c(
  sum(allCellsMeta$qc.empty), 
  NA, 
  NA, 
  round(sum(allCellsMeta$qc.empty) / nrow(allCellsMeta), 2)
)
qcStats[ "Total removed (thresholding)", ] <- c(
  sum(!allCellsMeta$useCell), 
  NA, 
  NA, 
  round(sum(!allCellsMeta$useCell)/nrow(allCellsMeta), 2)
)
qcStats[ "Total removed (manual)", ] <- c(
  sum(allCellsMeta$useCell) - ncol(scData), 
  NA, 
  NA, 
  round((sum(allCellsMeta$useCell) - ncol(scData))/nrow(allCellsMeta), 2)
)
qcStats[ "Cells remaining", ] <- c(
  sum(ncol(scData)), 
  NA, 
  NA, 
  round(sum(ncol(scData))/nrow(allCellsMeta), 2)
)

qc_dt <- as.data.frame(qcStats) |>
  tibble::rownames_to_column(var = "Metric")

qc_dt <- qc_dt[, c("Metric", setdiff(names(qc_dt), "Metric"))]

dt <- DT::datatable(
  qc_dt,
  class     = "cell-border stripe",
  caption   = htmltools::tags$caption(
    style = "caption-side: top; text-align: left;",
    htmltools::HTML(sprintf(
      "<span style='font-weight: normal; font-size: 14px;'>Bin size: %s</span>",
      param$binSize
    ))
  ),
  escape    = FALSE,
  rownames  = FALSE,
  options   = list(
    autoWidth = TRUE,
    dom       = "t",
    paging    = FALSE,
    ordering  = FALSE
  )
)


htmlwidgets::prependContent(
  dt,
  htmltools::tags$style(htmltools::HTML(
    "table.dataTable tbody td:empty::before{content:'-'; color:#6c757d;}"
  ))
)

# kable(qcStats,
#       row.names=TRUE,
#       caption="Number of cells removed") %>%
#   kable_styling(bootstrap_options = "striped", full_width = F, position = "left") %>% kableExtra::group_rows(group_label = "Cells Removed by QC Thresholds", start_row = 1, end_row = 5)
```
:::
:::


<br/>

### Dimensionality reduction


```{r scree plot, fig.align='center', fig.width=14}
pct <- scData[["pca"]]@stdev / sum(scData[["pca"]]@stdev) * 100
cumu <- cumsum(pct)
plot_df <- data.frame(pct = pct, cumu = cumu, rank = 1:length(pct))

# Elbow plot
p <- ggplot(plot_df, aes(cumu, pct, label = rank, color = rank > param$npcs))
p <- p + geom_vline(xintercept = cumu[param$npcs], color = "grey") + geom_text() 
p <- p + xlab(paste("Variance based on 50 PCs of", param$nfeatures, "features")) +  
  ylab("Cumulative variance in % explained per PC") 
p <- p + theme_bw() + labs(color = paste("PC >", param$npcs)) + theme(legend.position = "bottom")
p <- p + annotate(geom="text", y=max(plot_df$pct), x=max(plot_df$cumu[param$npcs]), 
                  label=paste('Variance used:', round(plot_df$cumu[param$npcs], digits = 2), '%'), color="red")
p
```

<br/>


```{r exploreHVGs, echo=FALSE, results='asis'}
HVGs <- VariableFeatures(object = scData)

jsCall = paste0('enrich({list: "', paste(HVGs, collapse="\\n"), '", popup: true});')
enrichrCall <- paste0("<a href='javascript:void(0)' onClick='", jsCall, 
                       "'>Analyse HVGs at Enrichr website</a>")


enrichrTable <- tibble(GeneSet='HVGs',
                       "# of HVGs"=length(HVGs),
                       "Enrichr link"=enrichrCall)
kable(enrichrTable, format="html", escape=FALSE,
      caption=paste0("GeneSet enrichment")) %>%
  kable_styling("striped", full_width = F, position = "left")
```

The dimension reduction is based on the top `r param$nfeatures` highly variable genes (HVGs): `r enrichrCall`


#### Selected QC metrics

We use several common QC metrics to identify low-quality cells based on their expression profiles. The metrics that were chosen are described below.

1. The library size is defined as the total sum of counts across all relevant features for each cell. Cells with small library sizes are of low quality as the RNA has been lost at some point during library preparation.
2. The number of expressed features in each cell is defined as the number of genes with non-zero counts for that cell. Any cell with very few expressed genes is likely to be of poor quality as the diverse transcript population has not been successfully captured.
3. The proportions of mitochondrial and ribosomal genes per cell. High proportions are indicative of poor-quality cells (Islam et al. 2014; Ilicic et al. 2016), presumably because of the loss of cytoplasmic RNA from perforated cells.

<br/>

#### Diagnostic plots

A key assumption here is that the QC metrics are independent of the biological state of each cell. Poor values (e.g., low library sizes, high mitochondrial or ribosomal proportions) are presumed to be driven by technical factors rather than biological processes, meaning that the subsequent removal of cells will not misrepresent the biology in downstream analyses. Major violations of this assumption would potentially result in the loss of cell types that have, say, systematically low RNA content or high numbers of mitochondria. We can check for such violations using some diagnostics plots. In the most ideal case, we would see normal distributions that would justify the thresholds used in outlier detection. A large proportion of cells in another mode suggests that the QC metrics might be correlated with some biological state, potentially leading to the loss of distinct cell types during filtering. 

<br>

#### Dimensionality reduction

Dimensionality reduction aims to reduce the number of separate dimensions in the data. This is possible because different genes are correlated if they are affected by the same biological process. Thus, we do not need to store separate information for individual genes, but can instead compress multiple features into a single dimension. This reduces computational work in downstream analyses, as calculations only need to be performed for a few dimensions rather than thousands of genes; reduces noise by averaging across multiple genes to obtain a more precise representation of the patterns in the data, and enables effective plotting of the data.

The numbers of PCs that should be retained for downstream analyses typically range from 10 to 50. However, identifying the true dimensionality of a dataset can be challenging, that's why we recommend considering the ‘Elbow plot’ approach. a ranking of principal components based on the percentage of variance explained by each one. The assumption is that each of the top PCs capturing biological signal should explain much more variance than the remaining PCs. Thus, there should be a sharp drop in the percentage of variance explained when we move past the last “biological” PC. This manifests as an elbow in the scree plot, the location of which serves as a natural choice for a number of PCs.

## Clustering

In order to find clusters of cells we first built a graph called K-nearest neighbor (KNN), where each node is a cell that is connected to its nearest neighbors in the high-dimensional space. Edges are weighted based on the similarity between the cells involved, with higher weight given to cells that are more closely related. This step takes as input the previously defined dimensionality of the dataset (first `r param$npcs` PCs). We then applied algorithms to identify “communities” of cells that are more connected to cells in the same community than they are to cells of different communities. Each community represents a cluster that we can use for downstream interpretation. 

We can visualize the distribution of clusters in the TSNE and UMAP plots. However, we should not perform downstream analyses directly on their coordinates. These plots are most useful for checking whether two clusters are actually neighboring subclusters or whether a cluster can be split into further subclusters. 

```{r clustering plot1, fig.height=8, fig.width=20}
p1 <- DimPlot(scData, reduction="tsne", label = FALSE, pt.size = 1.5) + labs(color = "seurat_clusters")
p1 <- LabelClusters(p1, id = "ident",  fontface = "bold", color = "black", size = 6)

p2 <- DimPlot(scData, reduction="umap", label = FALSE, pt.size = 1.5) + labs(color = "seurat_clusters")
p2 <- LabelClusters(p2, id = "ident",  fontface = "bold", color = "black", size = 6)

p1 + p2 + plot_annotation(
) + plot_layout(nrow = 1)
```

<br/><br/>

The number of cells in each cluster and sample is represented in this barplot.

<br/>

```{r number of cells in each cluster}
cellIdents_perSample <- data.frame(ident = Idents(scData), Sample=scData$Sample)
barplot = ggplot(data=cellIdents_perSample, aes(x=ident, fill=Sample)) + geom_bar(stat="Count") + NoLegend()
barplot + labs(x="Cluster", y = "Number of cells", fill = "Sample") + theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust=1))


cells_prop = cellsProportion(scData, groupVar1 = "seurat_clusters", groupVar2 = "Sample")
kable(cells_prop,row.names=FALSE, format="html",caption="Cell proportions") %>% kable_styling(bootstrap_options = "striped", full_width = F, position = "float_right")
```

## Cluster assessment


#### Segregation of clusters by various sources of uninteresting variation.

Once we have created the clusters we need to assess if the clustering was driven by technical artifacts or uninteresting biological variability, such as cell cycle, mitochondrial gene expression.
We can explore whether the cells cluster by the different cell cycle phases. In such a case, we would have clusters where most of the cells would be in one specific phase. This bias could be taken into account when normalizing and transforming the data prior to clustering. We can also look at the total number of reads, genes detected and mitochondrial gene expression. The clusters should be more or less even but if we observe big differences among some of them for these metrics, we will keep an eye on them and see if the cell types we identify later can explain the differences. 

```{r cell cycle, fig.width=min(6 + clusterNameNChar*0.2, 10), fig.height = min(6 + clusterNameNChar*0.2, 10), eval=!is.null(scData@meta.data$CellCycle)}
if (any(!is.na(scData$CellCycle))){
  DimPlot(scData, label=FALSE, group.by= "CellCycle")
}
p2 <- DimPlot(scData, reduction="umap", label = FALSE, pt.size = 1.5) + labs(color = "seurat_clusters") + NoLegend()
p2 <- LabelClusters(p2, id = "ident",  fontface = "bold", color = "black", size = 6)
p2
```

```{r uninteresting variation, fig.width=min(6 + clusterNameNChar*0.2, 10), fig.height = min(6 + clusterNameNChar*0.2, 10)}
VlnPlot(scData, features ="nCount_RNA", log=TRUE) + ggtitle("Number of UMIs vs ident") + NoLegend()
FeaturePlot(scData, features="nCount_RNA", label = TRUE)

VlnPlot(scData, features ="nFeature_RNA") + ggtitle("Number of genes vs ident") + NoLegend()
FeaturePlot(scData, features="nFeature_RNA", label = TRUE)

VlnPlot(scData, features ="percent_mito") + ggtitle("Mitochondrial percentage vs ident") + NoLegend()
FeaturePlot(scData, features="percent_mito", label = TRUE)

VlnPlot(scData, features ="percent_riboprot") + ggtitle("Ribosomal protein percentage vs ident") + NoLegend()
FeaturePlot(scData, features="percent_riboprot", label = TRUE)

if (!is.null(scData@meta.data$percent_ribosomal)){
  print(VlnPlot(scData, features ="percent_ribosomal") + ggtitle("Ribosomal RNA percentage vs ident") + NoLegend())
  print(FeaturePlot(scData, features="percent_ribosomal", label = TRUE))
}

VlnPlot(scData, features ="doubletScore") + ggtitle("DoubletScore vs ident") + NoLegend()
FeaturePlot(scData, features="doubletScore", label = TRUE)
```

```{r decontx, fig.width=min(6 + clusterNameNChar*0.2, 10), fig.height = min(6 + clusterNameNChar*0.2, 10)}

if (!is.null(scData@meta.data$DecontX_contFrac)){
VlnPlot(scData, features ="DecontX_contFrac", y.max=1) + ggtitle("DecontX ambient fraction vs ident") + NoLegend()
FeaturePlot(scData, features="DecontX_contFrac", label = TRUE)
}
```

```{r soupx, fig.width=min(6 + clusterNameNChar*0.2, 10), fig.height = min(6 + clusterNameNChar*0.2, 10)}
if (!is.null(scData@meta.data$SoupX_contFrac)){
  VlnPlot(scData, features ="SoupX_contFrac", y.max=1) + ggtitle("SoupX ambient fraction vs ident") + NoLegend()
  FeaturePlot(scData, features="SoupX_contFrac", label = TRUE)
}
```

```{r cell probability, fig.width=min(6 + clusterNameNChar*0.2, 10), fig.height = min(6 + clusterNameNChar*0.2, 10)}

if (!is.null(scData@meta.data$negLog10CellPValue)){
VlnPlot(scData, features ="negLog10CellPValue") + ggtitle("negative log10 Cell PValue") + NoLegend()
FeaturePlot(scData, features="negLog10CellPValue", label = TRUE)
}
```

```{r control seq plot, fig.width=12, fig.height=shrinkToRange(length(param$controlSeqs)*3/4, c(6, 18)), eval=ezIsSpecified(param$controlSeqs)}
genesToPlot <- gsub("_", "-", param$controlSeqs)
genesToPlot <- intersect(genesToPlot, rownames(scData))
if (length(genesToPlot) > 0){
  if (length(genesToPlot) < 20){
    FeaturePlot(scData, genesToPlot) + NoLegend()
  } else {
    DoHeatmap(scData, features=genesToPlot)
    DotPlot(scData, features=genesToPlot) + coord_flip() +
      theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
  }
}
```

#### Cluster resolution 

One of the most important parameters when clustering is k, the number of nearest neighbors used to construct the graph. This controls the resolution of the clustering where higher k yields a more inter-connected graph and broader clusters. Users can experiment with different values of k to obtain a satisfactory resolution. We recommend increasing the resolution when a rare population is expected. 
Below, it is shown a clustering tree that helps us to visualize the relationships between clusters at a range of resolutions. Each cluster forms a node in the tree and edges are constructed by considering the cells in a cluster at a lower resolution that end up in a cluster at the next highest resolution. By connecting clusters in this way, we can see how clusters are related to each other, which are clearly distinct and which are unstable. The size of each node is related to the number of cells in each cluster and the color indicates the clustering resolution. Edges are colored according to the number of cells they represent and the transparency shows the incoming node proportion, the number of cells in the edge divided by the number of samples in the node it points to. 

```{r clustree, fig.align='center', fig.width=8, fig.height=8}
clustree::clustree(scData, prefix = paste0(DefaultAssay(scData), "_snn_res."))
```

## Cluster markers

```{r wilcoxon test, eval=(param$DE.method=="wilcox"), results='asis'}
cat("We found positive markers that defined clusters compared to all other cells via differential expression. The test we used was the Wilcoxon Rank Sum test. Genes with an average, at least 0.25-fold difference (log-scale) between the cells in the tested cluster and the rest of the cells and an adjusted p-value < 0.05 were declared as significant.")
```

```{r LR test, eval=(param$DE.method=="LR"), results='asis'}
cat("We found positive markers that defined clusters compared to all other cells via differential expression using a logistic regression test and including in the model the cell cycle as the batch effect. Genes with an average, at least 0.25-fold difference (log-scale) between the cells in the tested cluster and the rest of the cells and an adjusted p-value < 0.05 were declared as significant.")
```


```{r pos markers}
ezInteractiveTableRmd(data.frame(posMarkers), digits=4)
```

## Marker plots

Here, we use a heatmap and a dotplot to visualize simultaneously the top 5 markers in each cluster. Be aware that some genes may be in the top markers for different clusters.

<br/>

```{r marker plot setup}
top5 <- posMarkers %>% 
  group_by(cluster) %>%
  slice_max(n = 5, order_by = tibble(diff_pct, avg_log2FC))
genesToPlot <- c(gsub("_", "-", param$controlSeqs), unique(as.character(top5$gene)))
genesToPlot <- intersect(genesToPlot, rownames(scData))
```

#### Heatmap & DotPlot

```{r marker heatmap, fig.width=12, fig.height=length(levels(Idents(scData)))}
DoHeatmap(scData, features=unique(genesToPlot))
DotPlot(scData, features=genesToPlot) + coord_flip() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
```

#### Group-wise DE Plot

```{r marker groupwise plot, fig.width=13, fig.height=length(levels(Idents(scData)))}
do_GroupwiseDEPlot(sample = scData,
                   de_genes = posMarkers %>% 
                     mutate(gene=as.character(gene),
                            p_val_adj=ifelse(p_val_adj < 1e-100, 1e-100, p_val_adj)),
                   min.cutoff = NA) ## setting a min.cutoff may crash the plot in instances where no average expression is above the cutoff
```

```{r plot of user genes, fig.width=12, fig.height=shrinkToRange(length(param$controlSeqs)/5, c(6, 12)), eval=ezIsSpecified(param$controlSeqs)}
genesToPlot <- intersect(param$controlSeqs, rownames(scData))

if (length(genesToPlot) > 0){
  DoHeatmap(scData, features=unique(genesToPlot))
  DotPlot(scData, features=genesToPlot) + coord_flip() +
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
} else { 
  cat("controlseqs not found")
}
```

## Cell type annotation {.tabset}


### EnrichR

Cell type scoring using the EnrichR tool. This approach consists in performing a gene set enrichment analysis on the marker genes defining each cluster. This identifies the pathways and processes that are (relatively) active in each cluster based on the upregulation of the associated genes compared to other clusters.

```{r query online enrichR version, echo=FALSE, results='asis'}
markersPerClusterTable <- c()
eachCluster <- 0
for (eachCluster in levels(posMarkers$cluster)) {
  markersPerCluster <- dplyr::filter(posMarkers, cluster == eachCluster) %>%
    dplyr::arrange(desc(avg_log2FC))
  markersPerCluster <- head(markersPerCluster, min(nrow(markersPerCluster), 500))
  markersPerClusterTable <- rbind(markersPerClusterTable,markersPerCluster)
}

genesPerCluster <- split(markersPerClusterTable$gene, markersPerClusterTable$cluster)
jsCall = paste0('enrich({list: "', sapply(genesPerCluster, paste, collapse="\\n"), '", popup: true});')
enrichrCalls <- paste0("<a href='javascript:void(0)' onClick='", jsCall, 
                       "'>Analyse at Enrichr website</a>")
```



```{r enrichr markers, echo=FALSE, results='asis'}
enrichrTable <- tibble(Cluster=names(genesPerCluster),
                       "# of posMarkers"=lengths(genesPerCluster),
                       "Enrichr link"=enrichrCalls)
if (!is.null(enrichRout) && length(enrichRout) > 0){
  enrichRTerm <- as.data.frame(do.call(rbind, lapply(enrichRout, as.vector)))
  enrichRTerm <- map_df(enrichRTerm, ~ map_df(.x, ~ replace(.x, is.null(.x), NA)), .id = "database")
  enrichRTerm <- enrichRTerm %>%
    group_by(., Cluster, database) %>%
    summarise(topTerms = paste(Term, collapse = "; ")) %>%
    as.data.frame()
  if(nrow(enrichRTerm)>0){
    enrichRTerm <- reshape2::dcast(enrichRTerm, ... ~ database)
    enrichrTable <- merge(enrichrTable, enrichRTerm, by = "Cluster")
  }
}

kable(enrichrTable, format="html", escape=FALSE,
      caption=paste0("GeneSet enrichment")) %>%
  kable_styling("striped", full_width = F, position = "left")
```



```{r plot enrichR per cluster, fig.height=5, fig.width=10, eval= !is.null(enrichRout)}
for (cluster in names(enrichRout)) {
  enrichRDataFrame <- as.data.frame(do.call(rbind, enrichRout[[cluster]]))
  enrichRDataFrame$database <- sapply(rownames(enrichRDataFrame), function(x) str_split(x, "[.]")[[1]][1])
  print(ggplot(as.data.table(enrichRDataFrame), aes(database, Term))
        +
          geom_point(aes(color = OverlapGenesN, size = Combined.Score))
        +
          scale_color_viridis()
        +
          scale_fill_viridis()
        +
          labs(y = "Term", x = "Cluster", title = paste0("Cluster: ", cluster))
        +
          theme_bw()
        +
          theme(
            axis.title.x = element_blank(),
            axis.text.x = element_text(angle = 45, hjust = 1)
          ))
}
```


<br/>

### SingleR

Matching of clusters to annotated reference datasets using SingleR.

```{r singler, fig.height=12, fig.width=12, results = 'asis', eval= !is.null(singler.results)}
clusterInfosList <- list()
plotlyPlots <- list()
nTopMarkers <- 10
for (r in names(singler.results)) {
  cat("##### Heatmap: ", r, "\n\n")
  print(plotScoreHeatmap(singler.results[[r]]$single.fine))
  print(plotScoreHeatmap(singler.results[[r]]$cluster.fine, show_colnames = TRUE))
  cat("\n\n")
  singler.single.labels <- singler.results[[r]]$single.fine$labels
  singler.cluster.labels <- singler.results[[r]]$cluster.fine$labels[match(Idents(scData), rownames(singler.results[[r]]$cluster.fine))]
  
  cellInfo <- tibble(
    Cells = colnames(scData), 
    Cluster = Idents(scData), 
    SingleR.labels.cluster = singler.cluster.labels, 
    SingleR.labels.single = singler.single.labels)  %>%
    left_join(as_tibble(scData@reductions$umap@cell.embeddings, rownames="Cells"))
  
  nrOfLabels_cluster <- length(unique(cellInfo$SingleR.labels.cluster))
  nrOfLabels_single <- length(unique(cellInfo$SingleR.labels.single))
  
  if(nrOfLabels_single <= 9){
    colsLabels <- brewer.pal(nrOfLabels_single, "Set1")
  }else{
    colsLabels <- colorRampPalette(brewer.pal(9, "Set1"))(nrOfLabels_single)
  }
  
  x <- list(title="umap_1", zeroline=FALSE)
  y <- list(title="umap_2", zeroline=FALSE)
  
  p1 <- plot_ly(cellInfo, x = ~umap_1, y = ~umap_2, color=~SingleR.labels.single,
                text = ~paste("Cluster: ", Cluster,
                              "\nCell: ", Cells,
                              "\nSingleR.labels.cluster: ", 
                              SingleR.labels.single),
                type = 'scatter', mode = "markers", marker=list(size=5, opacity=0.5),
                colors=colsLabels, width=800, height=500) %>%
    layout(xaxis=x, yaxis=y, title=paste0(r, ": Single"))
  p2 <- plot_ly(cellInfo, x = ~umap_1, y = ~umap_2, color=~SingleR.labels.cluster,
                text = ~paste("Cluster: ", Cluster,
                              "\nCell: ", Cells,
                              "\nSingleR.labels.cluster: ", SingleR.labels.cluster),
                type = 'scatter', mode = "markers", marker=list(size=5, opacity=0.5),
                colors=colsLabels, width=800, height=500) %>%
    layout(xaxis=x, yaxis=y, title=paste0(r, ": Cluster"))
  plotlyPlots <- append(plotlyPlots, list(p1, p2))
  cat("\n\n")
  clusterInfos <- ezFrame(Sample=as.character(unique(scData$Sample)), 
                          Reference=r,
                          Cluster=levels(Idents(scData)))
  if (!is.null(singler.results)){
    clusterInfos$SinglerCellType <- singler.results[[r]]$cluster.fine[clusterInfos$Cluster, "pruned.labels"]
  }
  topMarkers <- posMarkers %>% group_by(cluster) %>%
    slice_max(n = nTopMarkers, order_by = avg_log2FC)
  topMarkerString <- sapply(split(topMarkers$gene, topMarkers$cluster), paste, collapse=", ")
  clusterInfos[["TopMarkers"]] <- topMarkerString[clusterInfos$Cluster]
  clusterInfos[["Percentage of Cells"]] <- table(Idents(scData)) / nrow(scData)
  clusterInfosList <- append(clusterInfosList, list(clusterInfos))
  cat("\n\n")
}
```

<br>

```{r singler labelsUMAP, results = 'asis', eval=!is.null(singler.results)}
cat("##### UMAPs with SingleR Labels\n\n")
cat("The single cell (top) and cluster (bottom) annotations are also shown on the UMAPs. Place the mouse over the cells to get information such as their UMAP coordinates, original cluster, the cells name and the label assigned by SingleR. You can also zoom in specific areas of the UMAP by dragging and drop with the mouse.\n")
tl <- htmltools::tagList(plotlyPlots)
tl
cat("\n\n")
```

<br/>

```{r singler labelsTable, results = 'asis', eval=!is.null(singler.results)}
cat("##### Table of SingleR Labels\n\n")
cat(sprintf("The following table summarises the cluster-level labels for each reference (%s) and displays the top %s genes for that cluster in terms of their average log2-fold change. Note the top markers for every cluster will be identical regardless of reference used since this information is specific to the cluster and not the annotation reference.", paste(names(singler.results), collapse=", "), nTopMarkers))
ezInteractiveTableRmd(bind_rows(clusterInfosList))
cat("\n\n")
```

### AUCell

Matching the cells to marker gene sets that are known to be characteristic for cell types. We use marker gene sets from the CellMarker database (Zhang X., Lan Y., Xu J., Quan F., Zhao E., Deng C., et al. (2019). CellMarker: a manually curated resource of cell markers in human and mouse. Nucleic Acids Res. 47, D721–d728. 10.1093/nar/gky900). 

```{r AUC assigments, eval= !is.null(cells.AUC)}
tab <- NULL
try({
  ## in some extreme situations the default value of smallesPopPercent crashes 
  cells_assignment <- AUCell_exploreThresholds(cells.AUC, plotHist=FALSE, assign=TRUE, nCores = param$cores) 
  cellsAssigned <- lapply(cells_assignment, function(x) x$assignment)
  assignmentTable <- reshape2::melt(cellsAssigned, value.name="cell")
  colnames(assignmentTable)[2] <- "geneSet"
  tras_cells.AUC <- t(assay(cells.AUC))
  full.labels <- colnames(tras_cells.AUC)[max.col(tras_cells.AUC)]
  tab <- table(full.labels, Idents(scData))
  var_height <- shrinkToRange(nrow(tab)*0.5, c(6,16))
})

```

```{r assigments, eval= !is.null(cells.AUC), results='asis'}
cat("We can explore the cell assignment results using different plots. Below, we show a heatmap that represents the number of cells (in log scale) from each cluster that were assigned to the different cell types. After calculating an AUC score for each cell and cell type, we assign cell type identity by taking the cell type with the top AUC as the label for that cell. Some cell types may be missing because no cells obtained their top AUC score for it.")
cat("\n\n")
```

```{r assigments heatmap, eval= !is.null(cells.AUC), results='asis',fig.align='center', fig.width=10, fig.height=var_height}
if (!is.null(tab) && nrow(tab) > 2) {
  pheatmap(log10(tab+10), color=viridis::viridis(100))
}
```


```{r tsne and AUC res, eval= !is.null(cells.AUC), results='asis'}
cat("The plots below show for every cell type:\n")
cat('\n')
cat("1) The distribution of the AUC values in the cells. The ideal situation will be a bi-modal distribution, in which most cells in the dataset have a low “AUC” compared to a population of cells with a higher value.  The size of the gene-set will also affect the results. With smaller gene-genes (fewer genes), it is more likely to get cells with AUC = 0. While this is the case of the “perfect markers” it is also easier to get it by chance with small datasets. The vertical bars correspond to several thresholds that could be used to consider a gene-set ‘active’. The thickest vertical line indicates the threshold selected by default: the highest value to reduce the false positives.\n")
cat('\n')
cat("2) The t-SNE can be colored based on the AUC scores. To highlight the cluster of cells that are more likely of the cell type according to the signatures, we split the cells into cells that passed the assignment threshold (colored in blue), and cells that didn’t (colored in gray).\n")
cat('\n')
cat("3) The last TSNE represents the AUC scores values. The darker a cell is the higher AUC score it obtained, i.e. the cell is more enriched in that cell type.")
cat('\n')
cellsUmap <- scData@reductions$umap@cell.embeddings
minAucThresh = 0.2
filtered_cells.AUC <- cells.AUC[rowSums(assay(cells.AUC) >= minAucThresh)>0, ]
maxAucScore = rowMax(assay(filtered_cells.AUC))
scoreOrder = order(maxAucScore, decreasing = TRUE)
nPlots = 50
```

```{r tsne and AUC hist, eval= !is.null(cells.AUC), fig.height=5, fig.width=5}
try({
  AUCell_plotTSNE(tSNE=cellsUmap,
                  cellsAUC=filtered_cells.AUC[head(scoreOrder, nPlots), ],
                  plots = c("histogram", "binaryAUC"))
})
```

### Azimuth

```{r azimuth, eval=!is.null(scData@meta.data$Azimuth.celltype.l1), fig.width=15, fig.height=8}
options(ggrepel.max.overlaps = Inf)

cat(sprintf("Analysis was performed using the Azimuth reference map: %s", param$Azimuth))

DimPlot(scData, label=TRUE, group.by = "Azimuth.celltype.l1", repel = TRUE, reduction = "umap", cols = shared_colors) +
  theme(aspect.ratio = 1)
if('Azimuth.celltype.l2' %in% colnames(scData@meta.data))
  DimPlot(scData, label=TRUE, group.by = "Azimuth.celltype.l2", repel = TRUE, reduction = "umap", cols = shared_colors) +
  theme(aspect.ratio = 1)
if('Azimuth.celltype.l3' %in% colnames(scData@meta.data))
  DimPlot(scData, label=TRUE, group.by = "Azimuth.celltype.l3", repel = TRUE, reduction = "umap", cols = shared_colors) +
  theme(aspect.ratio = 1)
if('Azimuth.celltype.l4' %in% colnames(scData@meta.data))
  DimPlot(scData, label=TRUE, group.by = "Azimuth.celltype.l4", repel = TRUE, reduction = "umap", cols = shared_colors) +
  theme(aspect.ratio = 1)
```

### Azimuth Pan-Human

`r if(azimuth_available) "Azimuth Pan-Human provides neural network-based cell type annotation using the Satija lab reference (HUMAN DATASETS ONLY)."`

```{r azimuth panhuman results, eval=azimuth_available, results='asis', fig.width=15, fig.height=11}
if(azimuth_available && !is.null(azimuth_results)){
  cat("**Reference:** Pan-Human Azimuth neural network model (CloudAzimuth)\n\n")
  
  scData_az <- azimuth_results$scData
  
  # Count annotated cells
  if("final_level_labels" %in% colnames(scData_az@meta.data)){
    n_annotated <- sum(!is.na(scData_az@meta.data$final_level_labels))
    cat("**Cells annotated:** ", n_annotated, "\n\n")
  }
  
  # 1. Final level labels UMAP
  if("final_level_labels" %in% colnames(scData_az@meta.data)){
    cat("#### Final Level Cell Types\n\n")
    reduction_to_use <- if("azimuth_umap" %in% names(scData_az@reductions)) "azimuth_umap" else "umap"
    print(DimPlot(scData_az, group.by = "final_level_labels", label = TRUE, repel = TRUE, 
                  reduction = reduction_to_use, cols = shared_colors) + 
            ggtitle("Azimuth Pan-Human: Final Level Labels") + 
            theme(legend.position = "right") +
            guides(color = guide_legend(override.aes = list(size = 3), ncol = 2)) +
            coord_fixed())
    cat("\n\n")
  }
  
  # 2. Azimuth broad labels
  if("azimuth_broad" %in% colnames(scData_az@meta.data)){
    cat("#### Broad Level Cell Types\n\n")
    reduction_to_use <- if("azimuth_umap" %in% names(scData_az@reductions)) "azimuth_umap" else "umap"
    print(DimPlot(scData_az, group.by = "azimuth_broad", label = TRUE, repel = TRUE, 
                  reduction = reduction_to_use, cols = shared_colors) + 
            ggtitle("Azimuth Pan-Human: Broad Level Labels") +
            theme(legend.position = "right") +
            guides(color = guide_legend(override.aes = list(size = 3), ncol = 2)) +
            coord_fixed())
    cat("\n\n")
  }
  
  # 3. Azimuth medium labels
  if("azimuth_medium" %in% colnames(scData_az@meta.data)){
    cat("#### Medium Level Cell Types\n\n")
    reduction_to_use <- if("azimuth_umap" %in% names(scData_az@reductions)) "azimuth_umap" else "umap"
    print(DimPlot(scData_az, group.by = "azimuth_medium", label = TRUE, repel = TRUE, 
                  reduction = reduction_to_use, cols = shared_colors) + 
            ggtitle("Azimuth Pan-Human: Medium Level Labels") +
            theme(legend.position = "right") +
            guides(color = guide_legend(override.aes = list(size = 3), ncol = 2)) +
            coord_fixed())
    cat("\n\n")
  }
  
  # 4. Azimuth fine labels
  if("azimuth_fine" %in% colnames(scData_az@meta.data)){
    cat("#### Fine Level Cell Types\n\n")
    reduction_to_use <- if("azimuth_umap" %in% names(scData_az@reductions)) "azimuth_umap" else "umap"
    print(DimPlot(scData_az, group.by = "azimuth_fine", label = TRUE, repel = TRUE, 
                  reduction = reduction_to_use, cols = shared_colors) + 
            ggtitle("Azimuth Pan-Human: Fine Level Labels") +
            theme(legend.position = "right") +
            guides(color = guide_legend(override.aes = list(size = 3), ncol = 2)) +
            coord_fixed())
    cat("\n\n")
  }
  
  # 5. Confidence scores FeaturePlot
  if("final_level_softmax_prob" %in% colnames(scData_az@meta.data)){
    cat("#### Confidence Scores by Cell\n\n")
    reduction_to_use <- if("azimuth_umap" %in% names(scData_az@reductions)) "azimuth_umap" else "umap"
    print(FeaturePlot(scData_az, features = "final_level_softmax_prob", 
                      reduction = reduction_to_use) + 
            ggtitle("Azimuth Pan-Human: Confidence Scores") +
            scale_colour_viridis_c() +
            coord_fixed())
    cat("\n\n")
  }
  
  # 6. Histogram of softmax probabilities
  if("final_level_softmax_prob" %in% colnames(scData_az@meta.data)){
    cat("#### Confidence Score Distribution\n\n")
    library(ggplot2)
    p <- ggplot(scData_az@meta.data, aes(x = final_level_softmax_prob)) +
      geom_histogram(bins = 30, fill = "skyblue", color = "white", alpha = 0.8) +
      theme_minimal() +
      labs(title = "Azimuth Pan-Human: Softmax Probabilities",
           x = "Softmax Probability", 
           y = "Number of Cells")
    print(p)
    cat("\n\n")
  }
}
```

### Cell x gene
```{r cellxgene, eval=!is.null(cellxgeneResults), fig.width=7, fig.height=7}

options(ggrepel.max.overlaps = Inf)
n_celltype <- length(unique(scData$predicted.id.cellxgene.authorlabel))
sample_name <- names(scData)
# print("The URL of the reference data is:")
# print(param$cellxgeneUrl)
## get the DOI
d = datasets()
c = collections()
dataset_version_id_URL <- gsub("\\.rds$", "", basename(param$cellxgeneUrl))
collection_id_URL <- as.character(d |> filter(dataset_version_id == dataset_version_id_URL) |> 
                                    select(collection_id))
DOI <- c |> filter(collection_id == collection_id_URL) |> select(doi)
# print("The DOI of this dataset is:")
# print(paste0("https://doi.org/", DOI))

## dimplot of prediction.id.cellxgene.authorlabel
p1 <- DimPlot(scData, label = TRUE, repel = TRUE, group.by = 'predicted.id.cellxgene.authorlabel', cols = shared_colors) + 
  ggtitle(paste(sample_name, "- CellxGene - Predicted ID"))

## plots of mapping score
p2 <- FeaturePlot(scData,features = "prediction.score.max", cols = c("lightgrey", "dodgerblue"), pt.size = 1, max.cutoff = 'q97', order = T )+ggtitle(paste(sample_name, "- mapping score"))

## mapping quality by Vlnplots
p3 <- VlnPlot(scData, features = 'prediction.score.max', group.by = 'predicted.id.cellxgene.authorlabel', cols = shared_colors) +
  ggtitle(paste(sample_name, "- prediction.score.max grouped by author's cell label"))

```

```{r cellxgene_2, eval=!is.null(cellxgeneResults), echo=FALSE, message=FALSE, results="asis"}
cat("\n\n* The URL of the reference data is:", param$cellxgeneUrl)
cat("\n\n* The DOI of this dataset is:", ifelse(length(DOI) > 0, paste0("https://doi.org/", DOI), "DOI not available"))
```

```{r cellxgene_3, eval=!is.null(cellxgeneResults), fig.width=14, fig.height=12}
tryCatch({
  # Print plots individually with coord_fixed
  print(p1 + coord_fixed())
  print(p2 + coord_fixed())
  print(p3 )
}, error = function(e) {
  # If coord_fixed fails, print plots as-is
  print(p1)
  print(p2)
  print(p3)
})
```

### scType

`r if(sctype_available) "scType provides fully-automated cell-type identification using specific marker combinations (human and mouse supported)."`

```{r sctype results, eval=sctype_available, results='asis', fig.width=14, fig.height=10}
if(sctype_available && !is.null(sctype_results)){
  cat("**Detected tissue:** ", sctype_results$tissue_type, "\n\n")
  
  scData_sc <- sctype_results$scData
  
  # 1. scType cell type classification UMAP
  if("sctype_classification" %in% colnames(scData_sc@meta.data)){
    cat("#### scType Cell Type Classification\n\n")
    print(DimPlot(scData_sc, reduction = "umap", label = TRUE, repel = TRUE, 
                  group.by = 'sctype_classification', cols = shared_colors) +
            ggtitle(paste("scType Cell Type Annotation -", sctype_results$tissue_type)) +
            theme(legend.position = "right") +
            coord_fixed())
    cat("\n\n")
  }
  
}
```

## Interactive

The link below will take you to an interactive Shiny app which can be used to make 
production-ready plots and figures. You can also use this app to explore your own markers and create corresponding feature plots.

[Single Cell Explorer](`r {paste0("https://fgcz-shiny.uzh.ch/exploreSC", "/?data=",output$getColumn("SC Cluster Report"), "/scData.qs2")}`){target="_blank"}

### Data availability

[clusterInfos.xlsx](clusterInfos.xlsx) -- use this xls file to manually relabel the clusters

[posMarkers](posMarkers.xlsx) -- Excel table with all marker genes 

[scData.qs2](scData.qs2) -- final seurat object in [qs2 format](https://github.com/qsbase/qs2)

`r if(sctype_available) "[scType_results.xlsx](scType_results.xlsx) -- scType cell type annotation results"`

## SessionInfo
```{r report parameters, echo=FALSE}
param[c("npcs","pcGenes","resolution", "SCT.regress.CellCycle", "DE.method", "cellsFraction", "nUMIs", "nmad", "normalize")]
```


```{r, echo=FALSE}
ezSessionInfo()
```

```{r save_final_scData, echo=FALSE, message=FALSE}
# Save final scData object with all metadata (including cellxgene, azimuth, etc.)
# This ensures the final object includes all annotation results from the report
qs2::qs_save(scData, "scData.qs2", nthreads = param$cores)
```
