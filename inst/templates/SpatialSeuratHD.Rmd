---
title: "`r if (exists('reportTitle')) reportTitle else 'SUSHI Report'`"
output: 
  html_document:
    mathjax: https://fgcz-gstore.uzh.ch/reference/mathjax.js
    self_contained: true
    includes:
      in_header: !expr system.file("templates/fgcz_header.html", package="ezRun")
    css: !expr system.file("templates/fgcz.css", package="ezRun")
editor_options: 
  chunk_output_type: inline
---

# {.tabset}

## Quality control

`r format(Sys.time(), '%Y-%m-%d %H:%M:%S')`


```{r setup, include=FALSE}
library(Seurat)
library(ggplot2)
library(patchwork)
library(dplyr)
library(RColorBrewer)
library(kableExtra)
library(clustree)
library(ezRun)
library(scater)
library(SingleCellExperiment)
library(enrichR)
library(SCpubr)
library(qs2)

library(DT)
library(scater)
library(ggtext)
library(grid) 
library(htmltools)
library(patchwork)
library(scales)
library(UpSetR)

knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, knitr.table.format = "html")
```


```{r}
posMarkers <- readxl::read_xlsx("posMarkers.xlsx")
param <- qs_read("param.qs2")
input <- qs_read("input.qs2")
output <- qs_read("output.qs2")
scData <- qs_read("scData.qs2")
scData.unfiltered_spatial <- qs_read("scData.unfiltered.qs2")
imageName <- names(scData@images)
nCountCol <- grep('^nCount_Spatial.*', colnames(scData@meta.data), value=TRUE) %>% head(1)
nFeatureCol <- grep('^nFeature_Spatial.*', colnames(scData@meta.data), value=TRUE) %>% head(1)

allCellsMeta <- qs_read("allCellsMeta.qs2")
sampleName <- input$getNames()

if (file.exists("cellsPerGeneFraction.qs2")){
  cellsPerGeneFraction <-  qs_read("cellsPerGeneFraction.qs2")
} else {
  cellsPerGeneFraction <- NULL
}

enrichRout <- NULL
aziResults <- NULL

# Process the posMarkers
posMarkers$gene = as.factor(posMarkers$gene)
# make sure the loaded cluster uses proper integer ordering if all levels are integer!
clusterSet <- posMarkers$cluster %>% as.integer() %>% unique() %>% sort(na.last=TRUE)
if (any(is.na(clusterSet))){
  posMarkers$cluster = as.factor(posMarkers$cluster)
} else {
  posMarkers$cluster = factor(posMarkers$cluster, levels=clusterSet)
}
posMarkers$p_val_adj[posMarkers$p_val_adj==0] <- min(posMarkers$p_val_adj[posMarkers$p_val_adj>0])
```


```{r}
xxAll <- SingleCellExperiment(colData = allCellsMeta)
xxAll$discard <- !xxAll$useCell
colData(xxAll)$Sample<- sampleName
scData.unfiltered <- CreateSeuratObject(ezMatrix(0, rows=1:10, cols=rownames(allCellsMeta)), meta.data = allCellsMeta)
scData.unfiltered$discard <- !colnames(scData.unfiltered) %in% colnames(scData)
```

```{r}
rgb_order <- function(obj, 
                      img_name = Images(obj)[1],
                      eps = 0.02, 
                      margin = 0.01) {
  
  arr <- as.array(obj@images[[img_name]]@image)

  # Normalize if stored as 8/16-bit (no-op if already 0..1)
  mx <- suppressWarnings(max(arr, na.rm = TRUE)); if (!is.finite(mx) || mx == 0) mx <- 1
  if (mx > 1) arr <- arr / mx

  # if RGBA: composite over white, drop alpha
  if (length(dim(arr)) == 3 && dim(arr)[3] == 4) {
    A <- arr[,,4]; RGB <- arr[,,1:3]
    for (k in 1:3) RGB[,,k] <- RGB[,,k]*A + (1 - A)
    arr <- RGB
  }
  stopifnot(length(dim(arr)) == 3, dim(arr)[3] >= 3)
  arr <- arr[,,1:3, drop = FALSE]

  # mask out near-black background; keep pixels with any channel > eps
  mask <- apply(arr > eps, c(1,2), any)
  if (!any(mask)) mask <- matrix(TRUE, nrow = dim(arr)[1], ncol = dim(arr)[2])

  mR <- mean(arr[,,1][mask], na.rm = TRUE)
  mB <- mean(arr[,,3][mask], na.rm = TRUE)

  if (is.finite(mR) && is.finite(mB) && (mB > mR + margin)) {
    arr <- arr[,,c(3,2,1), drop = FALSE]
    chosen <- "BGR->RGB (swapped)"
  } else {
    chosen <- "RGB (kept as-is)"
  }

  obj@images[[img_name]]@image <- arr
  message(sprintf("Channel order decided by means on tissue: R=%.3f, B=%.3f -> %s",
                  mR, mB, chosen))
  obj
}

img_name <- Images(scData)[1]

scData   <- rgb_order(scData, 
                      img_name, 
                      eps = 0.02, 
                      margin = 0.01)


```


```{r template for spatialFeaturePlot}

sp_plot <- function(obj,
                    feature,
                    title = feature,
                    label = feature,
                    pt.size.factor = 2,
                    min.cutoff = "q01",
                    max.cutoff = "q99",
                    legend.pos = "right",
                    palette = "turbo",
                    ...) {

  SpatialFeaturePlot(
    object         = obj,
    features       = feature,
    pt.size.factor = pt.size.factor,
    min.cutoff     = min.cutoff,
    max.cutoff     = max.cutoff,
    ...                   
  ) +
    labs(title = title, fill = label) +
    scale_fill_viridis_c(option = palette, 
                         na.value = "grey95") +
    theme_void() +
    theme(
      legend.position   = legend.pos,
      plot.title        = element_text(size = 12, 
                                       face = "bold", 
                                       margin = margin(b = 4)),
      legend.title      = element_text(size = 8),
      legend.text       = element_text(size = 8),
      legend.key.height = unit(10, "pt"),
      legend.key.width  = unit(6, "pt")
    )

}

#if(any(is.nan(scData.unfiltered_spatial$percent_mito))){
#  toKeep <- rownames(scData.unfiltered_spatial@meta.data)[-which(is.nan(scData.unfiltered_spatial$percent_mito))]
#  scData.unfiltered_spatial <- subset(scData.unfiltered_spatial, cells = toKeep)
#}
```


### QC diagnostic plots

<details>
  <summary>Metrics to identify bins (spots) of low quality</summary>
  
```{r QC metrics, echo=F, message=F, warning=F}

qcMetrics <- tibble(
  metric = character(),
  interpretation = character()
) |>
  add_row(
    metric = "Library size – total sum of counts across all relevant features for each spot",
    interpretation = "Small library sizes indicate low quality (RNA may have been lost during library preparation)"
  ) |>
  add_row(
    metric = "Number of expressed genes with non-zero counts in each spot",
    interpretation = "Very few expressed genes means poor capture of the transcript population"
  ) |>
  add_row(
    metric = "Mitochondrial proportion – percentage of reads mapping to mitochondrial genes in each spot",
    interpretation = "High mitochondrial proportion indicate poor quality (loss of cytoplasmic RNA from perforated bins) (Islam et al. 2014; Ilicic et al. 2016)"
  )

datatable(
  qcMetrics,
  class = 'compact cell-border stripe', #or 'cell-border stripe'
  # caption = htmltools::tags$caption(
  #   style = 'caption-side: top; text-align: left; font-weight: bold; font-size: 16px;',
  #   "QC Metrics Used to Identify Low-Quality Bins"
  # ),
  escape = FALSE,
  rownames = FALSE,
  colnames = rep("", ncol(qcMetrics)),
  options = list(
    autoWidth = TRUE,
    dom = 't'  
  )
) |> 
  formatStyle(
    columns = names(qcMetrics)  
  )

```

Evaluation


```{r diagnostics plots, echo=F, message=F, warning=F}

qcDiagnostics <- tibble(
  check = character(),
  interpretation = character()
) |>
  add_row(
    check = "Independence of QC metrics",
    interpretation = "QC metrics should reflect technical quality, not biological state (e.g., low library size or high mitochondrial proportion should not correspond to specific cell types)."
  ) |>
  add_row(
    check = "Distribution of values",
    interpretation = "Ideally, metrics follow a normal distribution, supporting threshold-based outlier detection."
  ) |>
  add_row(
    check = "Secondary modes",
    interpretation = "A large secondary peak (another mode) suggests correlation with biology, risking loss of distinct cell types."
  ) |>
  add_row(
    check = "Violin plots",
    interpretation = "Show bins kept (`FALSE`) vs discarded (`TRUE`) after QC filtering, highlighting potential biases."
  ) |>
  add_row(
    check = "Spatial plots",
    interpretation = "Visualize QC metrics across the tissue to detect spatial patterns of low quality."
  )

datatable(
  qcDiagnostics,
#   caption = htmltools::tags$caption(
#     style = 'caption-side: top; text-align: left; font-weight: bold; font-size: 16px;',
#     "Diagnostic Plots Used for QC Evaluation"
#   ),
  class = 'cell-border stripe',
  escape = FALSE,
  rownames = FALSE,
  #colnames = rep("", ncol(qcDiagnostics)), 
  options = list(
    autoWidth = TRUE,
    dom = 't' 
  )
) |> 
  formatStyle(
    columns = names(qcDiagnostics)
  )

```
</details>


```{r 1st line of plots, fig.width=12, fig.height=4}

plot1 <- plotColData(
  xxAll, x = "Sample", 
  y = nCountCol, 
  colour_by = "discard"
) +
  scale_y_log10() +
  labs(title = "UMI counts", y = "UMI counts per spot") +
  theme(
    legend.position = "top",
    axis.title.x = element_blank(),
    axis.ticks.y = element_blank(),
    axis.ticks.x = element_blank()
  )

plot2 <- sp_plot(
  scData, nCountCol,
  title = "UMI per spot",
  label = "UMI counts"
)

plot3 <- sp_plot(
  scData, nCountCol,
  title  = "Raw image",
  label  = NULL,
#  images = img_name,
  alpha  = c(0, 0)
) + guides(fill = "none")




plot1 + plot2 + plot3

```


```{r 2nd line of plots, fig.width=12, fig.height=4}
plot4 <- plotColData(
  xxAll,
  x = "Sample",
  y = nFeatureCol,
  colour_by = "discard"
) +
  labs(
    title = "Detected genes",
    y = "Number of detected genes"
  ) +
  theme(
    legend.position = "none", 
    axis.title.x = element_blank(),
    axis.ticks.y = element_blank(),
    axis.ticks.x = element_blank()
  )

plot5 <- sp_plot(
  scData, 
  nFeatureCol,
  title = "",
  label = "Genes"
)

plot6 <- plotColData(
  xxAll,
  x = nCountCol,
  y = nFeatureCol,
  colour_by = "discard"
) +
  scale_x_log10() +
  scale_y_log10() +
  labs(
    title = "",
    x = "UMI counts",
    y = "Detected genes"
  ) +
  theme(
    legend.position = "none", 
    axis.ticks.y = element_blank(),
    axis.ticks.x = element_blank()
  )

plot4 + plot5 + plot6

```


```{r 3th line of plots, fig.width=12, fig.height=4}

plot7 <- plotColData(
  xxAll,
  x = "Sample",
  y = "percent_mito",
  colour_by = "discard"
) +
  labs(
    title = "Mito percent",
    y = "Percent mitochondrial reads"
  ) +
  theme(
    legend.position = "none", 
    axis.title.x = element_blank(),
    axis.ticks.y = element_blank(),
    axis.ticks.x = element_blank(),
    plot.margin = margin(2, 2, 2, 2) 
    )

plot8 <- sp_plot(
  scData, 
  "percent_mito",
  title = "",
  label = "Mito %"
)


plot9 <- plotColData(
  xxAll,
  x = nCountCol,
  y = "percent_mito",
  colour_by = "discard"
) +
  scale_x_log10() +
  labs(
    x = "UMI counts",
    y = "Percent mitochondrial reads"
  ) +
  theme(
    legend.position = "none", 
    axis.ticks.y = element_blank(),
    axis.ticks.x = element_blank(),
    plot.margin = margin(2, 2, 2, 2) 
  )



plot7 + plot8 + plot9

```

```{r 4th line of plots, fig.width=12, fig.height=4}

if (!is.null(xxAll$percent_riboprot)) {

   plot10 <- plotColData(
      xxAll,
      x = "Sample",
      y = "percent_riboprot",
      colour_by = "discard"
    ) +
      labs(
        title = "Ribosomal percent",
        y = "Percent ribosomal protein reads"
      ) +
      theme(
        legend.position = "none",
        axis.title.x = element_blank(),
        axis.ticks.y = element_blank(),
        axis.ticks.x = element_blank()
      )
  
   
   plot11 <- sp_plot(
     scData, "percent_riboprot",
     title = "",
     label = "Ribo %"
   )

    plot12 <- plotColData(
      xxAll,
      x = nCountCol,
      y = "percent_riboprot",
      colour_by = "discard"
    ) +
      scale_x_log10() +
      labs(
        x = "UMI counts",
        y = "Percent ribosomal protein reads"
      ) +
      theme(
        legend.position = "none",
        axis.ticks.y = element_blank(),
        axis.ticks.x = element_blank()
      )
  
}

plot10 + plot11 + plot12

```

```{r genes by count, fig.width=12, fig.height=6, include=FALSE}

#xxAll$genePerCount <- xxAll[[nFeatureCol]] / xxAll[[nCountCol]]

# plot13 <- plotColData(
#   xxAll,
#   x = "Sample",
#   y = "genePerCount",
#   colour_by = "discard"
# ) +
#   labs(
#     title = "Genes per UMI",
#     y = "Gene/UMI ratio"
#   ) +
#   theme(
#     legend.position = "none", 
#     axis.title.x = element_blank(),
#     axis.ticks.y = element_blank(),
#     axis.ticks.x = element_blank()
#   )
# 
# plot14 <- plotColData(
#   xxAll,
#   x = nCountCol,
#   y = "genePerCount",
#   colour_by = "discard"
# ) +
#   scale_x_log10() +
#   xlim(1, 10000) +
#   ylim(0.2, 0.8) +
#   labs(
#     title = "Gene/UMI ratio vs UMIs",
#     x = "UMI counts",
#     y = "Gene/UMI ratio"
#   ) +
#   theme(
#     legend.position = "none", 
#     axis.ticks.y = element_blank(),
#     axis.ticks.x = element_blank()
#   )
# 
# 
# plot13 + plot14

```


### Bins filtering

<details>
  <summary>Filtering rules</summary>

```{r cell filter, echo=F, message=F, warning=F}

cellFilter <- tibble(
  criterion = character(),
  rule = character()
) |>
  add_row(
    criterion = "Assumption — majority of cells are high-quality",
    rule = "Enables data-driven thresholds using QC metrics without detailed protocol knowledge."
  ) |>
  add_row(
    criterion = "Fixed thresholds (if provided)",
    rule = "If `nreads`, `ngenes`, or `perc_mito` are supplied, use those fixed cutoffs for filtering."
  ) |>
  add_row(
    criterion = "Adaptive: library size (nreads)",
    rule = "Exclude cells with library size < median − 3 × MAD (Median Absolute Deviation)"
  ) |>
  add_row(
    criterion = "Adaptive: detected genes (ngenes)",
    rule = "Exclude cells with detected genes < median − 3 × MAD."
  ) |>
  add_row(
    criterion = "Adaptive: mitochondrial proportion (perc_mito)",
    rule = "Exclude cells with mito % > median + 3 × MAD."
  ) |>
  add_row(
    criterion = "Gene-level prevalence filter",
    rule = "Keep genes present in ≥ N cells (or ≥ p% of cells); drop low-prevalence genes."
  )

datatable(
  cellFilter,
  class = 'cell-border stripe',
  # caption = htmltools::tags$caption(
  #   #style = 'caption-side: top; text-align: left; font-weight: bold; font-size: 16px;',
  #   "MAD = median absolute deviation"
  # ),
  escape = FALSE,
  rownames = FALSE,
  #colnames = rep("", ncol(cellFilter)),  # hide headers
  options = list(
    autoWidth = TRUE,
    dom = 't'
  )
) |>
  formatStyle(
    columns = names(cellFilter),
  )
```
</details>


```{r}

SpatialPlot(scData.unfiltered_spatial, group.by = "discard") + labs(title="Filtered Bins")

```


::: {.row}
::: {.col-md-6}

Number of bins filtered by the individual quality criteria.
```{r low quality Bins, fig.align='center'}

qcList <- lapply(allCellsMeta[ ,grep("^qc", colnames(allCellsMeta))], function(x){rownames(allCellsMeta)[x]})
qcList <- qcList[sapply(qcList, length) > 0]
if (length(qcList) > 1){
  UpSetR::upset(fromList(qcList), nsets = 5, mainbar.y.label="#bins")
}
```
:::

::: {.col-md-6}
```{r echo=FALSE, fig.align='center'}
qcStats <- ezFrame("Number of Bins"=integer(0), 
                   "Min Pass Value"=integer(0), 
                   "Max Pass Value"=integer(0), 
                   Fraction = integer(0))

qcStats[ "Library Size", ] <- c(
  c(sum(allCellsMeta$qc.lib), range(allCellsMeta[[nCountCol]][allCellsMeta$useCell])) %>% as.integer(),
  round(sum(allCellsMeta$qc.lib)/nrow(allCellsMeta), 2)
)

qcStats[ "Expressed genes", ] <- c(
  c(sum(allCellsMeta$qc.nexprs), range(allCellsMeta[[nFeatureCol]][allCellsMeta$useCell])) %>% as.integer(),
  round(sum(allCellsMeta$qc.nexprs)/nrow(allCellsMeta), 2)
)

qcStats[ "Mitochondrial Percent", ] <- c(
  c(sum(allCellsMeta$qc.mito), range(allCellsMeta$percent_mito[allCellsMeta$useCell])) %>% as.integer(),
  round(sum(allCellsMeta$qc.mito)/nrow(allCellsMeta), 2)
)

qcStats[ "Ribosomal protein Percent", ] <- c(
  c(sum(allCellsMeta$qc.ribo), range(allCellsMeta$percent_riboprot[allCellsMeta$useCell])) %>% as.integer(),
  round(sum(allCellsMeta$qc.ribo)/nrow(allCellsMeta), 2)
)

qcStats[ "Total removed (thresholding)", ] <- c(
  sum(!allCellsMeta$useCell), 
  NA, 
  NA, 
  round(sum(!allCellsMeta$useCell)/nrow(allCellsMeta), 2)
)

qcStats[ "Total removed (manual)", ] <- c(
  sum(allCellsMeta$useCell) - ncol(scData), 
  NA, 
  NA, 
  round((sum(allCellsMeta$useCell) - ncol(scData))/nrow(allCellsMeta), 2)
)

qcStats[ "Bins remaining", ] <- c(
  sum(ncol(scData)), 
  NA, 
  NA, 
  round(sum(ncol(scData))/nrow(allCellsMeta), 2)
)

qc_tbl <- cbind(Metric = rownames(qcStats), as.data.frame(qcStats), row.names = NULL)

dt <- datatable(
  qc_tbl,
  caption = htmltools::tags$caption(style = "caption-side: top; text-align: left;",
  htmltools::HTML(sprintf(
   "<span style='font-weight: normal; font-size: 14px;'>Bin size: %s</span>",
   param$binSize
))

  ),
  escape   = FALSE,
  rownames = FALSE,
  options  = list(
    autoWidth = TRUE,
    dom = "t"
  )
) |>
  formatRound(
    columns = which(map_lgl(qc_tbl, is.numeric)),
    digits = 0
  )

htmlwidgets::prependContent(
  dt,
  tags$style(HTML("table.dataTable tbody td:empty::before{content:'-'; color:#6c757d;}"))
)
```
:::
:::



### Dimensionality reduction


<details>
  <summary>Background information</summary>

```{r dim_ tbl, echo=F, message=F, warning=F}
dimred_tbl <- tibble(
  topic = character(),
  summary = character()
) |>
  add_row(
    topic   = "Goal",
    summary = "Reduce the number of dimensions by compressing information from many genes into fewer components."
  ) |>
  add_row(
    topic   = "Why it works",
    summary = "Genes affected by the same biological process are correlated, so separate storage per gene is redundant."
  ) |>
  add_row(
    topic   = "Benefits",
    summary = paste(
    "Computational efficiency — fewer dimensions to process.",
    "Noise reduction — averaging across genes sharpens true patterns.",
    "Visualization — enables clear 2D/3D plotting.",
    sep = "<br>"
  )
  ) |>
  add_row(
    topic   = "Method (example)",
    summary = "Principal Component Analysis (PCA) on normalized/centered data to obtain ranked components."
  ) |>
  add_row(
    topic   = "How many PCs?",
    summary = "Typically retain ~10–50 PCs for downstream analyses (dataset-dependent)."
  ) |>
  add_row(
    topic   = "How to choose PCs",
    summary = paste0(
      "Use a scree/variance-explained plot (a.k.a. Elbow plot). ",
      "Rank PCs by % variance explained; select PCs up to the elbow."
    )
  ) |>
  add_row(
    topic   = "Elbow plot logic",
    summary = paste0(
      "Assumption: PCs carrying biological signal explain markedly more variance than the rest. ",
      "Past the last “biological” PC, the variance drops sharply → the elbow indicates a natural cutoff."
    )
  )

datatable(
  dimred_tbl,
  class = "cell-border stripe",
  # caption = tags$caption(
  #   style = "caption-side: top; text-align: left; font-weight: bold; font-size: 16px;",
  #   "Overview and PC selection"
  # ),
  escape = FALSE,
  rownames = FALSE,
  options = list(
    autoWidth = TRUE,
    dom = "t"
  )
) |>
  formatStyle(
    columns = names(dimred_tbl),
    `white-space` = "pre-wrap",
    `vertical-align` = "top"
  )

```
</details>



```{r, fig.width=10}

pca_name <- if ("pca.sketch" %in% names(scData@reductions)) "pca.sketch" else "pca"

k <- param$npcs 

top_n <- max(80,k)

stdev <- scData[[pca_name]]@stdev %>% head(top_n)


pct  <- ((stdev^2) / sum(stdev^2)) * 100        
# mode <- sprintf("Variance-normalized%s", 
#                        paste0(", top ", length(stdev), " PCs"))


cumu    <- cumsum(pct)
plot_df <- data.frame(pct = pct, cumu = cumu, rank = seq_along(pct))
plot_df$used <- factor(plot_df$rank <= k, levels=c(TRUE, FALSE))

ggplot(plot_df, aes(x = cumu, 
                    y = pct, 
                    label = rank, 
                    color = used)) +
  geom_point(size = 1.6) + 
  geom_text(vjust = -0.8, size = 2) +
  geom_vline(xintercept = cumu[k], color = "grey50", linetype = "dashed") +
  
  # 
  # scale_color_manual(
  #   values = c("FALSE" = "#2B7A78", "TRUE" = "#1E88E5"),
  #   breaks = c(FALSE, TRUE),
  #   labels = c(paste0("PC % ", k), paste0("PC > ", k)),
  #   name   = NULL
  # ) +
  
  labs(
    title    = "Percent variance explained by the principal components",
    subtitle = paste0("number of PCs used: ", k),
    x = "Cumulative percent variance explained ",
    y = "Per PC variance explained"
  ) +
  
  annotate(
    "text",
    x = cumu[k], y = max(plot_df$pct),
    label = paste0("Variance used: ", sprintf("%.2f", cumu[k]), "%"),
    vjust = -0.4, size = 3, color = gg_color_hue(2)[1]
  ) + theme(legend.position = "none") +
  theme_bw() +theme(legend.position = "none")

```





## Clustering

<details>
  <summary>KNN → communities → clusters</summary>

```{r, echo=F}
npcs_txt <- sprintf("%s PCs", param$npcs)

cluster_tbl <- tibble(
  Step = character(),
  Details = character()
) |>
  add_row(
    Step = "Build KNN graph",
    Details = paste(
      "Each node = bin (cell).",
      sprintf("Connect each bin to its k nearest neighbors in %s space.", npcs_txt),
      "Distance usually Euclidean (on PCs) or cosine.",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Edge weighting",
    Details = paste(
      "Edges weighted by similarity (e.g., shared nearest neighbors/Jaccard).",
      "Higher weight = more similar bins.",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Community detection",
    Details = paste(
      "Apply a community detection algorithm (e.g., Leiden/Louvain) on the KNN graph.",
      "Find groups more connected internally than externally.",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Cluster labels",
    Details = paste(
      "Each community becomes a cluster ID per bin.",
      "Used for downstream interpretation (markers, enrichment, etc.).",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Visualization",
    Details = paste(
      "Plot clusters on UMAP and in image space to assess structure.",
      "Do not run statistical analyses directly on UMAP coordinates;",
      "use them for QC/visual inspection (e.g., neighboring subclusters, potential splits).",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Best practices & caveats",
    Details = paste(
      sprintf("Tune parameters: k (neighbors), resolution (Leiden/Louvain), and %s.", npcs_txt),
      "Check stability (seeds/subsampling) and biological plausibility.",
      "Beware tiny clusters (may be noise) and batch/spatial artifacts.",
      sep = "\n"
    )
  )


datatable(
  cluster_tbl,
  class   = "cell-border stripe",
  caption = tags$caption(
    style = "caption-side: top; text-align: left; font-weight: bold; font-size: 16px;",
    "Graph-based clustering overview (KNN → communities → clusters)"
  ),
  rownames = FALSE,
  options  = list(
    autoWidth = TRUE,
    dom = "t"
  )
) |>
  formatStyle(
    columns = names(cluster_tbl),
    `white-space`   = "pre-wrap",
    `vertical-align`= "top"
  )
```
</details>

<br>

`r paste("Resolution:", param$resolution)`

```{r, fig.height=8, fig.width=16}

n_clusters <- nlevels(Idents(scData))
show_leg   <- n_clusters <= 20


p1 <- DimPlot(scData,
              label = FALSE,
              pt.size = 1.5) +
  labs(color = "Clusters") +
  theme_void() +
  guides(color = if (show_leg) guide_legend(title = "Clusters") else "none") +
  ggtitle("UMAP") +
  theme(legend.position = "none")

p1 <- Seurat::LabelClusters(
  plot     = p1,
  id       = "ident",
  fontface = "bold",
  color    = "#383838",
  size     = 4
)

p2 <- SpatialDimPlot(scData,
                     label = TRUE,
                     label.size = 4,
                     pt.size.factor = 2) +
  labs(fill = "Clusters") +
  guides(fill = if (show_leg) guide_legend(title = "Clusters") else "none")


(p1 + p2) +
  plot_layout(nrow = 1, guides = if (show_leg) "collect" else "keep") 
 

```

<br>

::: {.row}
::: {.col-md-9}
```{r number of cells in each cluster, fig.width=12, fig.height=6}
if(!('Batch' %in% colnames(scData@meta.data))){
    scData@meta.data$Batch <- scData@meta.data$Sample
}

cellIdents_perSample <- scData@meta.data[,c('seurat_clusters', 'Batch')]
cellIdents_perSample$Batch <- factor(cellIdents_perSample$Batch)


# if (!exists("pal")) pal <- scales::hue_pal()(nlevels(plot_df$Batch))
# if (is.null(names(pal)) || !all(levels(plot_df$Batch) %in% names(pal))) {
#   pal <- setNames(pal, levels(plot_df$Batch))
# }
# 
# 
# lvls <- levels(factor(plot_df$Batch))  # or cellIdents_perSample$Batch
# pal  <- setNames(viridisLite::viridis(length(lvls), option = "D"), lvls)
# # pals::glasbey, pals::alphabet, RColorBrewer::brewer.pal

ggplot(cellIdents_perSample, aes(x = seurat_clusters, 
                    fill = Batch)) +
  geom_bar() +
#  scale_fill_manual(values = pal) +
  labs(title = "Bins per cluster and sample (counts)",
       x = NULL, 
       y = "# bins"
  ) + 
  theme_minimal()+
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) + ## make sure the y axis is not expanded at the bottom
  theme(#legend.position="none", 
        panel.grid.minor=element_blank(),
        panel.grid.major=element_blank(),
        scale_y_continuous(expand = expansion(mult = c(0.02, 0.15))),
        axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)
  )

```
:::

::: {.col-md-3}
```{r, echo=FALSE}

df <- cellsProportion(scData, groupVar1 = "seurat_clusters", groupVar2 = "Batch") 
df <- df |> as.data.frame(check.names = FALSE, stringsAsFactors = FALSE) |>
  dplyr::rename("Cluster"="seurat_clusters")



is_pct_col <- grepl("_fraction$", colnames(df))
colnames(df) <- colnames(df) |> str_replace_all("_fraction$", " (%)")
is_count_col <- !is_pct_col & colnames(df) != "Cluster"
colnames(df)[is_count_col] <- colnames(df)[is_count_col] |> paste("(n)")



DT::datatable(
  df,
  class   = "cell-border stripe compact",
  caption = htmltools::tags$caption(
#    style = "caption-side: top; text-align: left; font-weight: bold; font-size: 16px;",
    "Bins per cluster and sample"
  ),
  extensions = "Buttons",
  rownames   = FALSE,
  escape     = FALSE,
  filter     = "none",
  options    = list(
    paging       = TRUE,
    pageLength   = 12,
    dom          = "Bfrtip",  
    autoWidth    = TRUE,
    buttons      = list(
      list(extend = "excel", text = "Excel", filename = "markers")
    ),
    fixedColumns = list(leftColumns = 1),
    columnDefs   = list(list(className = "dt-left", targets = 0))
  )
) |>
  DT::formatPercentage(columns = is_pct_col, digits = 1) |>
  DT::formatStyle(columns = names(df), `white-space` = "pre-wrap")

```
:::
:::

<br/>


## Cluster assessment

<details>
  <summary>Technical vs. biological clustering driver</summary>

```{r, echo=FALSE}

driver_qc_tbl <- tibble(
  Item    = character(),
  Details = character()
) |>
  add_row(
    Item    = "Purpose",
    Details = "Check whether clusters are driven by technical artifacts or uninteresting biology (cell cycle, mitochondrial/ribosomal content, library size)."
  ) |>
  add_row(
    Item    = "Potential confounders",
    Details = paste(
      "Cell cycle phase composition (G1/S/G2M).",
      "Mitochondrial % and ribosomal %.",
      "Library size (UMIs) and genes detected.",
      sep = "\n"
    )
  ) |>
  add_row(
    Item    = "Diagnostics",
    Details = paste(
      "Per-cluster phase distribution (bar charts) — look for clusters dominated by a single phase.",
      "Box/violin plots per cluster for UMIs, genes, mito%, ribo%.",
      "Statistical checks (e.g., Kruskal-Wallis/ANOVA across clusters).",
      sep = "\n"
    )
  ) |>
  add_row(
    Item    = "Mitigations",
    Details = paste(
      "Regress out cell cycle / mito% / ribo% in scaling/normalization (e.g., Seurat ScaleData/SCTransform vars.to.regress).",
      "Adjust clustering parameters (PCs, k, resolution) after normalization.",
      sep = "\n"
    )
  ) |>
  add_row(
    Item    = "Decision rule",
    Details = paste(
      "If a cluster is mainly explained by confounders, flag it and re-evaluate after regression/normalization.",
      "If differences are modest and later cell-type labels explain them, proceed with interpretation.",
      sep = "\n"
    )
  )

DT::datatable(
  driver_qc_tbl,
  class   = "cell-border stripe",
  # caption = tags$caption(
  #   style = "caption-side: top; text-align: left; font-weight: bold; font-size: 16px;",
  #   "Are clusters driven by technical artifacts or uninteresting variability?"
  # ),
  rownames = FALSE,
  options  = list(autoWidth = TRUE, dom = "t")
) |>
  DT::formatStyle(
    columns = names(driver_qc_tbl),
    `white-space`    = "pre-wrap",
    `vertical-align` = "top"
  )
```

</details> 



```{r uninteresting variation, fig.height=16, fig.width=12}
boxplot_data_nCount <- FetchData(scData, vars = c(nCountCol, "seurat_clusters"))
#boxplot_data_nCount$seurat_clusters <- factor(boxplot_data_nCount$seurat_clusters, levels = sort(as.numeric(levels(boxplot_data_nCount$seurat_clusters))))
plot1 <- ggplot(boxplot_data_nCount, aes(x = seurat_clusters, y = .data[[nCountCol]], fill = seurat_clusters))
plot1 <- plot1 + geom_boxplot(outlier.size = 0.5, alpha = 0.9)
plot1 <- plot1 + scale_fill_viridis_d(option = "turbo")  
plot1 <- plot1 + ggtitle("Number of UMIs vs cluster") + xlab("Cluster") + ylab(nCountCol) + theme_minimal(base_size = 14) + theme(legend.position = "none")

boxplot_data_nFeature <- FetchData(scData, vars = c(nFeatureCol, "seurat_clusters"))
#boxplot_data_nFeature$seurat_clusters <- factor(boxplot_data_nFeature$seurat_clusters, levels = sort(as.numeric(levels(boxplot_data_nFeature$seurat_clusters))))
plot2 <- ggplot(boxplot_data_nFeature, aes(x = seurat_clusters, y = .data[[nFeatureCol]], fill = seurat_clusters))
plot2 <- plot2 + geom_boxplot(outlier.size = 0.5, alpha = 0.9)
plot2 <- plot2 + scale_fill_viridis_d(option = "turbo")  
plot2 <- plot2 + ggtitle("Number of genes vs cluster") + xlab("Cluster") + ylab(nFeatureCol) + theme_minimal(base_size = 14) + theme(legend.position = "none")

boxplot_data_mito <- FetchData(scData, vars = c("percent_mito", "seurat_clusters"))
#boxplot_data_mito$seurat_clusters <- factor(boxplot_data_mito$seurat_clusters, levels = sort(as.numeric(levels(boxplot_data_mito$seurat_clusters))))
plot3 <- ggplot(boxplot_data_mito, aes(x = seurat_clusters, y = percent_mito, fill = seurat_clusters))
plot3 <- plot3 + geom_boxplot(outlier.size = 0.5, alpha = 0.9)
plot3 <- plot3 + scale_fill_viridis_d(option = "turbo")  
plot3 <- plot3 + ggtitle("Mitochondrial percentage vs cluster") + xlab("Cluster") + ylab("percent_mito") + theme_minimal(base_size = 14) + theme(legend.position = "none")
plot1 + plot2 + plot3 + plot_layout(nrow = 3, ncol = 1)

```


```{r uninteresting variation old, fig.height=16, fig.width=18, include=FALSE}

# UMIs
boxplot_data_nCount <- FetchData(scData, vars = c(nCountCol, 
                                                  "seurat_clusters"))

boxplot_data_nCount$seurat_clusters <- factor(boxplot_data_nCount$seurat_clusters, 
                                              levels = sort(as.numeric(levels(boxplot_data_nCount$seurat_clusters))))

plot1 <- ggplot(boxplot_data_nCount,
                aes(x = seurat_clusters,
                    y = .data[[nCountCol]],
                    fill = seurat_clusters)) +

  geom_boxplot(outlier.size = 0.5,
               alpha = 0.9) +
    
  scale_fill_viridis_d(option = "turbo") +
    
  scale_y_continuous(labels = label_comma()) +     
    
  labs(
    title = "Number of UMIs vs cluster",
    #x = "Cluster",
    y = "UMIs per cell"
  ) +
    
  theme_minimal(base_size = 14) +
    
  theme(legend.position = "none",
        axis.title.x = element_blank(),
        plot.margin = margin(b = 20)
        )

# Features
boxplot_data_nFeature <- FetchData(scData, 
                                   vars = c(nFeatureCol, 
                                            "seurat_clusters")) 

boxplot_data_nFeature$seurat_clusters <- factor(boxplot_data_nFeature$seurat_clusters, 
                                                levels = sort(as.numeric(levels(boxplot_data_nFeature$seurat_clusters))))

plot2 <- ggplot(boxplot_data_nFeature,
                aes(x = seurat_clusters,
                    y = .data[[nFeatureCol]],
                    fill = seurat_clusters)) +
  geom_boxplot(outlier.size = 0.5, alpha = 0.9) +
  scale_fill_viridis_d(option = "turbo") +
  scale_y_continuous(labels = label_comma()) +
  labs(
    title = "Number of genes vs cluster",
    #x = "Cluster",
    y = "Genes detected per cell"
  ) +
  theme_minimal(base_size = 14) +
  theme(legend.position = "none",
        axis.title.x = element_blank(),
        plot.margin = margin(t = 20, b = 20)
        )

# Mito %

boxplot_data_mito <- FetchData(scData, vars = c("percent_mito", 
                                                "seurat_clusters")) 
boxplot_data_mito$seurat_clusters <- factor(boxplot_data_mito$seurat_clusters, 
                                            levels = sort(as.numeric(levels(boxplot_data_mito$seurat_clusters))))

plot3 <- ggplot(boxplot_data_mito,
                aes(x = seurat_clusters,
                    y = percent_mito,
                    fill = seurat_clusters)) +
  geom_boxplot(outlier.size = 0.5, alpha = 0.9) +
  scale_fill_viridis_d(option = "turbo") +
  scale_y_continuous(labels = label_number(accuracy = 0.1)) +
  labs(
    title = "Mito percentage vs cluster",
    x = "Cluster",
    y = "Mito %"
  ) +
  theme_minimal(base_size = 14) +
  theme(legend.position = "none",
        plot.margin = margin(t = 20)
        )

plot1 + plot2 + plot3 + plot_layout(nrow = 3, ncol = 1)

```


## Cluster markers

<details>
  <summary>Positive marker detection</summary>

```{r wilcoxon test, eval=(param$DE.method=="wilcox"), results='asis'}
marker_tbl <- tibble(
  Step = character(),
  Details = character()
) |>
  add_row(
    Step = "Goal",
    Details = paste(
      "Identify genes that are significantly higher in a given cluster compared to all other bins (\"positive markers\").",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Test",
    Details = paste(
      "Wilcoxon Rank Sum test (cluster vs. all other bins).",
      "Non-parametric; robust to non-normal distributions.",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Effect size filter",
    Details = paste(
      "Average log-fold change ≥ 0.25 (log-scale).",
      "Ensures selected markers have a meaningful up-regulation.",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Significance threshold",
    Details = paste(
      "Adjusted p-value < 0.05.",
      "Controls for multiple testing across genes.",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Direction",
    Details = paste(
      "Keep only **up-regulated** genes in the target cluster (\"positive\" markers).",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Outputs",
    Details = paste(
      "For each cluster: gene list with log2FC, pct.1 (in-cluster detection), pct.2 (out-of-cluster), p_val_adj, etc.",
      "Significant markers satisfy both effect-size and adjusted p-value criteria.",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Notes",
    Details = paste(
      "Inspect pct.1 vs pct.2 to confirm specificity.",
      "Very small p-values should be displayed in scientific notation; export raw values to avoid rounding to 0 in Excel.",
      sep = "\n"
    )
  )

DT::datatable(
  marker_tbl,
  class   = "cell-border stripe",
  # caption = htmltools::tags$caption(
  #   style = "caption-side: top; text-align: left; font-weight: bold; font-size: 16px;",
  #   "Positive marker detection (Wilcoxon + effect size)"
  # ),
  rownames = FALSE,
  options  = list(
    autoWidth = TRUE,
    dom = "t"
  )
) |>
  DT::formatStyle(
    columns = names(marker_tbl),
    `white-space`    = "pre-wrap",
    `vertical-align` = "top"
  )
```
Marker detection summary

```{r LR test, eval=(param$DE.method=="LR"), results='asis'}

marker_desc <- tibble(
  Item    = c("Test", "Covariate", "Effect size", "Significance", "Definition"),
  Details = c(
    "Logistic regression (cluster vs all other bins).",
    "Cell cycle included as a batch effect in the model.",
    "Average log-fold change ≥ 0.25 (log scale).",
    "Adjusted p-value < 0.05.",
    "Genes meeting both thresholds are called significant positive markers."
  )
)

  datatable(
  marker_desc,
  class   = "cell-border stripe",
  # caption = htmltools::tags$caption(
  #   style = "caption-side: top; text-align: left; font-weight: bold; font-size: 16px;",
  #   "Marker detection summary"
  # ),
  rownames = FALSE,
  options  = list(autoWidth = TRUE, dom = "t")
) |>
  formatStyle(names(marker_desc), `white-space` = "pre-wrap", 
              `vertical-align` = "top")
```
  
 </details>



```{r pos markers}


ezInteractiveTableRmd(posMarkers, digits=3, rowNames=FALSE)

# ezInteractiveTableRmd_elena <- function(values, digits=NULL, 
#                                  colNames=colnames(values), 
#                                  rowNames=rownames(values),
#                                  title="", 
#                                  format=NULL, 
#                                  envir=parent.frame()){
#   
#   suppressMessages(require(DT, quietly=TRUE))
#   suppressMessages(require(htmltools, quietly=TRUE))
#   
#   if (!is.null(digits)){
#     for (i in 1:ncol(values)) {
#       if(typeof(values[ ,i]) == "double"){
#         values[ ,i] = signif(values[ ,i], digits=digits)
#       }
#     }
#     captionText = paste("Numeric values are rounded to", 
#                         digits, 
#                         "digits.")
#     
#     caption = htmltools::tags$caption(htmltools::h1(title), 
#                                       htmltools::p(captionText))
#   } else {
#     caption = htmltools::tags$caption(htmltools::h1(title))
#   }
#   interactiveTable <- datatable(values, 
#                                 class    = "cell-border stripe compact",
#                                 extensions=c("Buttons"),
#                                 filter="bottom", 
#                                 #filter="top", 
#                                 caption=caption,
#                                 colnames=colNames,
#                                 rownames=rowNames,
#                                 options    = list(dom = "Bfrtip",
#                                                   buttons = list(list(extend = "excel", 
#                                                                        text = "Excel",
#                                                                        filename = "markers") #deleted buttons
#                                                                  ),
#                                                   pageLength = 20,
#                                                  # pageLength = 25,
#                                                   autoWidth  = TRUE
#                                                   )
#                                 )
#   if (!is.null(format)){
#     currEnv = list2env(list(interactiveTable = interactiveTable, 
#                             values = values), 
#                        parent = envir)
#     interactiveTable = eval(format, envir=c(currEnv))
#     #currEnv = environment()
#     #interactiveTable = eval(format, envir=c(envir, currEnv)) #makes list, not env
#   }
#   return(interactiveTable)
# }
# 
# 
# display_cols <- c("pct.1",
#                      "pct.2",
#                      "avg_log2FC",
#                      "p_val_adj",
#                      "diff_pct")
# 
# 
# ezInteractiveTableRmd_elena(data.frame(posMarkers)) |>
#   DT::formatSignif(display_cols,
#                    digits = 3) |> 
#   formatStyle(display_cols, `white-space` = "pre-wrap")


```
 

## Marker plots

```{r marker plot setup}
top5 <- posMarkers %>% 
  group_by(cluster) %>%
  slice_max(n = 5, order_by = tibble(diff_pct, avg_log2FC))
genesToPlot <- c(gsub("_", "-", param$controlSeqs), unique(as.character(top5$gene)))
genesToPlot <- intersect(genesToPlot, rownames(scData))
```


### DotPlot

```{r dotplot, fig.width  = 15, fig.height = 30}

DotPlot(scData, features=genesToPlot) + coord_flip() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
```


```{r plot of user genes, fig.width=12, fig.height=shrinkToRange(length(param$controlSeqs)/5, c(6, 12)), eval=ezIsSpecified(param$controlSeqs)}
genesToPlot <- intersect(param$controlSeqs, rownames(scData))

if (length(genesToPlot) > 0){
  DoHeatmap(scData, features=unique(genesToPlot))
  DotPlot(scData, features=genesToPlot) + coord_flip() +
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
} else { 
  cat("controlseqs not found")
}
```

Here, we use a heatmap and a dotplot to visualize simultaneously the top 5 markers in each cluster. Be aware that some genes may be in the top markers for different clusters.


## EnrichR

<details>
  <summary>Cell type scoring (Enrichr)</summary>
  
```{r, echo=FALSE}

enrichr_tbl <- tibble(
  Item    = character(),
  Details = character()
) |>
  add_row(
    Item    = "Goal",
    Details = "Score clusters by cell-type/pathway activity via gene set enrichment of their positive markers."
  ) |>
  add_row(
    Item    = "Input",
    Details = "Per-cluster marker genes (upregulated vs. other clusters)."
  ) |>
  add_row(
    Item    = "Method",
    Details = paste(
      "Use Enrichr to perform over-representation analysis on each cluster’s marker list.",
      "Enriched terms reflect pathways/processes relatively active in that cluster.",
      sep = "\n"
    )
  ) |>
  add_row(
    Item    = "Databases",
    Details = "Choose relevant libraries (e.g., cell-type signatures, GO, KEGG, Reactome, custom sets)."
  ) |>
  add_row(
    Item    = "Outputs",
    Details = paste(
      "Per cluster: ranked terms with enrichment score, p-value, adjusted p-value.",
      "Top terms guide cell-type naming and pathway interpretation.",
      sep = "\n"
    )
  ) |>
  add_row(
    Item    = "Notes",
    Details = paste(
      "Use adjusted p-values; prefer specific cell-type libraries for labeling.",
      "Cross-check terms with marker expression and spatial context.",
      sep = "\n"
    )
  )

datatable(
  enrichr_tbl,
  class   = "cell-border stripe",
  # caption = tags$caption(
  #   style = "caption-side: top; text-align: left; font-weight: bold; font-size: 16px;",
  #   "Cell type scoring using Enrichr"
  # ),
  rownames = FALSE,
  options  = list(
    autoWidth = TRUE,
    dom = "t"
  )
) |>
  formatStyle(
    columns = names(enrichr_tbl),
    `white-space`    = "pre-wrap",
    `vertical-align` = "top"
  )
```
  
</details> 
<br>

```{r query online enrichR version, echo=FALSE, results='asis'}
markersPerClusterTable <- c()

eachCluster <- 0

for (eachCluster in levels(posMarkers$cluster)) {
  markersPerCluster <- dplyr::filter(posMarkers,
                                     cluster == eachCluster) |>
    dplyr::arrange(desc(avg_log2FC))

  markersPerCluster <- head(markersPerCluster,
                            min(nrow(markersPerCluster), 500)
                            )

  markersPerClusterTable <- rbind(markersPerClusterTable,
                                  markersPerCluster)
}

genesPerCluster <- split(markersPerClusterTable$gene,
                         markersPerClusterTable$cluster)

jsCall = paste0('enrich({list: "',
                sapply(genesPerCluster,
                       paste,
                       collapse="\\n"),
                '", popup: true});')

enrichrCalls <- paste0("<a href='javascript:void(0)' onClick='",
                       jsCall,
                       # "'>Analyse at Enrichr website</a>"
                       "'>Open</a>")



```

::: {.row}
::: {.col-md-3}

```{r enrichr markers, echo=FALSE, results='asis'}
enrichrTable <- tibble(Cluster=names(genesPerCluster),
                         # "# of posMarkers"=lengths(genesPerCluster),
                         "N posMarkers"=lengths(genesPerCluster),
                         "Enrichr link"=enrichrCalls)

if (!is.null(enrichRout)){
  enrichRTerm <- as.data.frame(do.call(rbind,
                                       lapply(enrichRout, as.vector)))

  enrichRTerm <- map_df(enrichRTerm, 
                        ~ map_df(.x, 
                                 ~ replace(.x, is.null(.x), NA)), 
                        .id = "database")

  enrichRTerm <- enrichRTerm |>
    group_by(., Cluster, database) |>
    summarise(topTerms = paste(Term, collapse = "; ")) |>
    as.data.frame()

  enrichRTerm <- dcast(enrichRTerm, ... ~ database)

  enrichrTable <- merge(enrichrTable, enrichRTerm, by = "Cluster")
}

datatable(
  enrichrTable,
  rownames   = FALSE,
  escape     = FALSE,
  options    = list(
    paging       = TRUE,
    pageLength   = 15,      
    dom          = "tip",    
    autoWidth    = TRUE
  )
) 

# kable(enrichrTable, format="html", escape=FALSE,
#         caption=paste0("GeneSet enrichment")) %>%
# kable_styling("striped", full_width = F, position = "left")
```



## Data availability

##### Aggregated expression of every gene across the bins in each cluster

[geneExprPerCluster](bulkSignalPerCluster.tsv)

##### Aggregated expression of every gene across all the bins

[geneExprPerSample](bulkSignalPerSample.tsv)

##### Positive markers of each cluster

[posMarkers](cluster_markers.tsv)


##### The final Seurat Object is [here](scData.qs2)

## Session Info
```{r report parameters, echo=FALSE}
param[c("binSize",
        "npcs",
        "pcGenes",
        "resolution", 
        "DE.method", 
        # "cellsFraction", 
        "nUMIs", 
        "nmad")]
```


```{r, echo=FALSE}
format(Sys.time(), '%Y-%m-%d %H:%M:%S')
ezSessionInfo()
```
