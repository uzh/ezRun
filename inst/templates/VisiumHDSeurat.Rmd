---
title: "`r if (exists('reportTitle')) reportTitle else 'SUSHI Report'`"
output: 
  html_document:
    mathjax: https://fgcz-gstore.uzh.ch/reference/mathjax.js
    self_contained: true
    includes:
      in_header: !expr system.file("templates/fgcz_header.html", package="ezRun")
    css: !expr system.file("templates/fgcz.css", package="ezRun")
editor_options: 
  chunk_output_type: inline
---

# {.tabset}

Cell Filtering {.tabset}

```{r setup, include=FALSE}
library(Seurat)
library(ggplot2)
library(patchwork)
library(dplyr)
library(RColorBrewer)
library(kableExtra)
library(ezRun)
library(scater)
library(SingleCellExperiment)
library(enrichR)
library(SCpubr)
library(qs2)

library(DT)
library(ggtext)
library(grid) 
library(htmltools)
library(patchwork)
library(scales)
library(UpSetR)

library(SeuratWrappers)
library(Banksy)

library(sf)
library(Matrix)
library(SpotSweeper)
library(SpatialExperiment)

knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, knitr.table.format = "html")
```


```{r}
posMarkers <- readxl::read_xlsx("posMarkers.xlsx")
posMarkers$gene = as.factor(posMarkers$gene)
posMarkers$cluster <- makeGroupingVariableSortedFactor(posMarkers$cluster)
posMarkers$p_val_adj[posMarkers$p_val_adj==0] <- min(posMarkers$p_val_adj[posMarkers$p_val_adj>0])
if (file.exists("posMarkersBanksy.xlsx")) {
  posMarkersBanksy <- readxl::read_xlsx("posMarkersBanksy.xlsx")
  posMarkersBanksy$gene = as.factor(posMarkersBanksy$gene)
  posMarkersBanksy$cluster <- makeGroupingVariableSortedFactor(posMarkersBanksy$cluster)
  posMarkersBanksy$p_val_adj[posMarkersBanksy$p_val_adj==0] <-
    min(posMarkersBanksy$p_val_adj[posMarkersBanksy$p_val_adj>0])
} else {
  posMarkersBanksy <- data.frame()
}
param <- qs_read("param.qs2")
lambda <- param$lambda  # BANKSY spatial weighting parameter
input <- qs_read("input.qs2")
output <- qs_read("output.qs2")
scData <- qs_read("scData.qs2")
names(scData@images) <- make.names(names(scData@images))
if (scData@version < package_version("5.3.0")){
  scData <- SeuratObject::UpdateSeuratObject(scData)
}
scData_unfiltered <- qs_read("scData_unfiltered.qs2")
names(scData_unfiltered@images) <- make.names(names(scData_unfiltered@images))
if (scData_unfiltered@version < package_version("5.3.0")){
  scData_unfiltered <- SeuratObject::UpdateSeuratObject(scData_unfiltered)
}

nCountCol <- grep('^nCount_Spatial.*', 
                  colnames(scData@meta.data), 
                  value=TRUE) |> head(1)

nFeatureCol <- grep('^nFeature_Spatial.*', 
                    colnames(scData@meta.data), 
                    value=TRUE) |> head(1)

imageName <- names(scData@images)
stopifnot(length(imageName) == 1)
#allCellsMeta <- qs_read("allCellsMeta.qs2")
#sampleName <- input$getNames()

enrichRout <- NULL
aziResults <- NULL


scData   <- fix_microscopy_image(scData, 
                      imageName, 
                      eps = 0.02, 
                      margin = 0.01)


```

```{r seurat to spe}

scData_unfiltered$discard <- !scData_unfiltered$useCell
spe <- Seurat_to_SPE(scData_unfiltered, scData_unfiltered[[imageName]]@boundaries$centroids@coords)


```


`r paste("Output:", param$binSize)`


::: {.row}
::: {.col-md-6}

```{r, echo=F, message=F, warning=F}


qcFrame <- colData(spe) |> data.frame() |> select(starts_with("qc."))
qcFrame[is.na(qcFrame)] <- FALSE
## select only columns that have at least one flag
useColumn <- apply(qcFrame, 2, any)
qcFrame <- qcFrame[ , useColumn, drop=FALSE]

if (ncol(qcFrame) > 1) {
  UpSetR::upset(
    qcFrame + 0,## convert to from logical to integer
    nsets = min(5, ncol(qcFrame)),
    mainbar.y.label = "bins/cells"
  ) |> print()
  grid.text("bins/cells removed",x = 0.65, y=0.95, gp=gpar(fontsize=20))
  
}
  

```
:::

::: {.col-md-6}

```{r, echo=F, message=F, warning=F}


meta <- colData(spe)

qcStats <- ezFrame(
  "Number of bins/cells" = numeric(0), 
  "Min Pass Value"       = numeric(0), 
  "Max Pass Value"       = numeric(0), 
  "Fraction"             = numeric(0)
)

qcStats["Library Size", ] <- c(
  c(sum(meta$qc.lib),
    range(meta[[nCountCol]][meta$useCell])) %>% as.integer(),
  round(sum(meta$qc.lib) / nrow(meta), 2)
)

qcStats["Expressed genes", ] <- c(
  c(sum(meta$qc.nexprs),
    range(meta[[nFeatureCol]][meta$useCell])) %>% as.integer(),
  round(sum(meta$qc.nexprs) / nrow(meta), 2)
)

qcStats["Mitochondrial Percent", ] <- c(
  c(sum(meta$qc.mito, na.rm=TRUE),
    range(meta$percent_mito[meta$useCell])) %>% as.integer(),
  round(sum(meta$qc.mito, na.rm=TRUE) / nrow(meta), 2)
)

if (!is.null(meta$qc.riboprot) ){
  qcStats["Ribosomal protein Percent", ] <- c(
    c(sum(meta$qc.riboprot, na.rm=TRUE),
      range(meta$percent_riboprot[meta$useCell])) %>% as.integer(),
    round(sum(meta$qc.riboprot, na.rm=TRUE) / nrow(meta), 2)
  )
}

ezKable(qcStats)
  

```

:::

::: 




<details>
  <summary>Metrics to identify bins/cells of low quality</summary>
  
```{r QC metrics, echo=F, message=F, warning=F}

qcMetrics <- tibble(
  metric = character(),
  interpretation = character()
) |>
  add_row(
    metric = "Library size – total sum of counts across all relevant features for each bin/cell",
    interpretation = "Small library sizes indicate low quality (RNA may have been lost during library preparation)"
  ) |>
  add_row(
    metric = "Number of expressed genes with non-zero counts in each bin/cell",
    interpretation = "Very few expressed genes means poor capture of the transcript population"
  ) |>
  add_row(
    metric = "Mitochondrial proportion – percentage of reads mapping to mitochondrial genes in each bin/cell",
    interpretation = "High mitochondrial proportion indicate poor quality (loss of cytoplasmic RNA from perforated bins) (Islam et al. 2014; Ilicic et al. 2016)"
  )

ezKable(qcMetrics)


```

Evaluation


```{r diagnostics plots, echo=F, message=F, warning=F}

qcDiagnostics <- tibble(
  check = character(),
  interpretation = character()
) |>
  add_row(
    check = "Independence of QC metrics",
    interpretation = "QC metrics should reflect technical quality, not biological state (e.g., low library size or high mitochondrial proportion should not correspond to specific cell types)."
  ) |>
  add_row(
    check = "Distribution of values",
    interpretation = "Ideally, metrics follow a normal distribution, supporting threshold-based outlier detection."
  ) |>
  add_row(
    check = "Secondary modes",
    interpretation = "A large secondary peak (another mode) suggests correlation with biology, risking loss of distinct cell types."
  ) |>
  add_row(
    check = "Violin plots",
    interpretation = "Show bins/cells kept (`FALSE`) vs discarded (`TRUE`) after QC filtering, highlighting potential biases."
  ) |>
  add_row(
    check = "Spatial plots",
    interpretation = "Visualize QC metrics across the tissue to detect spatial patterns of low quality."
  )

ezKable(qcDiagnostics)

```
</details>





```{r nCount plots, fig.width=12, fig.height=4}

plot1 <- plotColData(
  spe, x = "Sample", 
  y = nCountCol, 
  colour_by = "discard"
) +  scale_y_log10() +
  labs(title = "UMI counts", y = "UMI counts per bin/cell") 


plot2 <- ezSpatialFeaturePlot(
  scData_unfiltered, nCountCol,
  title = "UMI per bin/cell",
  label = "UMI counts"
)

plot3 <- ezSpatialFeaturePlot(
  scData_unfiltered, nCountCol,
  title  = "Raw image",
  label  = NULL,
#  images = img_name,
  alpha  = c(0, 0)
) + guides(fill = "none")



plot1 + plot2 + plot3

```


```{r nGenes, fig.width=12, fig.height=4}

plot1 <- plotColData(
  spe, x = "Sample", 
  y = nFeatureCol, 
  colour_by = "discard"
) +  
  labs(title = "Genes", y = "#genes per bin/cell") 


plot2 <- ezSpatialFeaturePlot(
  scData_unfiltered, nFeatureCol,
  title = "Genes per bin/cell",
  label = "#genes"
)


plot3 <- plotColData(
  spe,
  x = nCountCol,
  y = nFeatureCol,
  colour_by = "discard"
) +
  scale_x_log10() +
  scale_y_log10() +
  labs(
    title = "",
    x = "UMI counts",
    y = "#genes"
  )

plot1 + plot2 + plot3


```


```{r percent mito, fig.width=12, fig.height=4}


plot1 <- plotColData(
  spe, x = "Sample", 
  y = "percent_mito", 
  colour_by = "discard"
) +  
  labs(title = "percent mito", y = "Percent mitochondrial UMIs") 

scData_unfiltered$percent_mito[is.nan(scData_unfiltered$percent_mito)] <- 0
plot2 <- ezSpatialFeaturePlot(
  scData_unfiltered, "percent_mito",
  title = "",
  label = "percent mito"
)


plot3 <- plotColData(
  spe,
  x = nCountCol,
  y = "percent_mito",
  colour_by = "discard"
) +
  scale_x_log10() +
  scale_y_log10() +
  labs(
    title = "",
    x = "UMI counts",
    y = "percent mito"
  )

plot1 + plot2 + plot3





```

```{r percent ribo, fig.width=12, fig.height=4}



if (!is.null(spe$percent_riboprot) && 
    any(spe$percent_riboprot > 0, na.rm=TRUE)) {
  
  plot1 <- plotColData(
    spe, x = "Sample", 
    y = "percent_riboprot", 
    colour_by = "discard"
  ) +  
    labs(title = "percent riboprot", y = "Percent ribosomal protein UMIs") 
  
  scData_unfiltered$percent_riboprot[is.nan(scData_unfiltered$percent_riboprot)] <- 0
  plot2 <- ezSpatialFeaturePlot(
    scData_unfiltered, "percent_riboprot",
    title = "",
    label = "percent riboprot"
  )
  
  plot3 <- plotColData(
    spe,
    x = nCountCol,
    y = "percent_riboprot",
    colour_by = "discard"
  ) +
    scale_x_log10() +
    scale_y_log10() +
    labs(
      title = "",
      x = "UMI counts",
      y = "percent riboprot"
    )
  
  plot1 + plot2 + plot3
  
  
}  


```


<details>
  <summary>Filtering rules</summary>

```{r cell filter, echo=F, message=F, warning=F}

cellFilter <- tibble(
  criterion = character(),
  rule = character()
) |>
  add_row(
    criterion = "Assumption — majority of cells are high-quality",
    rule = "Enables data-driven thresholds using QC metrics without detailed protocol knowledge."
  ) |>
  add_row(
    criterion = "Fixed thresholds (if provided)",
    rule = "If `nreads`, `ngenes`, or `perc_mito` are supplied, use those fixed cutoffs for filtering."
  ) |>
  add_row(
    criterion = "Adaptive: library size (nreads)",
    rule = "Exclude cells with library size < median − 3 × MAD (Median Absolute Deviation)"
  ) |>
  add_row(
    criterion = "Adaptive: detected genes (ngenes)",
    rule = "Exclude cells with detected genes < median − 3 × MAD."
  ) |>
  add_row(
    criterion = "Adaptive: mitochondrial proportion (perc_mito)",
    rule = "Exclude cells with mito % > median + 3 × MAD."
  ) |>
  add_row(
    criterion = "Gene-level prevalence filter",
    rule = "Keep genes present in ≥ N cells (or ≥ p% of cells); drop low-prevalence genes."
  )

ezKable(cellFilter)
```
</details>


## Dimensionality reduction


<details>
  <summary>Background information</summary>

```{r dim_ tbl, echo=F, message=F, warning=F}
dimred_tbl <- tibble(
  topic = character(),
  summary = character()
) |>
  add_row(
    topic   = "Goal",
    summary = "Reduce the number of dimensions by compressing information from many genes into fewer components."
  ) |>
  add_row(
    topic   = "Why it works",
    summary = "Genes affected by the same biological process are correlated, so separate storage per gene is redundant."
  ) |>
  add_row(
    topic   = "Benefits",
    summary = paste(
    "Computational efficiency — fewer dimensions to process.",
    "Noise reduction — averaging across genes sharpens true patterns.",
    "Visualization — enables clear 2D/3D plotting.",
    sep = "<br>"
  )
  ) |>
  add_row(
    topic   = "Method (example)",
    summary = "Principal Component Analysis (PCA) on normalized/centered data to obtain ranked components."
  ) |>
  add_row(
    topic   = "How many PCs?",
    summary = "Typically retain ~10–50 PCs for downstream analyses (dataset-dependent)."
  ) |>
  add_row(
    topic   = "How to choose PCs",
    summary = paste0(
      "Use a scree/variance-explained plot (a.k.a. Elbow plot). ",
      "Rank PCs by % variance explained; select PCs up to the elbow."
    )
  ) |>
  add_row(
    topic   = "Elbow plot logic",
    summary = paste0(
      "Assumption: PCs carrying biological signal explain markedly more variance than the rest. ",
      "Past the last “biological” PC, the variance drops sharply → the elbow indicates a natural cutoff."
    )
  )

ezKable(dimred_tbl)

```
</details>


```{r, fig.width=10, echo=F, message=F, warning=F}

pca_name <- intersect(c("pca.sketch", "pca"), names(scData@reductions)) |> head(1)

stdev <- scData[[pca_name]]@stdev

n_use <- min(param$npcs, length(stdev))
stopifnot(n_use >= 1, n_use <= length(stdev))

var_pct <- (stdev^2) / sum(stdev^2) * 100
cum_pct <- cumsum(var_pct)

df <- data.frame(
  PC   = seq_along(stdev),
  perc = var_pct,
  cum  = cum_pct,
  used = seq_along(stdev) <= n_use
)

ggplot(df, 
       aes(x = PC)) +
  
  geom_col(aes(y = perc, 
               fill = used), 
           width = 0.7, 
           show.legend = FALSE) +
  
  scale_fill_manual(values = c(`TRUE` = "grey20", 
                               `FALSE` = "grey75")) +
  
  geom_line(aes(y = cum / max(cum) * max(perc), 
                group = 1), 
            linewidth = 0.5, 
            color = "orange") +
  
  geom_point(aes(y = cum / max(cum) * max(perc)), 
             size = 1, color = "orange") +

  geom_vline(xintercept = n_use, 
             linetype = "dashed", 
             color = "grey40") +
 
  scale_y_continuous(
    name = "Variance explained (%)",
    sec.axis = sec_axis(~ . / max(df$perc) * 100, 
                        name = "Cumulative variance (%)")
  ) +
  
  labs(
    title    = "PCA variance explained",
    subtitle = paste0("PCs used: ", 
                      n_use, 
                      "   |   Cumulative: ", 
                      sprintf('%.2f%%', 
                              df$cum[n_use])),
    x = NULL) +
  theme(
    text               = element_text(face = "bold"),
    axis.title.y.left  = element_text(color = "grey20"),
    axis.title.y.right = element_text(color = "orange"),
    plot.title         = element_text(hjust = 0.5),
    panel.grid.minor   = element_blank()
  )

```



## Segmentation mask

`r {
  if (identical(param$binSize, "segmented_outputs")) {
    n <- nrow(scData@images[[imageName]]@boundaries$segmentation@sf.data)
    paste("N cells:", n)
  } else ""
}`

```{r, fig.height=16, fig.width=20}

ezSpatialFeaturePlot(
  scData_unfiltered,
  nCountCol,
  label = "UMI counts",
  stroke = 0.2,
  image.scale= "hires",
  crop=TRUE
)

```


### Zoom in mask


```{r, fig.width=25, fig.height=20}

## TODO: use vitessce viewer instead

coords <- GetTissueCoordinates(scData_unfiltered)
xRange <- coords$x |> range()
yRange <- coords$y |> range()
xCenter <- mean(xRange)
xDiff <- diff(xRange)
yCenter <- mean(yRange)
yDiff <- diff(yRange)

use <- coords$x > xCenter - xDiff /20 & coords$x < xCenter + xDiff /20 &
  coords$y > yCenter - yDiff /20 & coords$y < yCenter + yDiff /20

center <- coords[ round(nrow(coords)/2) , c("x", "y")]
xRange <- coords$x |> range() |> diff()
croppedRange <- xRange * 0.1


ezSpatialFeaturePlot(
  subset(scData_unfiltered, cells=which(use)),
  nCountCol,
  pt.size.factor = 5,
  label = "UMI counts",
  stroke = 0.2,
  crop = TRUE
)


```

### Cell size/density

<details>
  <summary>Segmentation QC</summary>
  
```{r}

if (identical(param$binSize, "segmented_outputs")) {

    qc_text_tbl <- tibble(
    topic = c(
      "Cell size distributions (per image)",
      "Image area covered by cells"
    ),
    summary = c(
      paste(
        "Compare the distributions of cell size across individual images.",
        "Differences can indicate segmentation bias (e.g., density-dependent over/under-segmentation)",
        "or genuine biology driven by cell-type composition",
        "(e.g., tumor cells often larger than immune cells).",
        sep = " "
      ),
      paste(
        "Coverage = total cell area ÷ image area (per ROI).",
        "Low coverage flags ROIs with few cells, possibly due to incorrect ROI selection",
        "or non-tissue/artifact regions; review recommended.",
        sep = " "
      )
    )
  )

  ezKable(qc_text_tbl, 
          caption = "QC notes for image-level metrics", 
          escape = FALSE)

}

```
  </details>
  
`r {
  if (identical(param$binSize, "segmented_outputs")) {
    d <- dim(scData@images[[imageName]]@image)
    paste("Image dimension:", paste(d, collapse = " × "))
  } else "This tab is only for *segmented outputs* and isn’t applicable to bin-based results"
}`




#### Cell size

::: {.row}
::: {.col-md-6}

```{r cell area plot}

if (identical(param$binSize, "segmented_outputs")) {

  #scData@images[[imageName]]@boundaries$segmentation@sf.data |>
  rings <- Seurat::GetTissueCoordinates(scData, which="segmentation", return.sf=TRUE) |>
    group_by(cell) %>%
    summarise(
      ring = list(list(
        cbind(x, y)#,
      )),
      .groups = "drop"
    )
  geom <- st_sfc(lapply(rings$ring, st_polygon))
  poly_sf <- st_sf(cell = rings$cell, geometry = geom)
  poly_sf$area <- as.numeric(st_area(poly_sf))
  scData <- AddMetaData(scData, 
                        metadata = setNames(poly_sf$area, poly_sf$cell),
                        col.name = "areaHires")
    

  VlnPlot(scData, 
          features = "areaHires", 
          pt.size = 0) +
    labs(y = "Area [um]") + NoLegend()

} 

```

<br>
<br>

```{r cell area stats}
if (identical(param$binSize, "segmented_outputs")) {
  qcArea <- summary(scData$areaHires) |>
    round() |> 
    as.list() |> 
    as.data.frame()
  rownames(qcArea) <- imageName

  ## pedestrian implementation of the above
  # vals <- summary(scSub$areaPX2hires)
  # qs  <- quantile(vals, 
  #                 probs = c(a=0, .25, .5, .75, 1), 
  #                 names = FALSE, 
  #                 na.rm = TRUE)
  # 
  # mn  <- mean(vals, na.rm = TRUE)
  # 
  # N   <- length(vals)
  # 
  # qcArea <- ezFrame(
  #   "N cells" = integer(0),
  #   "Min"     = numeric(0),
  #   "1st Qu." = numeric(0),
  #   "Median"  = numeric(0),
  #   "Mean"    = numeric(0),
  #   "3rd Qu." = numeric(0),
  #   "Max"     = numeric(0)
  # )
  # 
  # qcArea[ Images(scData), ] <- c(N, 
  #                          qs[1], 
  #                          qs[2], 
  #                          qs[3], 
  #                          mn, 
  #                          qs[4], 
  #                          qs[5]) |> round(0)

  ezKable(qcArea)
}
```
:::
::: {.col-md-6}



```{r, eval=FALSE}

# if (identical(param$binSize, "segmented_outputs")) {
#  
#   sfp <- scData@images[[imageName]]@boundaries$segmentation@sf.data
#   lo  <- scData@images[[imageName]]@scale.factors$lowres
# 
#   W <- ncol(scData@images[[imageName]]@image)/lo
#   H <- nrow(scData@images[[imageName]]@image)/lo
#   covered <- sum(st_area(sfp)) / (W * H)
# 
#   ggplot(data.frame(sample=imageName, 
#                     covered=covered),
#          aes(sample, 
#              covered)) +
#   
#     geom_point(size = 3) + 
#   
#     theme_minimal(base_size = 12) +
#   
#     ylim(0,1) +
#   
#     labs(y="% covered area", 
#          x = "")
#   
# } 

```
:::
:::


## Clusters  {.tabset}

### Clustering

<details>
  <summary>KNN → communities → clusters</summary>

```{r, echo=F}
npcs_txt <- sprintf("%s PCs", param$npcs)

cluster_tbl <- tibble(
  Step = character(),
  Details = character()
) |>
  add_row(
    Step = "Build KNN graph",
    Details = paste(
      "Each node = bin/cell.",
      sprintf("Connect each bin/cell to its k nearest neighbors in %s space.", npcs_txt),
      "Distance usually Euclidean (on PCs) or cosine.",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Edge weighting",
    Details = paste(
      "Edges weighted by similarity (e.g., shared nearest neighbors/Jaccard).",
      "Higher weight = more similar bins/cells.",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Community detection",
    Details = paste(
      "Apply a community detection algorithm (e.g., Leiden/Louvain) on the KNN graph.",
      "Find groups more connected internally than externally.",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Cluster labels",
    Details = paste(
      "Each community becomes a cluster ID per bin/cell.",
      "Used for downstream interpretation (markers, enrichment, etc.).",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Visualization",
    Details = paste(
      "Plot clusters on UMAP and in image space to assess structure.",
      "Do not run statistical analyses directly on UMAP coordinates;",
      "use them for QC/visual inspection (e.g., neighboring subclusters, potential splits).",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Best practices & caveats",
    Details = paste(
      sprintf("Tune parameters: k (neighbors), resolution (Leiden/Louvain), and %s.", npcs_txt),
      "Check stability (seeds/subsampling) and biological plausibility.",
      "Beware tiny clusters (may be noise) and batch/spatial artifacts.",
      sep = "\n"
    )
  )

ezKable(cluster_tbl)

```
</details>
`r paste("Resolution:", param$clusterResolution)`

<br>


```{r, fig.height=6, fig.width=12}

n_clusters <- nlevels(Idents(scData))
show_leg   <- n_clusters <= 20

namedPalette <- setNames(
  DiscretePalette(length(levels(Idents(scData))
                         ), 
                  palette = "polychrome"), 
  levels(Idents(scData))
)

p1 <- DimPlot(scData,
              label = FALSE,
              pt.size = 0.5) +
  labs(color = "Clusters") +
  theme_void() +
  guides(color = if (show_leg) guide_legend(title = "Clusters") else "none") +
  ggtitle("UMAP") +
  theme(legend.position = "none")

p1 <- Seurat::LabelClusters(
  plot     = p1, 
  repel = T,
  box = T,
  id       = "ident",
  fontface = "bold",
  color    = "white",
  size     = 4
)


p2 <- SpatialDimPlot(
  scData,
  images = Images(scData),
  label              = T,
  label.size         = 4,
  repel              = T,        
  plot_segmentations = T,
  pt.size.factor     = 2
) +
  labs(fill = "Clusters") +
  guides(fill = if (show_leg) guide_legend(title = "Clusters") else "none")


(p1 + p2) +
  plot_layout(nrow = 1,
              guides = if (show_leg) "collect" else "keep")



```

<br>

::: {.row}
::: {.col-md-9}
```{r number of cells in each cluster, fig.width=12, fig.height=6}

cellIdents_perSample <- scData@meta.data[,c('seurat_clusters', 'Sample')]

ggplot(cellIdents_perSample, aes(x = seurat_clusters, fill = Sample)) +
  geom_bar(fill = "#93AECA") +
  #  scale_fill_manual(values = pal) +
  labs(title = "Bins/cells per cluster and sample (counts)",
       x = NULL, 
       y = "bins/cells"
  ) + 
  theme_minimal()+
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) + ## make sure the y axis is not expanded at the bottom
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)
  )

```
:::

::: {.col-md-3}
```{r, echo=FALSE}

df <- cellsProportion(scData, groupVar1 = "seurat_clusters", groupVar2 = "Sample") 
df <- df |> as.data.frame(check.names = FALSE, stringsAsFactors = FALSE) |>
  dplyr::rename("Cluster"="seurat_clusters")



is_pct_col <- grepl("_fraction$", colnames(df))
colnames(df) <- colnames(df) |> str_replace_all("_fraction$", " (%)")
is_count_col <- !is_pct_col & colnames(df) != "Cluster"
colnames(df)[is_count_col] <- colnames(df)[is_count_col] |> paste("(n)")

ezInteractiveTableRmd(df, rowNames = FALSE, title="number of bins/cells", filter="none")|>
  DT::formatPercentage(columns = is_pct_col, digits = 2) 


```
:::
:::

<br/>


### Cluster assessment

<details>
  <summary>Technical vs. biological clustering driver</summary>

```{r, echo=FALSE}

driver_qc_tbl <- tibble(
  Item    = character(),
  Details = character()
) |>
  add_row(
    Item    = "Purpose",
    Details = "Check whether clusters are driven by technical artifacts or uninteresting biology (cell cycle, mitochondrial/ribosomal content, library size)."
  ) |>
  add_row(
    Item    = "Potential confounders",
    Details = paste(
      "Cell cycle phase composition (G1/S/G2M).",
      "Mitochondrial % and ribosomal %.",
      "Library size (UMIs) and genes detected.",
      sep = "\n"
    )
  ) |>
  add_row(
    Item    = "Diagnostics",
    Details = paste(
      "Per-cluster phase distribution (bar charts) — look for clusters dominated by a single phase.",
      "Box/violin plots per cluster for UMIs, genes, mito%, ribo%.",
      "Statistical checks (e.g., Kruskal-Wallis/ANOVA across clusters).",
      sep = "\n"
    )
  ) |>
  add_row(
    Item    = "Mitigations",
    Details = paste(
      "Regress out cell cycle / mito% / ribo% in scaling/normalization (e.g., Seurat ScaleData/SCTransform vars.to.regress).",
      "Adjust clustering parameters (PCs, k, resolution) after normalization.",
      sep = "\n"
    )
  ) |>
  add_row(
    Item    = "Decision rule",
    Details = paste(
      "If a cluster is mainly explained by confounders, flag it and re-evaluate after regression/normalization.",
      "If differences are modest and later cell-type labels explain them, proceed with interpretation.",
      sep = "\n"
    )
  )

ezKable(driver_qc_tbl)
```

</details> 



```{r uninteresting variation, fig.height=16, fig.width=12}

plot1 <- VlnPlot(scData,
                 nCountCol,
                 group.by = "seurat_clusters",
                 pt.size = 0,          
                 raster = T) +
  
  ggtitle("Number of UMIs vs cluster") +
  
  ylab(nCountCol) +
  
  theme_minimal(base_size = 12) +
  
  theme(legend.position = "none",
        axis.title.x = element_blank()) +
  
  scale_y_log10(
    breaks = log_breaks(base = 10),
    labels = label_number()
  )

plot2 <- VlnPlot(scData,
                 nFeatureCol,     
                 group.by = "seurat_clusters",
                 pt.size  = 0,
                 raster   = T) +
  
  ggtitle("Number of genes vs cluster") +
  
  ylab(nFeatureCol) +
  
  theme_minimal(base_size = 12) +
  
  theme(legend.position = "none",
        axis.title.x = element_blank()) +
  
  scale_y_log10(
    breaks = log_breaks(base = 10),
    labels = label_number()
  )


plot3 <- VlnPlot(scData,
                 "percent_mito",     
                 group.by = "seurat_clusters",
                 pt.size = 0,
                 raster = T) +
  ggtitle("Mitochondrial percentage vs cluster") +
  xlab("Cluster") +
  ylab("percent_mito") +
  theme_minimal(base_size = 12) +
  theme(legend.position = "none")

plot1 + plot2 + plot3 + plot_layout(nrow = 3, ncol = 1)

```


### Cluster markers

<details>
  <summary>Positive marker detection</summary>

```{r wilcoxon test, eval=(param$DE.method=="wilcox"), results='asis'}
marker_tbl <- tibble(
  Step = character(),
  Details = character()
) |>
  add_row(
    Step = "Goal",
    Details = paste(
      "Identify genes that are significantly higher in a given cluster compared to all other bins/cells (\"positive markers\").",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Test",
    Details = paste(
      "Wilcoxon Rank Sum test (cluster vs. all other bins/cells).",
      "Non-parametric; robust to non-normal distributions.",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Effect size filter",
    Details = paste(
      "Average log-fold change ≥ 0.25 (log-scale).",
      "Ensures selected markers have a meaningful up-regulation.",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Significance threshold",
    Details = paste(
      "Adjusted p-value < 0.05.",
      "Controls for multiple testing across genes.",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Direction",
    Details = paste(
      "Keep only **up-regulated** genes in the target cluster (\"positive\" markers).",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Outputs",
    Details = paste(
      "For each cluster: gene list with log2FC, pct.1 (in-cluster detection), pct.2 (out-of-cluster), p_val_adj, etc.",
      "Significant markers satisfy both effect-size and adjusted p-value criteria.",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Notes",
    Details = paste(
      "Inspect pct.1 vs pct.2 to confirm specificity.",
      "Very small p-values should be displayed in scientific notation; export raw values to avoid rounding to 0 in Excel.",
      sep = "\n"
    )
  )

ezKable(marker_tbl)
```

Marker detection summary

```{r LR test, eval=(param$DE.method=="LR"), results='asis'}

marker_desc <- tibble(
  Item    = c("Test", "Covariate", "Effect size", "Significance", "Definition"),
  Details = c(
    "Logistic regression (cluster vs all other bins/cells).",
    "Cell cycle included as a batch effect in the model.",
    "Average log-fold change ≥ 0.25 (log scale).",
    "Adjusted p-value < 0.05.",
    "Genes meeting both thresholds are called significant positive markers."
  )
)

ezKable(marker_desc)
```
  
 </details>



```{r pos markers}
ezInteractiveTableRmd(posMarkers, digits=3, rowNames=FALSE)
```
 

### Marker plots

```{r marker plot setup}
top5 <- posMarkers  |> 
  group_by(cluster) |> 
  slice_max(n = 5, order_by = tibble(diff_pct, avg_log2FC))

genesToPlot <- c(gsub("_", "-", param$controlSeqs), unique(as.character(top5$gene)))

genesToPlot <- intersect(genesToPlot, rownames(scData))
```


#### DotPlot

Visualization of the top 5 markers in each cluster. If a gene is a top marker for multiple clusters it is shown only once.


```{r dotplot, fig.width  = 15, fig.height = 30}

DotPlot(scData, features=rev(genesToPlot)) + 
  coord_flip() +
  scale_y_discrete(limits = as.character(sort(as.integer(levels(Idents(scData)))))
                   ) +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))

```


```{r plot of user genes, fig.width=12, fig.height=shrinkToRange(length(param$controlSeqs)/5, c(6, 12)), eval=ezIsSpecified(param$controlSeqs)}
genesToPlot <- intersect(param$controlSeqs, rownames(scData))

if (length(genesToPlot) > 0){
  DoHeatmap(scData, features=unique(genesToPlot))
  DotPlot(scData, features=genesToPlot) + coord_flip() +
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
} else { 
  cat("controlseqs not found")
}
```



### EnrichR

<details>
  <summary>Cell type scoring (Enrichr)</summary>
  
```{r, echo=FALSE}

enrichr_tbl <- tibble(
  Item    = character(),
  Details = character()
) |>
  add_row(
    Item    = "Goal",
    Details = "Score clusters by cell-type/pathway activity via gene set enrichment of their positive markers."
  ) |>
  add_row(
    Item    = "Input",
    Details = "Per-cluster marker genes (upregulated vs. other clusters)."
  ) |>
  add_row(
    Item    = "Method",
    Details = paste(
      "Use Enrichr to perform over-representation analysis on each cluster’s marker list.",
      "Enriched terms reflect pathways/processes relatively active in that cluster.",
      sep = "\n"
    )
  ) |>
  add_row(
    Item    = "Databases",
    Details = "Choose relevant libraries (e.g., cell-type signatures, GO, KEGG, Reactome, custom sets)."
  ) |>
  add_row(
    Item    = "Outputs",
    Details = paste(
      "Per cluster: ranked terms with enrichment score, p-value, adjusted p-value.",
      "Top terms guide cell-type naming and pathway interpretation.",
      sep = "\n"
    )
  ) |>
  add_row(
    Item    = "Notes",
    Details = paste(
      "Use adjusted p-values; prefer specific cell-type libraries for labeling.",
      "Cross-check terms with marker expression and spatial context.",
      sep = "\n"
    )
  )

ezKable(enrichr_tbl)
```
  
</details> 
<br>

```{r query online enrichR version, echo=FALSE, results='asis'}
markersPerClusterTable <- c()

eachCluster <- 0

for (eachCluster in levels(posMarkers$cluster)) {
  markersPerCluster <- dplyr::filter(posMarkers,
                                     cluster == eachCluster) |>
    dplyr::arrange(desc(avg_log2FC))

  markersPerCluster <- head(markersPerCluster,
                            min(nrow(markersPerCluster), 500)
                            )

  markersPerClusterTable <- rbind(markersPerClusterTable,
                                  markersPerCluster)
}

genesPerCluster <- split(markersPerClusterTable$gene,
                         markersPerClusterTable$cluster)

jsCall = paste0('enrich({list: "',
                sapply(genesPerCluster,
                       paste,
                       collapse="\\n"),
                '", popup: true});')

enrichrCalls <- paste0("<a href='javascript:void(0)' onClick='",
                       jsCall,
                       # "'>Analyse at Enrichr website</a>"
                       "'>Open</a>")



```


```{r enrichr markers, echo=FALSE, results='asis'}
enrichrTable <- tibble(Cluster=names(genesPerCluster),
                         # "# of posMarkers"=lengths(genesPerCluster),
                         "N posMarkers"=lengths(genesPerCluster),
                         "Enrichr link"=enrichrCalls)

if (!is.null(enrichRout)){
  enrichRTerm <- as.data.frame(do.call(rbind,
                                       lapply(enrichRout, as.vector)))

  enrichRTerm <- map_df(enrichRTerm, 
                        ~ map_df(.x, 
                                 ~ replace(.x, is.null(.x), NA)), 
                        .id = "database")

  enrichRTerm <- enrichRTerm |>
    group_by(., Cluster, database) |>
    summarise(topTerms = paste(Term, collapse = "; ")) |>
    as.data.frame()

  enrichRTerm <- dcast(enrichRTerm, ... ~ database)

  enrichrTable <- merge(enrichrTable, enrichRTerm, by = "Cluster")
}

## settings needed to make sure links remain links
ezKable(enrichrTable, escape=FALSE, format="html", format.args=list())

```



## Niches {.tabset}

```{r check_banksy}
has_banksy <- "banksy_cluster" %in% colnames(scData@meta.data)
has_niche_genes <- FALSE  # Will be updated in niche_dotplot_setup if there are genes
```


### Spatial clustering 

#### Communities of spatially adjacent bins/cells

<details>
  <summary>Niche defining</summary>

```{r}
banksy_niches <- tibble(
  Concept = character(),
  Definition = character(),
  `Key params` = character(),
  `Practical tip` = character()
) |>
  add_row(
    Concept = "Niche (BANKSY cluster)",
    Definition = "Community of spatially adjacent bins/cells with neighborhood-smoothed expression.",
    `Key params` = "k_geom, λ",
    `Practical tip` = "Represents a tissue microenvironment."
  ) |>
  add_row(
    Concept = "k_geom (local neighborhood size)",
    Definition = "How many nearest spatial neighbors define a bin’s/cell's niche.",
    `Key params` = "Integer (e.g., 6–12 for HD bins/cells)",
    `Practical tip` = "↑k = smoother/merge risk; ↓k = sharper/border-preserving."
  ) |>
  add_row(
    Concept = "λ (neighbor influence)",
    Definition = "How strongly neighbors affect each bin’s/cell's expression.",
    `Key params` = "0–1 (start ≈ 0.4)",
    `Practical tip` = "↑λ = denoise/over-smooth risk; ↓λ = crisp/possibly noisy."
  ) |>
  add_row(
    Concept = "Outcome",
    Definition = "Denoised matrix and niches that align with histology.",
    `Key params` = "features = 'variable'",
    `Practical tip` = "Validate on image & markers; adjust k_geom/λ as needed."
  )

ezKable(banksy_niches)
```

</details>

`r if(has_banksy) paste("Lambda:", ifelse(!is.null(param$lambda), param$lambda, 0.8))`

`r if(has_banksy) paste("Resolution:", ifelse(!is.null(param$Niche_resolution), param$nicheResolution, 0.5))`


```{r banksy plot spatial, fig.width=12, fig.height=6, eval=has_banksy}
Idents(scData) <- "banksy_cluster"

n_clusters_banksy <- nlevels(Idents(scData))
show_leg_banksy   <- n_clusters <= 20

p1 <- DimPlot(scData,
              label = FALSE,
              pt.size = 0.5) +
  labs(color = "Clusters") +
  theme_void() +
  guides(color = if (show_leg) guide_legend(title = "Clusters") else "none") +
  ggtitle("UMAP") +
  theme(legend.position = "none")

p1 <- Seurat::LabelClusters(
  plot     = p1,
  id       = "ident",
  fontface = "bold",
  box = T,
  color    = "white",
  size     = 4
)

p_spatialNiches <- SpatialDimPlot(scData, 
                    group.by = "banksy_cluster", 
                    label = T, 
                    plot_segmentations = T,
                    repel = T, 
                    label.size = 4
                    # ,
                    # interactive = T #to check on segmentation 
                    ) +
  
  labs(fill = "Clusters") +
  guides(fill = if (show_leg_banksy) guide_legend(title = "Clusters") else "none")

(p1 + p_spatialNiches) +
  plot_layout(nrow = 1, guides = if (show_leg) "collect" else "keep") 
```

```{r, fig.width=20, fig.height=20, dpi=300}
# banksy_cells <- CellsByIdentities(scData)
# 
# SpatialDimPlot(scData, 
#                cells.highlight = banksy_cells[setdiff(names(banksy_cells), "NA")], 
#                            cols.highlight = c("#FFFF00", 
#                                               "grey50"), 
#                            facet.highlight = T, 
#                            combine = T) + 
#   NoLegend() 

```

<br>

::: {.row}
::: {.col-md-9}

```{r number of cells in each cluster banksy, fig.width=18, fig.height=10, eval=has_banksy}
# if(!('Batch' %in% colnames(scData@meta.data))){
#     scData@meta.data$Batch <- scData@meta.data$Sample
# }

cellIdents_perSample <- scData@meta.data[,c('banksy_cluster', 'Sample')]
#cellIdents_perSample$Batch <- factor(cellIdents_perSample$Batch)



ggplot(cellIdents_perSample, aes(x = banksy_cluster, 
                    fill = Sample)) +
  geom_bar(fill = "#93AECA") +
#  scale_fill_manual(values = pal) +
  labs(title = "Bins/cells per cluster and sample (counts)",
       x = NULL, 
       y = "bins/cells"
  ) + 
  theme_minimal()+
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) + 
  theme(legend.position="top", 
        panel.grid.minor=element_blank(),
        panel.grid.major=element_blank(),
        scale_y_continuous(expand = expansion(mult = c(0.02, 0.15))),
        axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)
  )

```

:::

::: {.col-md-3}
```{r, echo=FALSE, eval=has_banksy}

df <- cellsProportion(scData, groupVar1 = "banksy_cluster", groupVar2 = "Sample") 
df <- df |> as.data.frame(check.names = FALSE, stringsAsFactors = FALSE) |>
  dplyr::rename("Cluster"="banksy_cluster")



is_pct_col <- grepl("_fraction$", colnames(df))
colnames(df) <- colnames(df) |> str_replace_all("_fraction$", " (%)")
is_count_col <- !is_pct_col & colnames(df) != "Cluster"
colnames(df)[is_count_col] <- colnames(df)[is_count_col] |> paste("(n)")

ezInteractiveTableRmd(df, rowNames = FALSE, title="number of bins/cells", filter="none")|>
  DT::formatPercentage(columns = is_pct_col, digits = 2) 


```

:::
:::


### Niches assessment


```{r uninteresting variation banksy, fig.height=16, fig.width=18, eval=has_banksy}
plot1 <- VlnPlot(scData,
                 nCountCol,
                 group.by = "banksy_cluster",
                 pt.size = 0,          
                 raster = T) +
  
  ggtitle("Number of UMIs vs cluster") +
  
  ylab(nCountCol) +
  
  theme_minimal(base_size = 12) +
  
  theme(legend.position = "none",
        axis.title.x = element_blank()) +
  
  scale_y_log10(
    breaks = log_breaks(base = 10),
    labels = label_number()
  )

plot2 <- VlnPlot(scData,
                 nFeatureCol,     
                 group.by = "banksy_cluster",
                 pt.size  = 0,
                 raster   = T) +
  
  ggtitle("Number of genes vs cluster") +
  
  ylab(nFeatureCol) +
  
  theme_minimal(base_size = 12) +
  
  theme(legend.position = "none",
        axis.title.x = element_blank()) +
  
  scale_y_log10(
    breaks = log_breaks(base = 10),
    labels = label_number()
  )


plot3 <- VlnPlot(scData,
                 "percent_mito",     
                 group.by = "banksy_cluster",
                 pt.size = 0,
                 raster = T) +
  ggtitle("Mitochondrial percentage vs cluster") +
  xlab("Cluster") +
  ylab("percent_mito") +
  theme_minimal(base_size = 12) +
  theme(legend.position = "none")

plot1 + plot2 + plot3 + plot_layout(nrow = 3, ncol = 1)

```

### Niches markers

<details>
  <summary>Positive marker detection for BANKSY niches</summary>

```{r wilcoxon test banksy, eval=(param$DE.method=="wilcox"), results='asis', eval=has_banksy}
marker_tbl <- tibble(
  Step = character(),
  Details = character()
) |>
  add_row(
    Step = "Goal",
    Details = paste(
      "Identify genes that are significantly higher in a given BANKSY niche compared to all other bins/cells (\"positive markers\").",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Test",
    Details = paste(
      "Wilcoxon Rank Sum test (niche vs. all other bins/cells).",
      "Non-parametric; robust to non-normal distributions.",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Effect size filter",
    Details = paste(
      "Average log-fold change ≥ 0.25 (log-scale).",
      "Ensures selected markers have a meaningful up-regulation.",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Significance threshold",
    Details = paste(
      "Adjusted p-value < 0.05.",
      "Controls for multiple testing across genes.",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Direction",
    Details = paste(
      "Keep only **up-regulated** genes in the target niche (\"positive\" markers).",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Outputs",
    Details = paste(
      "For each niche: gene list with log2FC, pct.1 (in-niche detection), pct.2 (out-of-niche), p_val_adj, etc.",
      "Significant markers satisfy both effect-size and adjusted p-value criteria.",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Notes",
    Details = paste(
      "Inspect pct.1 vs pct.2 to confirm specificity.",
      "Very small p-values should be displayed in scientific notation; export raw values to avoid rounding to 0 in Excel.",
      sep = "\n"
    )
  )

ezKable(marker_tbl)
```

Marker detection summary

```{r LR test banksy, eval=(param$DE.method=="LR"), results='asis'}

marker_desc <- tibble(
  Item    = c("Test", "Covariate", "Effect size", "Significance", "Definition"),
  Details = c(
    "Logistic regression (niche vs all other bins/cells).",
    "Cell cycle included as a batch effect in the model.",
    "Average log-fold change ≥ 0.25 (log scale).",
    "Adjusted p-value < 0.05.",
    "Genes meeting both thresholds are called significant positive markers."
  )
)

ezKable(marker_desc)
```

 </details>



```{r pos markers banksy, eval=has_banksy && nrow(posMarkersBanksy) > 0}

ezInteractiveTableRmd(posMarkersBanksy, digits=3, rowNames=FALSE)

```


### Marker plots

```{r marker plot setup banksy, eval=has_banksy && nrow(posMarkersBanksy) > 0}
top5 <- posMarkersBanksy %>%
  group_by(cluster) %>%
  slice_max(n = 5, order_by = tibble(diff_pct, avg_log2FC))
genesToPlot <- c(gsub("_", "-", param$controlSeqs), unique(as.character(top5$gene)))
genesToPlot <- intersect(genesToPlot, rownames(scData))
```


#### DotPlot

Visualization of the top 5 markers in each cluster. If a gene is a top marker for multiple clusters it is shown only once.


```{r dotplot banksy, fig.width  = 20, fig.height = 30, eval=has_banksy && nrow(posMarkersBanksy) > 0 && has_niche_genes}

DotPlot(scData, features=rev(genesToPlot)) + 
  coord_flip() +
  scale_y_discrete(limits = as.character(sort(as.integer(levels(Idents(scData)))
                                              )
                                         )
                   ) +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
```

### EnrichR
```{r query online enrichR version banksy, echo=FALSE, results='asis', eval=has_banksy && nrow(posMarkersBanksy) > 0}
markersPerClusterTable <- c()

eachCluster <- 0

for (eachCluster in levels(posMarkersBanksy$cluster)) {
  markersPerCluster <- dplyr::filter(posMarkersBanksy,
                                     cluster == eachCluster) |>
    dplyr::arrange(desc(avg_log2FC))

  markersPerCluster <- head(markersPerCluster,
                            min(nrow(markersPerCluster), 500)
                            )

  markersPerClusterTable <- rbind(markersPerClusterTable,
                                  markersPerCluster)
}

genesPerCluster <- split(gsub("\\.m[0-9]+$", "", markersPerClusterTable$gene),
                         markersPerClusterTable$cluster)

jsCall = paste0('enrich({list: "',
                sapply(genesPerCluster,
                       paste,
                       collapse="\\n"),
                '", popup: true});')

enrichrCalls <- paste0("<a href='javascript:void(0)' onClick='",
                       jsCall,
                       # "'>Analyse at Enrichr website</a>"
                       "'>Open</a>")



```


```{r enrichr markers banksy, echo=FALSE, results='asis', eval=has_banksy && nrow(posMarkersBanksy) > 0}
enrichrTable1 <- tibble(Cluster=names(genesPerCluster),
                         # "# of posMarkers"=lengths(genesPerCluster),
                         "N posMarkers"=lengths(genesPerCluster),
                         "Enrichr link"=enrichrCalls)

if (!is.null(enrichRout)){
  enrichRTerm <- as.data.frame(do.call(rbind,
                                       lapply(enrichRout, as.vector)))

  enrichRTerm <- map_df(enrichRTerm, 
                        ~ map_df(.x, 
                                 ~ replace(.x, is.null(.x), NA)), 
                        .id = "database")

  enrichRTerm <- enrichRTerm |>
    group_by(., Cluster, database) |>
    summarise(topTerms = paste(Term, collapse = "; ")) |>
    as.data.frame()

  enrichRTerm <- dcast(enrichRTerm, ... ~ database)

  enrichrTable1 <- merge(enrichrTable1, enrichRTerm, by = "Cluster")
}

## settings needed to make sure links remain links
ezKable(enrichrTable1, escape=FALSE, format="html", format.args=list())

```

## Links

### Data files

##### Aggregated expression of every gene across the bins/cells in each cluster

[geneExprPerCluster](bulkSignalPerCluster.tsv)

##### Aggregated expression of every gene across all the bins/cells

[geneExprPerSample](bulkSignalPerSample.tsv)

##### Positive markers of each cluster

[posMarkers](cluster_markers.tsv)



##### The final Seurat Object is [here](scData.qs2)

## Parameters

### Parameters used

```{r report parameters, echo=FALSE}

ezListAsKable(param[c("binSize",
        "npcs",
        "clusterResolution",
        "nicheResolution",
        "lambda",
        "DE.method",
        "nUMIs",
        "nmad")],
        col.names=c("Parameter", "Value"),
        caption="Parameters used")

  
```

### Session Info

```{r, echo=FALSE}


format(Sys.time(), '%Y-%m-%d %H:%M:%S')
ezSessionInfo()
```

