---
title: "`r if (exists('reportTitle')) reportTitle else 'SUSHI Report'`"
output: 
  html_document:
    mathjax: https://fgcz-gstore.uzh.ch/reference/mathjax.js
    self_contained: true
    includes:
      in_header: !expr system.file("templates/fgcz_header.html", package="ezRun")
    css: !expr system.file("templates/fgcz.css", package="ezRun")
editor_options: 
  chunk_output_type: inline
---

# {.tabset}

## Cell Filtering {.tabset}

```{r setup, include=FALSE}
library(Seurat)
library(ggplot2)
library(patchwork)
library(dplyr)
library(RColorBrewer)
library(kableExtra)
library(ezRun)
library(scater)
library(SingleCellExperiment)
library(enrichR)
library(SCpubr)
library(qs2)

library(DT)
library(ggtext)
library(grid) 
library(htmltools)
library(patchwork)
library(scales)
library(UpSetR)

library(SeuratWrappers)
library(Banksy)
library(spacexr)

library(sf)
library(Matrix)
library(SpotSweeper)
library(SpatialExperiment)

knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, knitr.table.format = "html")
```


```{r}
posMarkers <- readxl::read_xlsx("posMarkers.xlsx")
posMarkers$gene = as.factor(posMarkers$gene)
posMarkers$cluster <- makeGroupingVariableSortedFactor(posMarkers$cluster)
posMarkers$p_val_adj[posMarkers$p_val_adj==0] <- min(posMarkers$p_val_adj[posMarkers$p_val_adj>0])
if (file.exists("posMarkersBanksy.xlsx")) {
  posMarkersBanksy <- readxl::read_xlsx("posMarkersBanksy.xlsx")
  posMarkersBanksy$gene = as.factor(posMarkersBanksy$gene)
  posMarkersBanksy$cluster <- makeGroupingVariableSortedFactor(posMarkersBanksy$cluster)
  posMarkersBanksy$p_val_adj[posMarkersBanksy$p_val_adj==0] <-
    min(posMarkersBanksy$p_val_adj[posMarkersBanksy$p_val_adj>0])
} else {
  posMarkersBanksy <- data.frame()
}
param <- qs_read("param.qs2")
lambda <- param$lambda  # BANKSY spatial weighting parameter
input <- qs_read("input.qs2")
output <- qs_read("output.qs2")
scData <- qs_read("scData.qs2")
names(scData@images) <- make.names(names(scData@images))
if (scData@version < package_version("5.3.0")){
  scData <- SeuratObject::UpdateSeuratObject(scData)
}
scData_unfiltered <- qs_read("scData_unfiltered.qs2")
names(scData_unfiltered@images) <- make.names(names(scData_unfiltered@images))
if (scData_unfiltered@version < package_version("5.3.0")){
  scData_unfiltered <- SeuratObject::UpdateSeuratObject(scData_unfiltered)
}

nCountCol <- grep('^nCount_Spatial.*', 
                  colnames(scData@meta.data), 
                  value=TRUE) |> head(1)

nFeatureCol <- grep('^nFeature_Spatial.*', 
                    colnames(scData@meta.data), 
                    value=TRUE) |> head(1)

imageName <- names(scData@images)
stopifnot(length(imageName) == 1)
#allCellsMeta <- qs_read("allCellsMeta.qs2")
#sampleName <- input$getNames()

enrichRout <- NULL
aziResults <- NULL


scData   <- fix_microscopy_image(scData, 
                      imageName, 
                      eps = 0.02, 
                      margin = 0.01)


```

```{r seurat to spe}

scData_unfiltered$discard <- !scData_unfiltered$useCell
spe <- Seurat_to_SPE(scData_unfiltered, scData_unfiltered[[imageName]]@boundaries$centroids@coords)


```


`r paste("Output:", param$binSize)`


::: {.row}
::: {.col-md-6}

```{r upset_plot, echo=FALSE, message=FALSE, warning=FALSE}

qcFrame <- colData(spe) |> data.frame() |> dplyr::select(starts_with("qc."))
qcFrame[is.na(qcFrame)] <- FALSE

# Rename to friendly names
name_map <- c(qc.lib = "UMI_Counts", qc.nexprs = "nGenes",
              qc.mito = "Mito_Percent", qc.riboprot = "Ribo_Percent")
for (old in names(name_map)) {
  if (old %in% colnames(qcFrame)) colnames(qcFrame)[colnames(qcFrame) == old] <- name_map[old]
}

## select only columns that have at least one flag
useColumn <- apply(qcFrame, 2, any)
qcFrame <- qcFrame[, useColumn, drop = FALSE]

if (ncol(qcFrame) > 1) {
  UpSetR::upset(
    qcFrame + 0, ## convert from logical to integer
    nsets = min(5, ncol(qcFrame)),
    mainbar.y.label = "bins/cells"
  ) |> print()
  grid.text("bins/cells removed", x = 0.65, y = 0.95, gp = gpar(fontsize = 20))
} else if (ncol(qcFrame) == 1) {
  n_flagged <- sum(qcFrame[[1]])
  n_total <- nrow(qcFrame)
  df <- data.frame(
    Status = c("Removed", "Kept"),
    Count = c(n_flagged, n_total - n_flagged)
  )
  p <- ggplot(df, aes(x = Status, y = Count, fill = Status)) +
    geom_bar(stat = "identity") +
    scale_fill_manual(values = c("Removed" = "#e74c3c", "Kept" = "#2ecc71")) +
    geom_text(aes(label = Count), vjust = -0.5, size = 5) +
    labs(title = paste("Bins/cells removed by:", colnames(qcFrame)),
         y = "Number of bins/cells") +
    theme_minimal() +
    theme(legend.position = "none")
  print(p)
} else {
  cat("No cells were removed by quality filtering.")
}

```
:::

::: {.col-md-6}

```{r qc_stats_table, echo=FALSE, message=FALSE, warning=FALSE}

meta <- colData(spe)

qcStats <- ezFrame(
  "Number of bins/cells" = numeric(0),
  "Min Pass Value"       = numeric(0),
  "Max Pass Value"       = numeric(0),
  "Fraction removed"     = numeric(0)
)

qcStats["UMI Counts", ] <- c(
  c(sum(meta$qc.lib),
    range(meta[[nCountCol]][meta$useCell])) %>% as.integer(),
  round(sum(meta$qc.lib) / nrow(meta), 2)
)

qcStats["# Genes", ] <- c(
  c(sum(meta$qc.nexprs),
    range(meta[[nFeatureCol]][meta$useCell])) %>% as.integer(),
  round(sum(meta$qc.nexprs) / nrow(meta), 2)
)

if (!is.null(meta$qc.mito) && sum(meta$qc.mito, na.rm = TRUE) > 0) {
  qcStats["Mitochondrial %", ] <- c(
    c(sum(meta$qc.mito, na.rm = TRUE),
      range(meta$percent_mito[meta$useCell])) %>% as.integer(),
    round(sum(meta$qc.mito, na.rm = TRUE) / nrow(meta), 2)
  )
}

if (!is.null(meta$qc.riboprot) && sum(meta$qc.riboprot, na.rm = TRUE) > 0) {
  qcStats["Ribosomal %", ] <- c(
    c(sum(meta$qc.riboprot, na.rm = TRUE),
      range(meta$percent_riboprot[meta$useCell])) %>% as.integer(),
    round(sum(meta$qc.riboprot, na.rm = TRUE) / nrow(meta), 2)
  )
}

ezKable(qcStats)
  

```

:::

::: 




<details>
  <summary>Metrics to identify bins/cells of low quality</summary>
  
```{r QC metrics, echo=F, message=F, warning=F}

qcMetrics <- tibble(
  metric = character(),
  interpretation = character()
) |>
  add_row(
    metric = "Library size – total sum of counts across all relevant features for each bin/cell",
    interpretation = "Small library sizes indicate low quality (RNA may have been lost during library preparation)"
  ) |>
  add_row(
    metric = "Number of expressed genes with non-zero counts in each bin/cell",
    interpretation = "Very few expressed genes means poor capture of the transcript population"
  ) |>
  add_row(
    metric = "Mitochondrial proportion – percentage of reads mapping to mitochondrial genes in each bin/cell",
    interpretation = "High mitochondrial proportion indicate poor quality (loss of cytoplasmic RNA from perforated bins) (Islam et al. 2014; Ilicic et al. 2016)"
  )

ezKable(qcMetrics)


```

Evaluation


```{r diagnostics plots, echo=F, message=F, warning=F}

qcDiagnostics <- tibble(
  check = character(),
  interpretation = character()
) |>
  add_row(
    check = "Independence of QC metrics",
    interpretation = "QC metrics should reflect technical quality, not biological state (e.g., low library size or high mitochondrial proportion should not correspond to specific cell types)."
  ) |>
  add_row(
    check = "Distribution of values",
    interpretation = "Ideally, metrics follow a normal distribution, supporting threshold-based outlier detection."
  ) |>
  add_row(
    check = "Secondary modes",
    interpretation = "A large secondary peak (another mode) suggests correlation with biology, risking loss of distinct cell types."
  ) |>
  add_row(
    check = "Violin plots",
    interpretation = "Show bins/cells kept (`FALSE`) vs discarded (`TRUE`) after QC filtering, highlighting potential biases."
  ) |>
  add_row(
    check = "Spatial plots",
    interpretation = "Visualize QC metrics across the tissue to detect spatial patterns of low quality."
  )

ezKable(qcDiagnostics)

```
</details>





```{r nCount plots, fig.width=12, fig.height=4}

plot1 <- plotColData(
  spe, x = "Sample", 
  y = nCountCol, 
  colour_by = "discard"
) +  scale_y_log10() +
  labs(title = "UMI counts", y = "UMI counts per bin/cell") 


plot2 <- ezSpatialFeaturePlot(
  scData_unfiltered, nCountCol,
  title = "UMI per bin/cell",
  label = "UMI counts"
)

plot3 <- ezSpatialFeaturePlot(
  scData_unfiltered, nCountCol,
  title  = "Raw image",
  label  = NULL,
#  images = img_name,
  alpha  = c(0, 0)
) + guides(fill = "none")



plot1 + plot2 + plot3

```


```{r nGenes, fig.width=12, fig.height=4}

plot1 <- plotColData(
  spe, x = "Sample", 
  y = nFeatureCol, 
  colour_by = "discard"
) +  
  labs(title = "Genes", y = "#genes per bin/cell") 


plot2 <- ezSpatialFeaturePlot(
  scData_unfiltered, nFeatureCol,
  title = "Genes per bin/cell",
  label = "#genes"
)


plot3 <- plotColData(
  spe,
  x = nCountCol,
  y = nFeatureCol,
  colour_by = "discard"
) +
  scale_x_log10() +
  scale_y_log10() +
  labs(
    title = "",
    x = "UMI counts",
    y = "#genes"
  )

plot1 + plot2 + plot3


```


```{r percent mito, fig.width=12, fig.height=4}


plot1 <- plotColData(
  spe, x = "Sample", 
  y = "percent_mito", 
  colour_by = "discard"
) +  
  labs(title = "percent mito", y = "Percent mitochondrial UMIs") 

scData_unfiltered$percent_mito[is.nan(scData_unfiltered$percent_mito)] <- 0
plot2 <- ezSpatialFeaturePlot(
  scData_unfiltered, "percent_mito",
  title = "",
  label = "percent mito"
)


plot3 <- plotColData(
  spe,
  x = nCountCol,
  y = "percent_mito",
  colour_by = "discard"
) +
  scale_x_log10() +
  scale_y_log10() +
  labs(
    title = "",
    x = "UMI counts",
    y = "percent mito"
  )

plot1 + plot2 + plot3





```

```{r percent ribo, fig.width=12, fig.height=4}



if (!is.null(spe$percent_riboprot) && 
    any(spe$percent_riboprot > 0, na.rm=TRUE)) {
  
  plot1 <- plotColData(
    spe, x = "Sample", 
    y = "percent_riboprot", 
    colour_by = "discard"
  ) +  
    labs(title = "percent riboprot", y = "Percent ribosomal protein UMIs") 
  
  scData_unfiltered$percent_riboprot[is.nan(scData_unfiltered$percent_riboprot)] <- 0
  plot2 <- ezSpatialFeaturePlot(
    scData_unfiltered, "percent_riboprot",
    title = "",
    label = "percent riboprot"
  )
  
  plot3 <- plotColData(
    spe,
    x = nCountCol,
    y = "percent_riboprot",
    colour_by = "discard"
  ) +
    scale_x_log10() +
    scale_y_log10() +
    labs(
      title = "",
      x = "UMI counts",
      y = "percent riboprot"
    )
  
  plot1 + plot2 + plot3
  
  
}  


```


<details>
  <summary>Filtering rules</summary>

```{r cell filter, echo=F, message=F, warning=F}

cellFilter <- tibble(
  criterion = character(),
  rule = character()
) |>
  add_row(
    criterion = "Assumption — majority of cells are high-quality",
    rule = "Enables data-driven thresholds using QC metrics without detailed protocol knowledge."
  ) |>
  add_row(
    criterion = "Fixed thresholds (if provided)",
    rule = "If `nreads`, `ngenes`, or `perc_mito` are supplied, use those fixed cutoffs for filtering."
  ) |>
  add_row(
    criterion = "Adaptive: library size (nreads)",
    rule = "Exclude cells with library size < median − 3 × MAD (Median Absolute Deviation)"
  ) |>
  add_row(
    criterion = "Adaptive: detected genes (ngenes)",
    rule = "Exclude cells with detected genes < median − 3 × MAD."
  ) |>
  add_row(
    criterion = "Adaptive: mitochondrial proportion (perc_mito)",
    rule = "Exclude cells with mito % > median + 3 × MAD."
  ) |>
  add_row(
    criterion = "Gene-level prevalence filter",
    rule = "Keep genes present in ≥ N cells (or ≥ p% of cells); drop low-prevalence genes."
  )

ezKable(cellFilter)
```
</details>


## Dimensionality reduction


<details>
  <summary>Background information</summary>

```{r dim_ tbl, echo=F, message=F, warning=F}
dimred_tbl <- tibble(
  topic = character(),
  summary = character()
) |>
  add_row(
    topic   = "Goal",
    summary = "Reduce the number of dimensions by compressing information from many genes into fewer components."
  ) |>
  add_row(
    topic   = "Why it works",
    summary = "Genes affected by the same biological process are correlated, so separate storage per gene is redundant."
  ) |>
  add_row(
    topic   = "Benefits",
    summary = paste(
    "Computational efficiency — fewer dimensions to process.",
    "Noise reduction — averaging across genes sharpens true patterns.",
    "Visualization — enables clear 2D/3D plotting.",
    sep = "<br>"
  )
  ) |>
  add_row(
    topic   = "Method (example)",
    summary = "Principal Component Analysis (PCA) on normalized/centered data to obtain ranked components."
  ) |>
  add_row(
    topic   = "How many PCs?",
    summary = "Typically retain ~10–50 PCs for downstream analyses (dataset-dependent)."
  ) |>
  add_row(
    topic   = "How to choose PCs",
    summary = paste0(
      "Use a scree/variance-explained plot (a.k.a. Elbow plot). ",
      "Rank PCs by % variance explained; select PCs up to the elbow."
    )
  ) |>
  add_row(
    topic   = "Elbow plot logic",
    summary = paste0(
      "Assumption: PCs carrying biological signal explain markedly more variance than the rest. ",
      "Past the last “biological” PC, the variance drops sharply → the elbow indicates a natural cutoff."
    )
  )

ezKable(dimred_tbl)

```
</details>


```{r, fig.width=10, echo=F, message=F, warning=F}

pca_name <- intersect(c("pca.sketch", "pca"), names(scData@reductions)) |> head(1)

stdev <- scData[[pca_name]]@stdev

n_use <- min(param$npcs, length(stdev))
stopifnot(n_use >= 1, n_use <= length(stdev))

var_pct <- (stdev^2) / sum(stdev^2) * 100
cum_pct <- cumsum(var_pct)

df <- data.frame(
  PC   = seq_along(stdev),
  perc = var_pct,
  cum  = cum_pct,
  used = seq_along(stdev) <= n_use
)

ggplot(df, 
       aes(x = PC)) +
  
  geom_col(aes(y = perc, 
               fill = used), 
           width = 0.7, 
           show.legend = FALSE) +
  
  scale_fill_manual(values = c(`TRUE` = "grey20", 
                               `FALSE` = "grey75")) +
  
  geom_line(aes(y = cum / max(cum) * max(perc), 
                group = 1), 
            linewidth = 0.5, 
            color = "orange") +
  
  geom_point(aes(y = cum / max(cum) * max(perc)), 
             size = 1, color = "orange") +

  geom_vline(xintercept = n_use, 
             linetype = "dashed", 
             color = "grey40") +
 
  scale_y_continuous(
    name = "Variance explained (%)",
    sec.axis = sec_axis(~ . / max(df$perc) * 100, 
                        name = "Cumulative variance (%)")
  ) +
  
  labs(
    title    = "PCA variance explained",
    subtitle = paste0("PCs used: ", 
                      n_use, 
                      "   |   Cumulative: ", 
                      sprintf('%.2f%%', 
                              df$cum[n_use])),
    x = NULL) +
  theme(
    text               = element_text(face = "bold"),
    axis.title.y.left  = element_text(color = "grey20"),
    axis.title.y.right = element_text(color = "orange"),
    plot.title         = element_text(hjust = 0.5),
    panel.grid.minor   = element_blank()
  )

```



## Segmentation mask

`r {
  if (identical(param$binSize, "segmented_outputs")) {
    n <- nrow(scData@images[[imageName]]@boundaries$segmentation@sf.data)
    paste("N cells:", n)
  } else ""
}`

```{r, fig.height=16, fig.width=20}

ezSpatialFeaturePlot(
  scData_unfiltered,
  nCountCol,
  label = "UMI counts",
  stroke = 0.2,
  image.scale= "hires",
  crop=TRUE
)

```


### Zoom in mask


```{r, fig.width=25, fig.height=20}

## TODO: use vitessce viewer instead

coords <- GetTissueCoordinates(scData_unfiltered)
xRange <- coords$x |> range()
yRange <- coords$y |> range()
xCenter <- mean(xRange)
xDiff <- diff(xRange)
yCenter <- mean(yRange)
yDiff <- diff(yRange)

use <- coords$x > xCenter - xDiff /20 & coords$x < xCenter + xDiff /20 &
  coords$y > yCenter - yDiff /20 & coords$y < yCenter + yDiff /20

center <- coords[ round(nrow(coords)/2) , c("x", "y")]
xRange <- coords$x |> range() |> diff()
croppedRange <- xRange * 0.1

if(length(which(use)) > 0){
    ezSpatialFeaturePlot(
        subset(scData_unfiltered, cells=which(use)),
        nCountCol,
        pt.size.factor = 5,
        label = "UMI counts",
        stroke = 0.2,
        crop = TRUE
    )
}
```

### Cell size/density

<details>
  <summary>Segmentation QC</summary>
  
```{r}

if (identical(param$binSize, "segmented_outputs")) {

    qc_text_tbl <- tibble(
    topic = c(
      "Cell size distributions (per image)",
      "Image area covered by cells"
    ),
    summary = c(
      paste(
        "Compare the distributions of cell size across individual images.",
        "Differences can indicate segmentation bias (e.g., density-dependent over/under-segmentation)",
        "or genuine biology driven by cell-type composition",
        "(e.g., tumor cells often larger than immune cells).",
        sep = " "
      ),
      paste(
        "Coverage = total cell area ÷ image area (per ROI).",
        "Low coverage flags ROIs with few cells, possibly due to incorrect ROI selection",
        "or non-tissue/artifact regions; review recommended.",
        sep = " "
      )
    )
  )

  ezKable(qc_text_tbl, 
          caption = "QC notes for image-level metrics", 
          escape = FALSE)

}

```
  </details>
  
`r {
  if (identical(param$binSize, "segmented_outputs")) {
    d <- dim(scData@images[[imageName]]@image)
    paste("Image dimension:", paste(d, collapse = " × "))
  } else "This tab is only for *segmented outputs* and isn’t applicable to bin-based results"
}`




#### Cell size

::: {.row}
::: {.col-md-6}

```{r cell area plot}

if (identical(param$binSize, "segmented_outputs")) {

  #scData@images[[imageName]]@boundaries$segmentation@sf.data |>
  rings <- Seurat::GetTissueCoordinates(scData, which="segmentation", return.sf=TRUE) |>
    group_by(cell) %>%
    summarise(
      ring = list(list(
        cbind(x, y)#,
      )),
      .groups = "drop"
    )
  geom <- st_sfc(lapply(rings$ring, st_polygon))
  poly_sf <- st_sf(cell = rings$cell, geometry = geom)
  poly_sf$area <- as.numeric(st_area(poly_sf))
  scData <- AddMetaData(scData, 
                        metadata = setNames(poly_sf$area, poly_sf$cell),
                        col.name = "areaHires")
    

  VlnPlot(scData, 
          features = "areaHires", 
          pt.size = 0) +
    labs(y = "Area [um]") + NoLegend()

} 

```

<br>
<br>

```{r cell area stats}
if (identical(param$binSize, "segmented_outputs")) {
  qcArea <- summary(scData$areaHires) |>
    round() |> 
    as.list() |> 
    as.data.frame()
  rownames(qcArea) <- imageName

  ## pedestrian implementation of the above
  # vals <- summary(scSub$areaPX2hires)
  # qs  <- quantile(vals, 
  #                 probs = c(a=0, .25, .5, .75, 1), 
  #                 names = FALSE, 
  #                 na.rm = TRUE)
  # 
  # mn  <- mean(vals, na.rm = TRUE)
  # 
  # N   <- length(vals)
  # 
  # qcArea <- ezFrame(
  #   "N cells" = integer(0),
  #   "Min"     = numeric(0),
  #   "1st Qu." = numeric(0),
  #   "Median"  = numeric(0),
  #   "Mean"    = numeric(0),
  #   "3rd Qu." = numeric(0),
  #   "Max"     = numeric(0)
  # )
  # 
  # qcArea[ Images(scData), ] <- c(N, 
  #                          qs[1], 
  #                          qs[2], 
  #                          qs[3], 
  #                          mn, 
  #                          qs[4], 
  #                          qs[5]) |> round(0)

  ezKable(qcArea)
}
```
:::
::: {.col-md-6}



```{r, eval=FALSE}

# if (identical(param$binSize, "segmented_outputs")) {
#  
#   sfp <- scData@images[[imageName]]@boundaries$segmentation@sf.data
#   lo  <- scData@images[[imageName]]@scale.factors$lowres
# 
#   W <- ncol(scData@images[[imageName]]@image)/lo
#   H <- nrow(scData@images[[imageName]]@image)/lo
#   covered <- sum(st_area(sfp)) / (W * H)
# 
#   ggplot(data.frame(sample=imageName, 
#                     covered=covered),
#          aes(sample, 
#              covered)) +
#   
#     geom_point(size = 3) + 
#   
#     theme_minimal(base_size = 12) +
#   
#     ylim(0,1) +
#   
#     labs(y="% covered area", 
#          x = "")
#   
# } 

```
:::
:::


## Clusters  {.tabset}

### Clustering

<details>
  <summary>KNN → communities → clusters</summary>

```{r, echo=F}
npcs_txt <- sprintf("%s PCs", param$npcs)

cluster_tbl <- tibble(
  Step = character(),
  Details = character()
) |>
  add_row(
    Step = "Build KNN graph",
    Details = paste(
      "Each node = bin/cell.",
      sprintf("Connect each bin/cell to its k nearest neighbors in %s space.", npcs_txt),
      "Distance usually Euclidean (on PCs) or cosine.",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Edge weighting",
    Details = paste(
      "Edges weighted by similarity (e.g., shared nearest neighbors/Jaccard).",
      "Higher weight = more similar bins/cells.",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Community detection",
    Details = paste(
      "Apply a community detection algorithm (e.g., Leiden/Louvain) on the KNN graph.",
      "Find groups more connected internally than externally.",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Cluster labels",
    Details = paste(
      "Each community becomes a cluster ID per bin/cell.",
      "Used for downstream interpretation (markers, enrichment, etc.).",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Visualization",
    Details = paste(
      "Plot clusters on UMAP and in image space to assess structure.",
      "Do not run statistical analyses directly on UMAP coordinates;",
      "use them for QC/visual inspection (e.g., neighboring subclusters, potential splits).",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Best practices & caveats",
    Details = paste(
      sprintf("Tune parameters: k (neighbors), resolution (Leiden/Louvain), and %s.", npcs_txt),
      "Check stability (seeds/subsampling) and biological plausibility.",
      "Beware tiny clusters (may be noise) and batch/spatial artifacts.",
      sep = "\n"
    )
  )

ezKable(cluster_tbl)

```
</details>
`r paste("Resolution:", param$clusterResolution)`

<br>


```{r, fig.height=6, fig.width=12}

n_clusters <- nlevels(Idents(scData))
show_leg   <- n_clusters <= 20

namedPalette <- setNames(
  DiscretePalette(length(levels(Idents(scData))
                         ), 
                  palette = "polychrome"), 
  levels(Idents(scData))
)

p1 <- DimPlot(scData,
              label = FALSE,
              pt.size = 0.5) +
  labs(color = "Clusters") +
  theme_void() +
  guides(color = if (show_leg) guide_legend(title = "Clusters") else "none") +
  ggtitle("UMAP") +
  theme(legend.position = "none")

p1 <- Seurat::LabelClusters(
  plot     = p1, 
  repel = T,
  box = T,
  id       = "ident",
  fontface = "bold",
  color    = "white",
  size     = 4
)


p2 <- SpatialDimPlot(
  scData,
  images = Images(scData),
  label              = T,
  label.size         = 4,
  repel              = T,        
  plot_segmentations = T,
  pt.size.factor     = 2
) +
  labs(fill = "Clusters") +
  guides(fill = if (show_leg) guide_legend(title = "Clusters") else "none")


(p1 + p2) +
  plot_layout(nrow = 1,
              guides = if (show_leg) "collect" else "keep")



```

<br>

::: {.row}
::: {.col-md-9}
```{r number of cells in each cluster, fig.width=12, fig.height=6}

cellIdents_perSample <- scData@meta.data[,c('seurat_clusters', 'Sample')]

ggplot(cellIdents_perSample, aes(x = seurat_clusters, fill = Sample)) +
  geom_bar(fill = "#93AECA") +
  #  scale_fill_manual(values = pal) +
  labs(title = "Bins/cells per cluster and sample (counts)",
       x = NULL, 
       y = "bins/cells"
  ) + 
  theme_minimal()+
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) + ## make sure the y axis is not expanded at the bottom
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)
  )

```
:::

::: {.col-md-3}
```{r, echo=FALSE}

df <- cellsProportion(scData, groupVar1 = "seurat_clusters", groupVar2 = "Sample") 
df <- df |> as.data.frame(check.names = FALSE, stringsAsFactors = FALSE) |>
  dplyr::rename("Cluster"="seurat_clusters")



is_pct_col <- grepl("_fraction$", colnames(df))
colnames(df) <- colnames(df) |> str_replace_all("_fraction$", " (%)")
is_count_col <- !is_pct_col & colnames(df) != "Cluster"
colnames(df)[is_count_col] <- colnames(df)[is_count_col] |> paste("(n)")

ezInteractiveTableRmd(df, rowNames = FALSE, title="number of bins/cells", filter="none")|>
  DT::formatPercentage(columns = is_pct_col, digits = 2) 


```
:::
:::

<br/>


### Cluster assessment

<details>
  <summary>Technical vs. biological clustering driver</summary>

```{r, echo=FALSE}

driver_qc_tbl <- tibble(
  Item    = character(),
  Details = character()
) |>
  add_row(
    Item    = "Purpose",
    Details = "Check whether clusters are driven by technical artifacts or uninteresting biology (cell cycle, mitochondrial/ribosomal content, library size)."
  ) |>
  add_row(
    Item    = "Potential confounders",
    Details = paste(
      "Cell cycle phase composition (G1/S/G2M).",
      "Mitochondrial % and ribosomal %.",
      "Library size (UMIs) and genes detected.",
      sep = "\n"
    )
  ) |>
  add_row(
    Item    = "Diagnostics",
    Details = paste(
      "Per-cluster phase distribution (bar charts) — look for clusters dominated by a single phase.",
      "Box/violin plots per cluster for UMIs, genes, mito%, ribo%.",
      "Statistical checks (e.g., Kruskal-Wallis/ANOVA across clusters).",
      sep = "\n"
    )
  ) |>
  add_row(
    Item    = "Mitigations",
    Details = paste(
      "Regress out cell cycle / mito% / ribo% in scaling/normalization (e.g., Seurat ScaleData/SCTransform vars.to.regress).",
      "Adjust clustering parameters (PCs, k, resolution) after normalization.",
      sep = "\n"
    )
  ) |>
  add_row(
    Item    = "Decision rule",
    Details = paste(
      "If a cluster is mainly explained by confounders, flag it and re-evaluate after regression/normalization.",
      "If differences are modest and later cell-type labels explain them, proceed with interpretation.",
      sep = "\n"
    )
  )

ezKable(driver_qc_tbl)
```

</details> 



```{r uninteresting variation, fig.height=16, fig.width=12}

plot1 <- VlnPlot(scData,
                 nCountCol,
                 group.by = "seurat_clusters",
                 pt.size = 0,          
                 raster = T) +
  
  ggtitle("Number of UMIs vs cluster") +
  
  ylab(nCountCol) +
  
  theme_minimal(base_size = 12) +
  
  theme(legend.position = "none",
        axis.title.x = element_blank()) +
  
  scale_y_log10(
    breaks = log_breaks(base = 10),
    labels = label_number()
  )

plot2 <- VlnPlot(scData,
                 nFeatureCol,     
                 group.by = "seurat_clusters",
                 pt.size  = 0,
                 raster   = T) +
  
  ggtitle("Number of genes vs cluster") +
  
  ylab(nFeatureCol) +
  
  theme_minimal(base_size = 12) +
  
  theme(legend.position = "none",
        axis.title.x = element_blank()) +
  
  scale_y_log10(
    breaks = log_breaks(base = 10),
    labels = label_number()
  )


plot3 <- VlnPlot(scData,
                 "percent_mito",     
                 group.by = "seurat_clusters",
                 pt.size = 0,
                 raster = T) +
  ggtitle("Mitochondrial percentage vs cluster") +
  xlab("Cluster") +
  ylab("percent_mito") +
  theme_minimal(base_size = 12) +
  theme(legend.position = "none")

plot1 + plot2 + plot3 + plot_layout(nrow = 3, ncol = 1)

```


### Cluster markers

<details>
  <summary>Positive marker detection</summary>

```{r wilcoxon test, eval=(param$DE.method=="wilcox"), results='asis'}
marker_tbl <- tibble(
  Step = character(),
  Details = character()
) |>
  add_row(
    Step = "Goal",
    Details = paste(
      "Identify genes that are significantly higher in a given cluster compared to all other bins/cells (\"positive markers\").",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Test",
    Details = paste(
      "Wilcoxon Rank Sum test (cluster vs. all other bins/cells).",
      "Non-parametric; robust to non-normal distributions.",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Effect size filter",
    Details = paste(
      "Average log-fold change ≥ 0.25 (log-scale).",
      "Ensures selected markers have a meaningful up-regulation.",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Significance threshold",
    Details = paste(
      "Adjusted p-value < 0.05.",
      "Controls for multiple testing across genes.",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Direction",
    Details = paste(
      "Keep only **up-regulated** genes in the target cluster (\"positive\" markers).",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Outputs",
    Details = paste(
      "For each cluster: gene list with log2FC, pct.1 (in-cluster detection), pct.2 (out-of-cluster), p_val_adj, etc.",
      "Significant markers satisfy both effect-size and adjusted p-value criteria.",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Notes",
    Details = paste(
      "Inspect pct.1 vs pct.2 to confirm specificity.",
      "Very small p-values should be displayed in scientific notation; export raw values to avoid rounding to 0 in Excel.",
      sep = "\n"
    )
  )

ezKable(marker_tbl)
```

Marker detection summary

```{r LR test, eval=(param$DE.method=="LR"), results='asis'}

marker_desc <- tibble(
  Item    = c("Test", "Covariate", "Effect size", "Significance", "Definition"),
  Details = c(
    "Logistic regression (cluster vs all other bins/cells).",
    "Cell cycle included as a batch effect in the model.",
    "Average log-fold change ≥ 0.25 (log scale).",
    "Adjusted p-value < 0.05.",
    "Genes meeting both thresholds are called significant positive markers."
  )
)

ezKable(marker_desc)
```
  
 </details>



```{r pos markers}
ezInteractiveTableRmd(posMarkers, digits=3, rowNames=FALSE)
```
 

### Marker plots

```{r marker plot setup}
top5 <- posMarkers  |> 
  group_by(cluster) |> 
  slice_max(n = 5, order_by = tibble(diff_pct, avg_log2FC))

genesToPlot <- c(gsub("_", "-", param$controlSeqs), unique(as.character(top5$gene)))

genesToPlot <- intersect(genesToPlot, rownames(scData))
```


#### DotPlot

Visualization of the top 5 markers in each cluster. If a gene is a top marker for multiple clusters it is shown only once.


```{r dotplot, fig.width  = 15, fig.height = 30}

DotPlot(scData, features=rev(genesToPlot)) + 
  coord_flip() +
  scale_y_discrete(limits = as.character(sort(as.integer(levels(Idents(scData)))))
                   ) +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))

```


```{r plot of user genes, fig.width=12, fig.height=shrinkToRange(length(param$controlSeqs)/5, c(6, 12)), eval=ezIsSpecified(param$controlSeqs)}
genesToPlot <- intersect(param$controlSeqs, rownames(scData))

if (length(genesToPlot) > 0){
  DoHeatmap(scData, features=unique(genesToPlot))
  DotPlot(scData, features=genesToPlot) + coord_flip() +
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
} else { 
  cat("controlseqs not found")
}
```



### EnrichR

<details>
  <summary>Cell type scoring (Enrichr)</summary>
  
```{r, echo=FALSE}

enrichr_tbl <- tibble(
  Item    = character(),
  Details = character()
) |>
  add_row(
    Item    = "Goal",
    Details = "Score clusters by cell-type/pathway activity via gene set enrichment of their positive markers."
  ) |>
  add_row(
    Item    = "Input",
    Details = "Per-cluster marker genes (upregulated vs. other clusters)."
  ) |>
  add_row(
    Item    = "Method",
    Details = paste(
      "Use Enrichr to perform over-representation analysis on each cluster’s marker list.",
      "Enriched terms reflect pathways/processes relatively active in that cluster.",
      sep = "\n"
    )
  ) |>
  add_row(
    Item    = "Databases",
    Details = "Choose relevant libraries (e.g., cell-type signatures, GO, KEGG, Reactome, custom sets)."
  ) |>
  add_row(
    Item    = "Outputs",
    Details = paste(
      "Per cluster: ranked terms with enrichment score, p-value, adjusted p-value.",
      "Top terms guide cell-type naming and pathway interpretation.",
      sep = "\n"
    )
  ) |>
  add_row(
    Item    = "Notes",
    Details = paste(
      "Use adjusted p-values; prefer specific cell-type libraries for labeling.",
      "Cross-check terms with marker expression and spatial context.",
      sep = "\n"
    )
  )

ezKable(enrichr_tbl)
```
  
</details> 
<br>

```{r query online enrichR version, echo=FALSE, results='asis'}
markersPerClusterTable <- c()

eachCluster <- 0

for (eachCluster in levels(posMarkers$cluster)) {
  markersPerCluster <- dplyr::filter(posMarkers,
                                     cluster == eachCluster) |>
    dplyr::arrange(desc(avg_log2FC))

  markersPerCluster <- head(markersPerCluster,
                            min(nrow(markersPerCluster), 500)
                            )

  markersPerClusterTable <- rbind(markersPerClusterTable,
                                  markersPerCluster)
}

genesPerCluster <- split(markersPerClusterTable$gene,
                         markersPerClusterTable$cluster)

jsCall = paste0('enrich({list: "',
                sapply(genesPerCluster,
                       paste,
                       collapse="\\n"),
                '", popup: true});')

enrichrCalls <- paste0("<a href='javascript:void(0)' onClick='",
                       jsCall,
                       # "'>Analyse at Enrichr website</a>"
                       "'>Open</a>")



```


```{r enrichr markers, echo=FALSE, results='asis'}
enrichrTable <- tibble(Cluster=names(genesPerCluster),
                         # "# of posMarkers"=lengths(genesPerCluster),
                         "N posMarkers"=lengths(genesPerCluster),
                         "Enrichr link"=enrichrCalls)

if (!is.null(enrichRout)){
  enrichRTerm <- as.data.frame(do.call(rbind,
                                       lapply(enrichRout, as.vector)))

  enrichRTerm <- map_df(enrichRTerm, 
                        ~ map_df(.x, 
                                 ~ replace(.x, is.null(.x), NA)), 
                        .id = "database")

  enrichRTerm <- enrichRTerm |>
    group_by(., Cluster, database) |>
    summarise(topTerms = paste(Term, collapse = "; ")) |>
    as.data.frame()

  enrichRTerm <- dcast(enrichRTerm, ... ~ database)

  enrichrTable <- merge(enrichrTable, enrichRTerm, by = "Cluster")
}

## settings needed to make sure links remain links
ezKable(enrichrTable, escape=FALSE, format="html", format.args=list())

```



## Niches {.tabset}

```{r check_banksy}
has_banksy <- "banksy_cluster" %in% colnames(scData@meta.data)
```


### Spatial clustering 

#### Communities of spatially adjacent bins/cells

<details>
  <summary>Niche defining</summary>

```{r}
banksy_niches <- tibble(
  Concept = character(),
  Definition = character(),
  `Key params` = character(),
  `Practical tip` = character()
) |>
  add_row(
    Concept = "Niche (BANKSY cluster)",
    Definition = "Community of spatially adjacent bins/cells with neighborhood-smoothed expression.",
    `Key params` = "k_geom, λ",
    `Practical tip` = "Represents a tissue microenvironment."
  ) |>
  add_row(
    Concept = "k_geom (local neighborhood size)",
    Definition = "How many nearest spatial neighbors define a bin’s/cell's niche.",
    `Key params` = "Integer (e.g., 6–12 for HD bins/cells)",
    `Practical tip` = "↑k = smoother/merge risk; ↓k = sharper/border-preserving."
  ) |>
  add_row(
    Concept = "λ (neighbor influence)",
    Definition = "How strongly neighbors affect each bin’s/cell's expression.",
    `Key params` = "0–1 (start ≈ 0.4)",
    `Practical tip` = "↑λ = denoise/over-smooth risk; ↓λ = crisp/possibly noisy."
  ) |>
  add_row(
    Concept = "Outcome",
    Definition = "Denoised matrix and niches that align with histology.",
    `Key params` = "features = 'variable'",
    `Practical tip` = "Validate on image & markers; adjust k_geom/λ as needed."
  )

ezKable(banksy_niches)
```

</details>

`r if(has_banksy) paste("Lambda:", ifelse(!is.null(param$lambda), param$lambda, 0.8))`

`r if(has_banksy) paste("Resolution:", ifelse(!is.null(param$Niche_resolution), param$nicheResolution, 0.5))`


```{r banksy plot spatial, fig.width=12, fig.height=6, eval=has_banksy}
Idents(scData) <- "banksy_cluster"

n_clusters_banksy <- nlevels(Idents(scData))
show_leg_banksy   <- n_clusters <= 20

p1 <- DimPlot(scData,
              label = FALSE,
              pt.size = 0.5) +
  labs(color = "Clusters") +
  theme_void() +
  guides(color = if (show_leg) guide_legend(title = "Clusters") else "none") +
  ggtitle("UMAP") +
  theme(legend.position = "none")

p1 <- Seurat::LabelClusters(
  plot     = p1,
  id       = "ident",
  fontface = "bold",
  box = T,
  color    = "white",
  size     = 4
)

p_spatialNiches <- SpatialDimPlot(scData, 
                    group.by = "banksy_cluster", 
                    label = T, 
                    plot_segmentations = T,
                    repel = T, 
                    label.size = 4
                    # ,
                    # interactive = T #to check on segmentation 
                    ) +
  
  labs(fill = "Clusters") +
  guides(fill = if (show_leg_banksy) guide_legend(title = "Clusters") else "none")

(p1 + p_spatialNiches) +
  plot_layout(nrow = 1, guides = if (show_leg) "collect" else "keep") 
```

```{r, fig.width=20, fig.height=20, dpi=300}
# banksy_cells <- CellsByIdentities(scData)
# 
# SpatialDimPlot(scData, 
#                cells.highlight = banksy_cells[setdiff(names(banksy_cells), "NA")], 
#                            cols.highlight = c("#FFFF00", 
#                                               "grey50"), 
#                            facet.highlight = T, 
#                            combine = T) + 
#   NoLegend() 

```

<br>

::: {.row}
::: {.col-md-9}

```{r number of cells in each cluster banksy, fig.width=18, fig.height=10, eval=has_banksy}
# if(!('Batch' %in% colnames(scData@meta.data))){
#     scData@meta.data$Batch <- scData@meta.data$Sample
# }

cellIdents_perSample <- scData@meta.data[,c('banksy_cluster', 'Sample')]
#cellIdents_perSample$Batch <- factor(cellIdents_perSample$Batch)



ggplot(cellIdents_perSample, aes(x = banksy_cluster, 
                    fill = Sample)) +
  geom_bar(fill = "#93AECA") +
#  scale_fill_manual(values = pal) +
  labs(title = "Bins/cells per cluster and sample (counts)",
       x = NULL, 
       y = "bins/cells"
  ) + 
  theme_minimal()+
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) + 
  theme(legend.position="top", 
        panel.grid.minor=element_blank(),
        panel.grid.major=element_blank(),
        scale_y_continuous(expand = expansion(mult = c(0.02, 0.15))),
        axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)
  )

```

:::

::: {.col-md-3}
```{r, echo=FALSE, eval=has_banksy}

df <- cellsProportion(scData, groupVar1 = "banksy_cluster", groupVar2 = "Sample") 
df <- df |> as.data.frame(check.names = FALSE, stringsAsFactors = FALSE) |>
  dplyr::rename("Cluster"="banksy_cluster")



is_pct_col <- grepl("_fraction$", colnames(df))
colnames(df) <- colnames(df) |> str_replace_all("_fraction$", " (%)")
is_count_col <- !is_pct_col & colnames(df) != "Cluster"
colnames(df)[is_count_col] <- colnames(df)[is_count_col] |> paste("(n)")

ezInteractiveTableRmd(df, rowNames = FALSE, title="number of bins/cells", filter="none")|>
  DT::formatPercentage(columns = is_pct_col, digits = 2) 


```

:::
:::


### Niches assessment


```{r uninteresting variation banksy, fig.height=16, fig.width=18, eval=has_banksy}
plot1 <- VlnPlot(scData,
                 nCountCol,
                 group.by = "banksy_cluster",
                 pt.size = 0,          
                 raster = T) +
  
  ggtitle("Number of UMIs vs cluster") +
  
  ylab(nCountCol) +
  
  theme_minimal(base_size = 12) +
  
  theme(legend.position = "none",
        axis.title.x = element_blank()) +
  
  scale_y_log10(
    breaks = log_breaks(base = 10),
    labels = label_number()
  )

plot2 <- VlnPlot(scData,
                 nFeatureCol,     
                 group.by = "banksy_cluster",
                 pt.size  = 0,
                 raster   = T) +
  
  ggtitle("Number of genes vs cluster") +
  
  ylab(nFeatureCol) +
  
  theme_minimal(base_size = 12) +
  
  theme(legend.position = "none",
        axis.title.x = element_blank()) +
  
  scale_y_log10(
    breaks = log_breaks(base = 10),
    labels = label_number()
  )


plot3 <- VlnPlot(scData,
                 "percent_mito",     
                 group.by = "banksy_cluster",
                 pt.size = 0,
                 raster = T) +
  ggtitle("Mitochondrial percentage vs cluster") +
  xlab("Cluster") +
  ylab("percent_mito") +
  theme_minimal(base_size = 12) +
  theme(legend.position = "none")

plot1 + plot2 + plot3 + plot_layout(nrow = 3, ncol = 1)

```

### Niches markers

<details>
  <summary>Positive marker detection for BANKSY niches</summary>

```{r wilcoxon test banksy, eval=(param$DE.method=="wilcox"), results='asis', eval=has_banksy}
marker_tbl <- tibble(
  Step = character(),
  Details = character()
) |>
  add_row(
    Step = "Goal",
    Details = paste(
      "Identify genes that are significantly higher in a given BANKSY niche compared to all other bins/cells (\"positive markers\").",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Test",
    Details = paste(
      "Wilcoxon Rank Sum test (niche vs. all other bins/cells).",
      "Non-parametric; robust to non-normal distributions.",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Effect size filter",
    Details = paste(
      "Average log-fold change ≥ 0.25 (log-scale).",
      "Ensures selected markers have a meaningful up-regulation.",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Significance threshold",
    Details = paste(
      "Adjusted p-value < 0.05.",
      "Controls for multiple testing across genes.",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Direction",
    Details = paste(
      "Keep only **up-regulated** genes in the target niche (\"positive\" markers).",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Outputs",
    Details = paste(
      "For each niche: gene list with log2FC, pct.1 (in-niche detection), pct.2 (out-of-niche), p_val_adj, etc.",
      "Significant markers satisfy both effect-size and adjusted p-value criteria.",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Notes",
    Details = paste(
      "Inspect pct.1 vs pct.2 to confirm specificity.",
      "Very small p-values should be displayed in scientific notation; export raw values to avoid rounding to 0 in Excel.",
      sep = "\n"
    )
  )

ezKable(marker_tbl)
```

Marker detection summary

```{r LR test banksy, eval=(param$DE.method=="LR"), results='asis'}

marker_desc <- tibble(
  Item    = c("Test", "Covariate", "Effect size", "Significance", "Definition"),
  Details = c(
    "Logistic regression (niche vs all other bins/cells).",
    "Cell cycle included as a batch effect in the model.",
    "Average log-fold change ≥ 0.25 (log scale).",
    "Adjusted p-value < 0.05.",
    "Genes meeting both thresholds are called significant positive markers."
  )
)

ezKable(marker_desc)
```

 </details>



```{r pos markers banksy, eval=has_banksy && nrow(posMarkersBanksy) > 0}

ezInteractiveTableRmd(posMarkersBanksy, digits=3, rowNames=FALSE)

```


### Marker plots

```{r marker plot setup banksy, eval=has_banksy && nrow(posMarkersBanksy) > 0}
top5 <- posMarkersBanksy %>%
  group_by(cluster) %>%
  slice_max(n = 5, order_by = tibble(diff_pct, avg_log2FC))
genesToPlot <- c(gsub("_", "-", param$controlSeqs), unique(as.character(top5$gene)))
## genesToPlot <- intersect(genesToPlot, rownames(scData))
```


#### DotPlot

Visualization of the top 5 markers in each cluster. If a gene is a top marker for multiple clusters it is shown only once.


```{r dotplot banksy, fig.width  = 20, fig.height = 30, eval=has_banksy && length(genesToPlot) > 0}

DotPlot(scData, features=rev(genesToPlot)) + 
  coord_flip() +
  scale_y_discrete(limits = as.character(sort(as.integer(levels(Idents(scData)))
                                              )
                                         )
                   ) +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
```

### EnrichR
```{r query online enrichR version banksy, echo=FALSE, results='asis', eval=has_banksy && nrow(posMarkersBanksy) > 0}
markersPerClusterTable <- c()

eachCluster <- 0

for (eachCluster in levels(posMarkersBanksy$cluster)) {
  markersPerCluster <- dplyr::filter(posMarkersBanksy,
                                     cluster == eachCluster) |>
    dplyr::arrange(desc(avg_log2FC))

  markersPerCluster <- head(markersPerCluster,
                            min(nrow(markersPerCluster), 500)
                            )

  markersPerClusterTable <- rbind(markersPerClusterTable,
                                  markersPerCluster)
}

genesPerCluster <- split(gsub("\\.m[0-9]+$", "", markersPerClusterTable$gene),
                         markersPerClusterTable$cluster)

jsCall = paste0('enrich({list: "',
                sapply(genesPerCluster,
                       paste,
                       collapse="\\n"),
                '", popup: true});')

enrichrCalls <- paste0("<a href='javascript:void(0)' onClick='",
                       jsCall,
                       # "'>Analyse at Enrichr website</a>"
                       "'>Open</a>")



```


```{r enrichr markers banksy, echo=FALSE, results='asis', eval=has_banksy && nrow(posMarkersBanksy) > 0}
enrichrTable1 <- tibble(Cluster=names(genesPerCluster),
                         # "# of posMarkers"=lengths(genesPerCluster),
                         "N posMarkers"=lengths(genesPerCluster),
                         "Enrichr link"=enrichrCalls)

if (!is.null(enrichRout)){
  enrichRTerm <- as.data.frame(do.call(rbind,
                                       lapply(enrichRout, as.vector)))

  enrichRTerm <- map_df(enrichRTerm, 
                        ~ map_df(.x, 
                                 ~ replace(.x, is.null(.x), NA)), 
                        .id = "database")

  enrichRTerm <- enrichRTerm |>
    group_by(., Cluster, database) |>
    summarise(topTerms = paste(Term, collapse = "; ")) |>
    as.data.frame()

  enrichRTerm <- dcast(enrichRTerm, ... ~ database)

  enrichrTable1 <- merge(enrichrTable1, enrichRTerm, by = "Cluster")
}

## settings needed to make sure links remain links
ezKable(enrichrTable1, escape=FALSE, format="html", format.args=list())

```

## Cell type annotation {.tabset}

```{r check_annotation}
# Check for RCTD annotation columns
has_rctd <- "RCTD_Main" %in% colnames(scData@meta.data)
has_spot_class <- "spot_class" %in% colnames(scData@meta.data)

# Use RCTD_Main or predicted.celltype
if (has_rctd) {
  celltype_col <- "RCTD_Main"
} else if ("predicted.celltype" %in% colnames(scData@meta.data)) {
  celltype_col <- "predicted.celltype"
} else {
  celltype_col <- NULL
}

has_annotation <- !is.null(celltype_col)

# Get RCTD reference information from param
rctd_ref_name <- if (!is.null(param$rctdReference) &&
                     param$rctdReference != "" &&
                     param$rctdReference != "None") {
  param$rctdReference
} else {
  NULL
}

rctd_ref_file <- if (!is.null(param$rctdFile) && param$rctdFile != "") {
  param$rctdFile
} else {
  NULL
}
```

### Reference info

```{r rctd_reference_info, eval=has_annotation && !is.null(rctd_ref_name), results='asis'}
cat("**RCTD Reference:** ", rctd_ref_name, "\n\n", sep = "")
if (!is.null(rctd_ref_file)) {
  cat("**Reference file:** ", rctd_ref_file, "\n\n", sep = "")
}
umi_min_used <- ifelse(!is.null(param$rctdUMImin), param$rctdUMImin, 20)
cat("**UMI_min threshold:** ", umi_min_used,
    " (cells below this were not classified)\n\n", sep = "")
cat("**Number of cell types:** ",
    length(unique(na.omit(scData@meta.data[[celltype_col]]))), "\n\n", sep = "")
```

```{r no_rctd_ref, eval=!has_annotation || is.null(rctd_ref_name)}
cat("RCTD annotation was not performed or reference information not available.")
```

### Cell types

```{r celltype_spatial, fig.width=18, fig.height=10, eval=has_annotation}
# Get unique cell types and create consistent color mapping
celltypes_unique <- sort(unique(na.omit(scData@meta.data[[celltype_col]])))
n_celltypes <- length(celltypes_unique)
cluster_colors <- unname(pals::polychrome())
extended_colors <- c(
  cluster_colors,
  RColorBrewer::brewer.pal(9, "Set1"),
  RColorBrewer::brewer.pal(8, "Set2"),
  RColorBrewer::brewer.pal(12, "Set3")
)
extended_colors <- unique(extended_colors)
if (n_celltypes > length(extended_colors)) {
  extended_colors <- rep(extended_colors, length.out = n_celltypes)
}
celltype_colors <- setNames(extended_colors[1:n_celltypes], celltypes_unique)

# Create truncated labels for legend
truncate_label <- function(x, max_chars = 35) {
  ifelse(nchar(x) > max_chars, paste0(substr(x, 1, max_chars - 3), "..."), x)
}
celltype_labels <- setNames(truncate_label(celltypes_unique), celltypes_unique)

# Replace NA in celltype_col with "Unassigned" for plotting
plot_col <- paste0(celltype_col, "_plot")
plot_vals <- as.character(scData@meta.data[[celltype_col]])
plot_vals[is.na(plot_vals)] <- "Unassigned"
scData@meta.data[[plot_col]] <- factor(plot_vals)
celltype_colors_plot <- c(celltype_colors, "Unassigned" = "grey80")

# Spatial plot (same style as cluster SpatialDimPlot)
p1 <- SpatialDimPlot(scData, group.by = plot_col,
                     images = Images(scData),
                     label = TRUE, repel = TRUE, label.size = 4,
                     plot_segmentations = TRUE, pt.size.factor = 2) +
  scale_fill_manual(values = celltype_colors_plot) +
  ggtitle("Cell types - Spatial") +
  labs(fill = "Cell type") +
  theme(legend.position = "bottom",
        legend.text = element_text(size = 7)) +
  guides(fill = guide_legend(ncol = 4, override.aes = list(size = 3)))

# UMAP with coord_fixed
p2 <- DimPlot(scData, group.by = plot_col, cols = celltype_colors_plot,
              label = TRUE, repel = TRUE, pt.size = 0.5,
              label.size = 3, raster = FALSE) +
  coord_fixed() +
  ggtitle("Cell types - UMAP") +
  theme_void() +
  theme(legend.position = "none")

(p1 + p2) + plot_layout(nrow = 1, widths = c(1.2, 1))
```

```{r no_annotation, eval=!has_annotation}
cat("Cell type annotation was not performed.",
    "Select an RCTD reference to enable annotation.")
```

### Cell type proportions

```{r celltype_barplot, fig.width=10, fig.height=8, eval=has_annotation}
celltype_counts <- as.data.frame(table(scData@meta.data[[celltype_col]]))
colnames(celltype_counts) <- c("CellType", "Count")
celltype_counts <- celltype_counts[order(celltype_counts$Count,
                                         decreasing = FALSE), ]
celltype_counts$CellType <- factor(celltype_counts$CellType,
                                   levels = celltype_counts$CellType)

ggplot(celltype_counts, aes(x = CellType, y = Count, fill = CellType)) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values = celltype_colors) +
  coord_flip() +
  theme_minimal(base_size = 12) +
  theme(legend.position = "none",
        axis.title.y = element_blank(),
        axis.text.y = element_text(size = 9)) +
  labs(title = "Cell type proportions", y = "Number of cells") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05)))
```

```{r celltype_table, eval=has_annotation}
celltype_prop <- as.data.frame(table(scData@meta.data[[celltype_col]]))
colnames(celltype_prop) <- c("CellType", "Count")
celltype_prop <- celltype_prop[order(celltype_prop$Count, decreasing = TRUE), ]
celltype_prop$Proportion <- celltype_prop$Count / sum(celltype_prop$Count)

ezInteractiveTableRmd(celltype_prop, rowNames = FALSE,
                      title = "Cell type proportions") |>
  DT::formatPercentage(columns = "Proportion", digits = 2)
```

### Niche x cell type

```{r niche_celltype_heatmap_check}
has_rctd_niche <- "RCTD_Main" %in% colnames(scData@meta.data)
if (has_rctd_niche) {
  celltype_col_niche <- "RCTD_Main"
} else if ("predicted.celltype" %in% colnames(scData@meta.data)) {
  celltype_col_niche <- "predicted.celltype"
} else {
  celltype_col_niche <- NULL
}
has_annotation_niche <- !is.null(celltype_col_niche)
```

```{r niche_celltype_heatmap_prep, eval=has_banksy && has_annotation_niche}
# Calculate proportion of each cell type within each niche
niche_celltype_df <- scData@meta.data |>
  dplyr::filter(!is.na(banksy_cluster),
                !is.na(.data[[celltype_col_niche]])) |>
  dplyr::group_by(banksy_cluster, .data[[celltype_col_niche]]) |>
  dplyr::summarise(count = n(), .groups = "drop") |>
  dplyr::group_by(banksy_cluster) |>
  dplyr::mutate(proportion = count / sum(count)) |>
  dplyr::ungroup()

# Create proportion matrix
prop_matrix_ct <- niche_celltype_df |>
  dplyr::select(banksy_cluster, all_of(celltype_col_niche), proportion) |>
  tidyr::pivot_wider(names_from = all_of(celltype_col_niche),
                     values_from = proportion, values_fill = 0) |>
  tibble::column_to_rownames("banksy_cluster") |>
  as.matrix()

# Sort rows numerically if possible
tryCatch({
  row_order <- order(as.numeric(rownames(prop_matrix_ct)))
  prop_matrix_ct <- prop_matrix_ct[row_order, , drop = FALSE]
}, error = function(e) NULL)

colnames(prop_matrix_ct) <- truncate_label(colnames(prop_matrix_ct),
                                           max_chars = 40)
```

```{r niche_celltype_heatmap_plot, eval=has_banksy && has_annotation_niche, fig.width=12, fig.height=8}
ht <- ComplexHeatmap::Heatmap(
  prop_matrix_ct,
  cluster_rows = FALSE,
  cluster_columns = TRUE,
  col = colorRampPalette(c("white", "#B2182B"))(100),
  column_title = "Cell type composition per niche",
  column_title_gp = gpar(fontsize = 12, fontface = "bold"),
  row_names_gp = gpar(fontsize = 8),
  column_names_gp = gpar(fontsize = 8),
  column_names_rot = 45,
  column_names_max_height = ComplexHeatmap::max_text_width(
    colnames(prop_matrix_ct), gp = grid::gpar(fontsize = 8)
  ),
  rect_gp = gpar(col = "grey80", lwd = 0.5),
  heatmap_legend_param = list(title = "Proportion")
)
ComplexHeatmap::draw(ht, padding = grid::unit(c(2, 2, 15, 2), "mm"))
```

```{r no_niche_celltype_heatmap, eval=!has_banksy || !has_annotation_niche}
cat("Niche x Cell type heatmap not available",
    "(no BANKSY results or no cell type annotation).")
```

### Cell type markers

```{r celltype_markers_compute, eval=has_annotation}
Idents(scData) <- celltype_col
celltype_markers <- FindAllMarkers(scData, only.pos = TRUE,
                                   min.pct = 0.25, logfc.threshold = 0.25,
                                   verbose = FALSE)
if (nrow(celltype_markers) > 0) {
  celltype_markers$diff_pct <- abs(
    celltype_markers$pct.1 - celltype_markers$pct.2
  )
}
has_celltype_markers <- exists("celltype_markers") && nrow(celltype_markers) > 0
# Reset identity to seurat_clusters
Idents(scData) <- "seurat_clusters"
```

```{r celltype_markers_table, eval=has_annotation && has_celltype_markers}
celltype_markers_sorted <- celltype_markers |>
  dplyr::arrange(cluster, desc(avg_log2FC)) |>
  dplyr::select(-diff_pct)

ezInteractiveTableRmd(celltype_markers_sorted,
                      rowNames = FALSE, title = "Cell type marker genes")
```

```{r no_celltype_markers, eval=has_annotation && !has_celltype_markers}
cat("No significant cell type markers found.")
```

### Cell type marker dotplot

```{r celltype_dotplot_setup, eval=has_annotation && has_celltype_markers}
top5_celltype <- celltype_markers |>
  dplyr::group_by(cluster) |>
  dplyr::arrange(desc(diff_pct)) |>
  dplyr::slice_head(n = 5) |>
  dplyr::ungroup()

sorted_clusters <- sort(unique(as.character(top5_celltype$cluster)))
genesToPlot_celltype <- character()
for (ct in sorted_clusters) {
  ct_genes <- top5_celltype$gene[top5_celltype$cluster == ct]
  genesToPlot_celltype <- c(genesToPlot_celltype,
                            setdiff(ct_genes, genesToPlot_celltype))
}
genesToPlot_celltype <- as.character(genesToPlot_celltype)
genesToPlot_celltype <- gsub("_", "-", genesToPlot_celltype)
genesToPlot_celltype <- intersect(genesToPlot_celltype, rownames(scData))
genesToPlot_celltype <- make.unique(genesToPlot_celltype)

has_genes_to_plot <- length(genesToPlot_celltype) > 0
```

```{r celltype_dotplot, fig.width=15, fig.height=20, eval=has_annotation && has_celltype_markers && has_genes_to_plot, results='asis'}
original_types <- as.character(scData@meta.data[[celltype_col]])
cells_with_celltype <- which(!is.na(original_types))

if (length(cells_with_celltype) < ncol(scData)) {
  n_na <- ncol(scData) - length(cells_with_celltype)
  cat("\n\n*Note:* Excluding ", n_na,
      " cells with unassigned cell types from dotplot.\n\n", sep = "")
}

scData_subset <- subset(scData,
                        cells = colnames(scData)[cells_with_celltype])
cleaned_types <- gsub("[/\\\\]", "_", original_types[cells_with_celltype])
cleaned_types <- gsub("\\s+", "_", cleaned_types)
cleaned_types <- make.names(cleaned_types)
scData_subset$celltype_clean <- factor(cleaned_types)
Idents(scData_subset) <- "celltype_clean"

tryCatch({
  p <- DotPlot(scData_subset, features = rev(genesToPlot_celltype),
               group.by = "celltype_clean") +
    coord_flip() +
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +
    labs(x = "Gene", y = "Cell type")
  print(p)
}, error = function(e) {
  tryCatch({
    cat("\n\n*Note:* Using fewer markers due to plotting constraints.\n\n")
    top_genes <- unique(head(genesToPlot_celltype, 20))
    p <- DotPlot(scData_subset, features = rev(top_genes),
                 group.by = "celltype_clean") +
      coord_flip() +
      theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +
      labs(x = "Gene", y = "Cell type")
    print(p)
  }, error = function(e2) {
    cat("Cell type marker dotplot could not be generated:", e2$message, "\n")
  })
})

rm(scData_subset)
```

```{r no_celltype_dotplot, eval=has_annotation && has_celltype_markers && !has_genes_to_plot}
cat("No valid marker genes found for dotplot.")
```

### RCTD classification

<details>
  <summary>RCTD classification definitions</summary>

```{r rctd_class_definitions}
rctd_def_tbl <- tibble::tibble(
  Class = c("singlet", "doublet_certain", "doublet_uncertain",
            "reject", "unassigned"),
  Definition = c(
    "Cell confidently assigned to a single cell type.",
    "Cell identified as containing two distinct cell types with high confidence.",
    "Cell potentially contains two cell types, but assignment confidence is lower.",
    "Cell could not be reliably classified (no good fit, too few transcripts, or no matching reference type).",
    "Cell was excluded by RCTD before analysis due to the UMI_min threshold."
  ),
  Color = c("#2ecc71 (green)", "#e74c3c (red)", "#f39c12 (orange)",
            "#95a5a6 (gray)", "#3498db (blue)")
)
ezKable(rctd_def_tbl)
```

**Note:** High proportions of singlets indicate good data quality and reference match. Doublets may indicate overlapping cells or spots spanning cell boundaries. Rejects warrant investigation - they may represent novel cell types not in the reference, dying cells, or technical artifacts.

</details>

```{r rctd_class_combined, fig.width=16, fig.height=7, eval=has_spot_class}
# Define RCTD class colors
rctd_class_colors <- c("singlet" = "#2ecc71",
                       "doublet_certain" = "#e74c3c",
                       "doublet_uncertain" = "#f39c12",
                       "reject" = "#95a5a6",
                       "unassigned" = "#3498db")

# Replace NA in spot_class with "unassigned" to avoid nn2 crash with label=TRUE
spot_class_vals <- as.character(scData@meta.data[["spot_class"]])
spot_class_vals[is.na(spot_class_vals)] <- "unassigned"
scData@meta.data[["spot_class_plot"]] <- factor(spot_class_vals)

# Spatial plot (same style as cluster SpatialDimPlot)
p1 <- SpatialDimPlot(scData, group.by = "spot_class_plot",
                     images = Images(scData),
                     label = TRUE, repel = TRUE, label.size = 4,
                     plot_segmentations = TRUE, pt.size.factor = 2,
                     cols = rctd_class_colors) +
  ggtitle("RCTD classification - Spatial") +
  labs(fill = "RCTD class")

# Barplot
class_vector <- as.character(scData$spot_class)
class_vector[is.na(class_vector)] <- "unassigned"
class_counts <- as.data.frame(table(class_vector, useNA = "no"))
colnames(class_counts) <- c("Class", "Count")
class_counts <- class_counts[order(class_counts$Count, decreasing = TRUE), ]
class_counts$Class <- factor(class_counts$Class, levels = class_counts$Class)
class_counts$Proportion <- class_counts$Count / sum(class_counts$Count)

p2 <- ggplot(class_counts, aes(x = Class, y = Count, fill = Class)) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values = rctd_class_colors) +
  geom_text(aes(label = paste0(round(Proportion * 100, 1), "%")),
            vjust = -0.5, size = 4) +
  theme_minimal(base_size = 12) +
  theme(legend.position = "none",
        axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "RCTD classification distribution",
       x = "Classification", y = "Number of cells") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.15)))

(p1 + p2) + plot_layout(widths = c(1.3, 1))
```

```{r rctd_class_table, eval=has_spot_class}
class_vector <- as.character(scData$spot_class)
class_vector[is.na(class_vector)] <- "unassigned"
class_table <- as.data.frame(table(class_vector))
colnames(class_table) <- c("Class", "Count")
class_table$Proportion <- class_table$Count / sum(class_table$Count)
class_table <- class_table[order(class_table$Count, decreasing = TRUE), ]

ezInteractiveTableRmd(class_table, rowNames = FALSE,
                      title = "RCTD classification summary") |>
  DT::formatPercentage(columns = "Proportion", digits = 2)
```

```{r no_rctd_class, eval=!has_spot_class}
cat("RCTD classification (spot_class) not available.",
    "Run RCTD annotation to generate.")
```

### Prediction scores

```{r prediction_scores_violin, fig.width=14, fig.height=10, eval=has_annotation}
weight_cols <- grep("^rctd\\.weight\\.", colnames(scData@meta.data),
                    value = TRUE)

if (length(weight_cols) > 0) {
  weight_matrix <- scData@meta.data[, weight_cols, drop = FALSE]
  max_weights <- apply(weight_matrix, 1, max, na.rm = TRUE)
  max_weights[is.infinite(max_weights)] <- NA
  scData$rctd_max_weight <- max_weights

  valid_weights <- sum(!is.na(scData$rctd_max_weight))

  if (valid_weights > 0) {
    x_labels <- setNames(truncate_label(celltypes_unique), celltypes_unique)

    # Subset to cells with non-NA celltype and weight to avoid VlnPlot crash
    valid_cells <- which(!is.na(scData@meta.data[[celltype_col]]) &
                         !is.na(scData$rctd_max_weight))
    scData_vln <- subset(scData, cells = colnames(scData)[valid_cells])

    p1 <- VlnPlot(scData_vln, features = "rctd_max_weight",
                  group.by = celltype_col, pt.size = 0,
                  cols = celltype_colors) +
      scale_x_discrete(labels = x_labels) +
      stat_summary(fun = median, geom = "crossbar", width = 0.5,
                   color = "white", linewidth = 0.8) +
      ggtitle("RCTD max weight by cell type") +
      ylab("Max prediction weight") +
      theme_minimal(base_size = 12) +
      theme(legend.position = "none",
            axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
            axis.title.x = element_blank())
    print(p1)
    rm(scData_vln)
  } else {
    cat("No valid RCTD prediction weights available for violin plot.")
  }
} else {
  cat("RCTD prediction weights not found in metadata.")
}
```

```{r prediction_scores_spatial, fig.width=14, fig.height=6, eval=has_annotation, results='asis'}
weight_cols_sp <- grep("^rctd\\.weight\\.", colnames(scData@meta.data),
                       value = TRUE)

if (length(weight_cols_sp) > 0 &&
    "rctd_max_weight" %in% colnames(scData@meta.data)) {
  valid_weights_sp <- sum(!is.na(scData$rctd_max_weight))

  if (valid_weights_sp > 0) {
    tryCatch({
      scData$rctd_max_weight_plot <- scData$rctd_max_weight
      scData$rctd_max_weight_plot[is.na(scData$rctd_max_weight_plot)] <- 0

      p1 <- SpatialFeaturePlot(scData,
                               features = "rctd_max_weight_plot") +
        scale_fill_gradientn(colors = viridis::plasma(100),
                             limits = c(0, 1),
                             name = "Max Weight") +
        ggtitle("Prediction confidence - Spatial")

      p2 <- FeaturePlot(scData, features = "rctd_max_weight_plot",
                        reduction = "umap", max.cutoff = "q95",
                        raster = FALSE, order = TRUE) +
        scale_color_gradientn(colors = viridis::plasma(100),
                              limits = c(0, 1),
                              name = "Max Weight") +
        coord_fixed() +
        ggtitle("Prediction confidence - UMAP") +
        theme_void()

      print((p1 + p2) + plot_layout(widths = c(1.2, 1)))

      na_count <- sum(is.na(scData$rctd_max_weight))
      if (na_count > 0) {
        cat("\n\n*Note:* ", na_count,
            " cells without RCTD weights shown as 0 (dark color).\n\n",
            sep = "")
      }
    }, error = function(e) {
      cat("Spatial prediction confidence plot not available:",
          e$message, "\n")
    })
  } else {
    cat("No valid RCTD prediction weights available for spatial plot.")
  }
} else {
  cat("RCTD prediction weights not found in metadata.")
}
```

```{r prediction_scores_summary, eval=has_annotation}
if ("rctd_max_weight" %in% colnames(scData@meta.data)) {
  valid_count <- sum(!is.na(scData$rctd_max_weight))
  if (valid_count > 0) {
    cat("Cells with valid prediction weights:", valid_count,
        "of", ncol(scData), "total cells\n")
    cat("Mean max weight:",
        round(mean(scData$rctd_max_weight, na.rm = TRUE), 3), "\n")
    cat("Median max weight:",
        round(median(scData$rctd_max_weight, na.rm = TRUE), 3), "\n")
  }
}
```

## Links

### Data files

##### Aggregated expression of every gene across the bins/cells in each cluster

[geneExprPerCluster](bulkSignalPerCluster.tsv)

##### Aggregated expression of every gene across all the bins/cells

[geneExprPerSample](bulkSignalPerSample.tsv)

##### Positive markers of each cluster

[posMarkers](cluster_markers.tsv)



##### The final Seurat Object is [here](scData.qs2)

## Parameters

### Parameters used

```{r report parameters, echo=FALSE}

ezListAsKable(param[c("binSize",
        "npcs",
        "clusterResolution",
        "nicheResolution",
        "lambda",
        "DE.method",
        "nUMIs",
        "nmad",
        "rctdReference",
        "rctdUMImin")],
        col.names=c("Parameter", "Value"),
        caption="Parameters used")

  
```

### Session Info

```{r, echo=FALSE}


format(Sys.time(), '%Y-%m-%d %H:%M:%S')
ezSessionInfo()
```

