---
title: "`r paste('Two groups analysis:', param$comparison)`"
author: "Functional Genomics Center Zurich"
output: 
  html_document:
  self_contained: false
lib_dir: rmarkdownLib
includes:
  in_header: fgcz_header.html
css: fgcz.css
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
require(knitr)
knitr::opts_chunk$set(echo = TRUE)
output = readRDS("output.rds")
deResult = readRDS("deResult.rds")
param = readRDS("param.rds")

debug = FALSE

require(ezRun)
library(knitr)
library(kableExtra)
library(SummarizedExperiment)
library(plotly)
library(webshot)
library(htmlwidgets)
require(enrichplot)
require(ggpubr)
library(tidyverse)
library(readxl)
```

```{r prepare data, include=FALSE}
# here, we prepare the data for this report

# report variables
goTermMaxChar = 20
goMaxGenesToPlot = 30

# general
se = deResult$se
param = metadata(se)$param

dataset = data.frame(colData(se), check.names=FALSE, stringsAsFactors=FALSE)
design = ezDesignFromDataset(dataset, param)

resultFiles = makeResultFiles(param, se)

# scatter plots
scatterData = makeTestScatterData(param, se)
logSignal = scatterData$logSignal
groupMeans = scatterData$groupMeans
types = scatterData$types
clusterGene = types$Significants
if (sum(clusterGene) > param$maxGenesForClustering){
  clusterGene[types$Significants] = rank(rowData(se)$pValue[types$Significants], ties.method="max") <= param$maxGenesForClustering
}

# enrichment analyses
enrichInput = compileEnrichmentInput(param, se)

## In some cases, such as p2710, there are millions of features, then we have to adjust some analyses below.
hasMassiveFeats = nrow(enrichInput$seqAnno) >= 200e3
```

Started on `r format(Sys.time(), "%Y-%m-%d %H:%M:%S")`

## TwoGroupsAnalysis_Result {.tabset}

### Settings
```{r settings table, echo=FALSE}
kable(makeCountResultSummary(param, se), row.names=TRUE, 
      col.names="Setting", format="html") %>%
  kable_styling(bootstrap_options = "striped", full_width = F,
                position = "left")
```

### Result summary
```{r features table, echo=FALSE}
settings = character()
settings["Number of features:"] = nrow(se)
if (!is.null(rowData(se)$isPresentProbe)){
  settings["Number of features with counts above threshold:"] = 
    sum(rowData(se)$isPresentProbe)
}
knitr::kable(as.data.frame(settings), format="html", 
             col.names="Number", row.names=TRUE) %>%
  kable_styling(bootstrap_options = "striped", full_width = F,
                position = "left")
```

#### Number of significants by p-value and fold-change
```{r significant genes table, echo=FALSE, message=FALSE}
knitr::kable(makeSignificantCounts(se), row.names=TRUE,  format="html") %>%
  kable_styling(bootstrap_options = "striped", full_width = F, 
                position = "left")
```

Full result table in xlsx format for opening with a spreadsheet program (e.g. Excel).

```{r result live report, echo=FALSE, message=FALSE, eval=TRUE, warning=FALSE, cache=FALSE}
resultFile <- makeResultFile(param, se)

write_tsv(as_tibble(colData(se), rownames="Name") %>% select(Name, sf),
          path="scalingfactors.txt")

liveReportLink = output$getColumn("Live Report")
deResult$saveToFile(basename(output$getColumn("Live Report")))
```

[`r resultFile$resultFile`](`r resultFile$resultFile`)

[Live Report and Visualizations](`r liveReportLink`)

### Inspection of significant genes
#### Between-group comparison
```{r thresholds table, echo=FALSE}
settings = character()
if (!is.null(param$pValueHighlightThresh)){
  settings["P-value threshold:"] = paste("p <=", param$pValueHighlightThresh)
}
if (!is.null(param$log2RatioHighlightThresh)){
  settings["Log ratio threshold:"] = paste("log ratio >=", 
                                           param$log2RatioHighlightThresh)
}
settings["Number of significant genes:"] = sum(types$Significants)
knitr::kable(as.data.frame(settings), format="html", 
             col.names="Number", row.names=TRUE) %>%
  kable_styling(bootstrap_options = "striped", full_width = F,
                position = "left")
```

Subsequent plots highlight significant genes in <span style="color:#A6CEE3FF">blue</span>.

[Interactive table of significant genes](`r resultFiles$resultHtml`)

```{r scatter comparison, echo=FALSE, message=FALSE, fig.width=9, fig.width=7, eval=!debug}
sampleValues = 2^groupMeans[ , param$sampleGroup]
refValues = 2^groupMeans[ , param$refGroup]

ezXYScatter.2(xVec=refValues, yVec=sampleValues,
              isPresent=rowData(se)$usedInTest, 
              types=types, names=rowData(se)$gene_name,
              xlab=param$refGroup, ylab=param$sampleGroup,
              main="Comparison of average expression",
              mode="ggplot2")

if(isFALSE(hasMassiveFeats)){
  p_scatter = ezXYScatter.2(xVec=refValues, yVec=sampleValues,
                            isPresent=rowData(se)$usedInTest, 
                            types=types, names=rowData(se)$gene_name,
                            xlab=param$refGroup, ylab=param$sampleGroup,
                            main="Comparison of average expression",
                            mode="plotly")
  scatterHtml = paste0(param$comparison, "-scatter.html")
  saveWidget(as_widget(p_scatter), scatterHtml)
}
```

```{r volcano p-value, echo=FALSE, message=FALSE, warning=FALSE, fig.width=9, fig.width=7, eval=!debug}
## volcano plot with p-value
ezVolcano(log2Ratio=rowData(se)$log2Ratio,
          pValue=rowData(se)$pValue, yType="p-value",
          isPresent=rowData(se)$usedInTest, types=types,
          names=rowData(se)$gene_name,
          main=param$comparison,
          mode="ggplot2")

if(isFALSE(hasMassiveFeats)){
  p_volcano = ezVolcano(log2Ratio=rowData(se)$log2Ratio, 
                        pValue=rowData(se)$pValue, yType="p-value",
                        isPresent=rowData(se)$usedInTest, types=types,
                        names=rowData(se)$gene_name,
                        main=param$comparison,
                        mode="plotly")
  volcanoHtml = paste0(param$comparison, "-volcano.html")
  saveWidget(as_widget(p_volcano), volcanoHtml)
}
```

### Inspection of significant genes (Advanced plots)

```{r pvalue hist, echo=FALSE, results='asis', eval=!debug}
myBreaks = seq(0, 1, by=0.002)
histUsed = hist(rowData(se)$pValue[rowData(se)$usedInTest], breaks=myBreaks, plot=FALSE)
histAbs = hist(rowData(se)$pValue[!rowData(se)$usedInTest], breaks=myBreaks, plot=FALSE)
xx = rbind(used=histUsed$counts, absent=histAbs$counts)
xx = shrinkToRange(xx, c(0, max(xx["used", ])))
barplot(xx, space=0, border=NA, col=c("blue", "darkorange"), 
        xlab="p-value", ylab="counts", ylim=c(0, max(xx["used", ])),
        main="p-value histogram")
abline(h=sum(rowData(se)$usedInTest)/ncol(xx))
at = c(0.01, 0.1, 0.25, 0.5, 0.75, 1)
axis(1, at=at*ncol(xx), labels = at)
legend("top", c("used", "not expressed"), col=c("blue", "darkorange"), pch=20, cex=1)
```

```{r intra group, echo=FALSE, results='asis', eval=!debug, message=FALSE}
theRange = 2^(range(logSignal, na.rm=TRUE))
x = logSignal
if(ncol(x) <= 100){
  if (!ezIsSpecified(param$grouping2)){ ## TODO: we no longer use pairing, we now use batch which is more general; however these plots only work if batch is a real pairing
    for (group in unique(c(param$refGroup, colnames(groupMeans)))){
      idx = which(group == param$grouping)
      if (length(idx) > 1){
        cat("\n")
        cat(paste("#### Intra-group Comparison:", group), "\n")
        
        pngName = paste0(group, "-scatter.png")
        xlab = paste("Avg of", group)
        refValues = groupMeans[ , group]
        plotCmd = expression({
          ezScatter(x=2^refValues, y=2^x[, idx, drop=FALSE], 
                    isPresent=assays(se)$isPresent[, idx, drop=FALSE], 
                    types=types, lim=theRange, xlab=xlab)
        })
        includeHtml = ezImageFileLink(plotCmd, file=pngName, 
                                       width=min(ncol(as.matrix(x[, idx, drop=FALSE])), 6) * 480,
                                       height=ceiling(ncol(as.matrix(x[, idx, drop=FALSE]))/6) * 480,
                                      addPdfLink = FALSE)
        # dynamic png with possibly many plots
        cat(includeHtml)
        
        if (ncol(groupMeans) == 2){
          otherGroup = setdiff(colnames(groupMeans), group)
          pngName = paste0(group, "-over-", otherGroup, "-scatter.png")
          xlab = paste("Avg of", otherGroup)
          refValues = groupMeans[ , otherGroup]
          plotCmd = expression({
            ezScatter(x=2^refValues, y=2^x[, idx, drop=FALSE], 
                      isPresent=assays(se)$isPresent[, idx, drop=FALSE], 
                      types=types, lim=theRange, xlab=xlab)
          })
          includeHtml = ezImageFileLink(plotCmd, file=pngName,
                                         width=min(ncol(as.matrix(x[, idx, drop=FALSE])), 6) * 480,
                                         height=ceiling(ncol(as.matrix(x[, idx, drop=FALSE]))/6) * 480,
                                        addPdfLink = FALSE)
          # dynamic png with possibly many plots
          cat(includeHtml)
        }
      }
      cat("\n")
    }
  }else{
    cat(paste("Pairs:", param$sampleGroup, "over", param$refGroup), "\n")
    useSample = param$grouping %in% c(param$sampleGroup, param$refGroup)
    if (all(table(param$grouping2[useSample], param$grouping[useSample]) == 1)){
      groups = paste(param$grouping, param$grouping2, sep="--")
      sampleGroups = sort(unique(groups[param$grouping == param$sampleGroup]))
      refGroups = sort(unique(groups[param$grouping == param$refGroup]))
      avgValues = averageColumns(x[ ,useSample], groups[useSample], mean)
      avgPresent= averageColumns(x[ ,useSample], groups[useSample], function(x){mean(x) > 0.5})
      sampleValues = avgValues[ , sampleGroups, drop=FALSE]
      refValues = avgValues[ , refGroups, drop=FALSE]
      samplePresent = avgPresent[ ,sampleGroups, drop=FALSE]
      refPresent = avgPresent[ , refGroups, drop=FALSE]
      pngName = paste0(param$sampleGroup, "-over-", param$refGroup, "-pairs.png")
      plotCmd = expression({
        ezScatter(x=2^refValues, y=2^sampleValues, isPresent=samplePresent | refPresent, types=types, lim=theRange, xlab=colnames(refValues))
      })
      includeHtml = ezImageFileLink(plotCmd, file=pngName,
                                     width=min(ncol(as.matrix(sampleValues)), 6) * 400,
                                     height=ceiling(ncol(as.matrix(sampleValues))/6) * 400,
                                    addPdfLink = FALSE)
      cat(includeHtml)
    }
  }
}
```

### Clustering of significant features
```{r cluster setup, echo=FALSE, eval=!debug}
settings = character()
settings["Significance threshold:"] = param$pValueHighlightThresh
if (param$log2RatioHighlightThresh > 0){
  settings["log2 Ratio threshold:"] = param$log2RatioHighlightThresh
}
settings["Number of significant features:"] = sum(clusterGene)
knitr::kable(as.data.frame(settings), format="html", 
             col.names="Number", row.names=TRUE) %>%
  kable_styling(bootstrap_options = "striped", full_width = F,
                position = "left")
```

#### Cluster plot
```{r javascript, echo=FALSE, results='asis', eval=!debug}
jsFile = system.file("extdata/enrichr.js", package="ezRun", mustWork=TRUE)
invisible(file.copy(from=jsFile, to=basename(jsFile), overwrite=TRUE))
cat(paste0("<SCRIPT language=\"JavaScript\" SRC=\"", basename(jsFile), "\"></SCRIPT>"))
```

```{r cluster, echo=FALSE, message=FALSE, fig.width=max(8,4+0.15*ncol(se)), fig.height=10, fig.retina=2, warning=FALSE, eval=!debug && !hasMassiveFeats}

## for clustering we use a moderated logSignal
logSignal = log2(assays(se)$xNorm + param$backgroundExpression)

if (sum(clusterGene) > param$minGenesForClustering){
  xCentered = logSignal[clusterGene , ]
  if(param$onlyCompGroupsHeatmap){
    columnsToSubset = param$grouping %in% c(param$refGroup, param$sampleGroup)
    param$grouping = param$grouping[columnsToSubset]
    xCentered = xCentered[ , columnsToSubset]
    design = design[columnsToSubset,,drop=FALSE]
  }
  if (!is.null(param$useRefGroupAsBaseline) && param$useRefGroupAsBaseline){
    xCentered = xCentered - rowMeans(xCentered[ , param$grouping == param$refGroup])
    xCentered = sweep(xCentered, MARGIN=1, 
                      rowMeans(xCentered[ , param$grouping == param$refGroup]),
                      FUN="-")
  } else {
    xCentered = sweep(xCentered, MARGIN=1, rowMeans(xCentered), FUN="-")
  }
  xCentered = xCentered[, order(param$grouping)]
  sampleColors = getSampleColors(param$grouping)[order(param$grouping)]
  
  clusterPng = "cluster-heatmap.png"
  clusterPdf = "cluster-heatmap.pdf"
  
  nClusters=6
  clusterColors = hcl.colors(nClusters, palette = "Spectral")
  clusterResult = clusterResults(xCentered, nClusters=nClusters, clusterColors=clusterColors)
  
  design = design[,c(param$groupingName,setdiff(colnames(design),param$groupingName)), drop=FALSE]
  
  plotCmd = expression({
    clusterPheatmap(xCentered, design, param, clusterColors,
                    lim=c(-param$logColorRange, param$logColorRange),
                    doClusterColumns=FALSE, sampleColors=sampleColors)
  })
  eval(plotCmd)

  if (doGo(param, seqAnno)){
    clusterResult = goClusterResults(x = xCentered, param, result = clusterResult, enrichInput)
  }
  ## append the result file with the cluster colors
  resultLoaded <- read_excel(resultFile$resultFile)
  resultLoaded$Cluster <- clusterResult$clusterNumbers[resultLoaded[[1]]]
  write_xlsx(resultLoaded, path=resultFile$resultFile)
  
  if (!is.null(clusterResult$GO)){
    goTables = goClusterTableRmd(param, clusterResult, seqAnno = enrichInput$seqAnno)
    if (doEnrichr(param)){
      goAndEnrichr = cbind(goTables$linkTable, goTables$enrichrTable)
    } else {
      goAndEnrichr = goTables$linkTable
    }
    bgColors = gsub("FF$", "", clusterResult$clusterColors)
    rownames(goAndEnrichr) = paste0('<font color="', bgColors,
                                     '">Cluster ', rownames(goAndEnrichr),
                                     '</font>')
    kable(goAndEnrichr, escape=FALSE, row.names=TRUE, format = "html",
          caption="GO categories of feature clusters") %>%
      kable_styling(bootstrap_options = "striped",
                    full_width = F, position = "float_right") %>%
      footnote(general="Cluster font color corresponds to the row colors in the heatmap plot.")
  }
}
```

```{r render go cluster, echo=FALSE, results='hide', message=FALSE, warning=FALSE, eval=!debug && !hasMassiveFeats}
if (sum(clusterGene) > param$minGenesForClustering && !is.null(clusterResult$GO)){
    ## GO Cluster tables
    file = file.path(system.file("templates", package="ezRun"), 
                      "twoGroups_goClusterTable.Rmd")
    file.copy(from=file, to=basename(file), overwrite=TRUE)
    rmarkdown::render(input=basename(file), envir = new.env(),
                      output_dir=".", output_file="goClusterTable.html",
                      quiet=TRUE)
}
```

```{r go cluster table link, echo=FALSE, results='asis', eval=!debug && !hasMassiveFeats}
if (file.exists("goClusterTable.html")){
  cat(paste0("[GO cluster tables](", "goClusterTable.html", ")"), "\n")
  cat("\n")
}
```

### MetaCore 
```{r metacore annotate, echo=FALSE, message=FALSE}
require(AnnotationHub)
ah <- AnnotationHub()
ref <- param$refBuild %>% strsplit(., "/") %>% .[[1]] %>% .[1] %>% gsub("_"," ",.)
if(!(ref %in% unique(ah$species)) | is.na(ref)){
  knitr::knit_exit()
} else {
  ref.orgdb <- query(ah, c("OrgDb", ref))[[1]]
  orgSymbols <- keys(ref.orgdb, keytype="SYMBOL")
  egr <- select(ref.orgdb, keys=orgSymbols, "ENTREZID", "SYMBOL")
  colnames(egr)[2] <- "entrez_id"
}
```

```{r metacore prepare, echo=FALSE, message=FALSE, eval=!debug}
resultLoaded <- read_excel(resultFile$resultFile)
resultMetaCore <- resultLoaded %>% filter(isPresent, pValue <= param$pValThreshGO) %>%
    dplyr::left_join(egr, by = c("gene_name"="SYMBOL")) %>%
    dplyr::select(gene_name, gene_id, transcript_id,
                  entrez_id, "log2 Ratio", pValue, fdr)
```

```{r metacore export, echo=FALSE, message=FALSE, eval=TRUE}
metacoreFile <- str_c("MetaCore--",param$comparison,".xlsx")
write_xlsx(resultMetaCore, path=metacoreFile)
```

#### Quick Start 
Using MetaCore requires an account. One can be obtained by emailing <sequencing@fgcz.ethz.ch>.

 1. [Click to Download Expression File for MetaCore](`r metacoreFile`)
 
 2. [Go to the MetaCore website](https://portal.genego.com)
 
 3. Upload the Expression File to MetaCore, selecting three columns: Gene ID, p-value, log ratio 
 
 4. Select `Pathway Maps` from the `One-click Analysis` tab. 

***

#### MetaCore 
MetaCore is a powerful pathway and systems analysis tool. It has a curated database of a wide range of molecular pathways and interactions, and provides useful visualisations and statistics based on gene expression fold changes. 

When uploading the data into MetaCore, select three columns:

* A gene identifier, pick **one** of:
  + HGNC gene symbols -- `Gene symbol (with aliases)` from the `Type` drop down menu
  + Ensembl Gene IDs -- `ENSEMBL IDs` 
  + Entrez Gene IDs -- `EntrezGene (LocusLink) IDs`
  
* Log fold changes of the genes -- `log ratio` 

* *P* values, **either**:
  + Raw *p* values if you have fewer DEGs -- `P-value`
  + FDR-corrected *p* values if you have more DEGs -- `P-value`

You must ensure that the data type drop-down menu above each column is correct. 

Select `---ignore---` from the drop down for all other columns in the table that are not to be used.

Please refer to the [FGCZ Wiki](https://fgcz-intranet.uzh.ch/tiki-index.php?page=users.sw.metacore) for a more comprehensive guide to using MetaCore.

MetaCore has numerous comprehensive tutorials online, including a useful YouTube page:
<https://www.youtube.com/watch?v=_J_ViIw9wIM&list=PL2tDZtDsVy5xqUibWp-mfl9xuZP4Bhi-v&index=2>

#### MetaCore Compatibility 
MetaCore currently has full pathway support for three core species: **Human**; **mouse**, and; **rat**. In addition to this, it can use Entrez IDs as orthologs to analyse a series of non-core species:

- Cow
- Chimpanzee
- Dog
- Zebra fish
- Chicken
- Fly
- Mosquito 
- Worm
- Arabidopsis
- Rice
- Blast of rice (fungal species)
- Macaca mulatta
- Mold
- Bread mold
- Candida sphaerica
- Fission yeast
- Baker's yeast


### Enrichr
```{r enrichr, echo=FALSE, message=FALSE, eval=!debug}
if (doGo(param, enrichInput$seqAnno)){
  if (doEnrichr(param)){
    isSig = rowData(se)$pValue < param$pValThreshGO & rowData(se)$usedInTest
    isUp = rowData(se)$log2Ratio > param$log2RatioThreshGO & isSig
    isDown = rowData(se)$log2Ratio < -param$log2RatioThreshGO & isSig
    regulatedGenes = list()
    regulatedGenes$upGenes = na.omit(unique(enrichInput$seqAnno[isUp, "gene_name"]))
    regulatedGenes$downGenes = na.omit(unique(enrichInput$seqAnno[isDown, "gene_name"]))
    regulatedGenes$bothGenes = union(regulatedGenes$upGenes, regulatedGenes$downGenes)
    
    enrichrLinks = ezMatrix("", rows=names(regulatedGenes), cols=c("Number of Genes", "External", "Precomputed"))
    maxResultsPerLibrary = 5
    for (row in rownames(enrichrLinks)){
      genesToUse = regulatedGenes[[row]]
      enrichrLinks[row, "Number of Genes"] = length(genesToUse)
      jsCall = paste0('enrich({list: "', paste(genesToUse, collapse="\\n"), '", popup: true});')
      enrichrLinks[row, "External"] = paste0("<a href='javascript:void(0)' onClick='", jsCall, "'>Analyse at Enrichr website</a>")
      resMerged = NA
      if (!is.null(genesToUse) && length(genesToUse) > 3 && param$doPrecomputeEnrichr) {
        resList = runEnrichr(genesToUse, maxResult = maxResultsPerLibrary)
        resList = lapply(names(resList), 
                         function(nm){return(cbind("Gene-set library"=nm, 
                                                   resList[[nm]][, c(2:5, 7:10)]))}) ## add the name as a first column
        if (length(resList) > 0) {
          resMerged = do.call("rbind", resList)
          resMerged = resMerged[order(-resMerged[,5]), ]
          resMerged[, c(3,6:8)] = apply(resMerged[, c(3,6:8)], 2, sprintf,
                                         fmt = "%0.2e")
          resMerged[, c(4,5)] = apply(resMerged[, c(4,5)], 2, sprintf, 
                                       fmt="%0.3f")
          enrichrTablePath = paste0("enrichrTable_", row, ".html")
          ezInteractiveTable(resMerged, tableLink=enrichrTablePath,
                             title=paste("Enrichr report for ", row))
          enrichrLinks[row, "Precomputed"] = ezLink(link=enrichrTablePath,
                                                    label="Report",
                                                    target="_blank")
        } else {
          enrichrLinks[row, "Precomputed"] = "No significant results"
        }
      } else {
        enrichrLinks[row, "Precomputed"] = "Not run (too few genes)"
      }
    }
    settings = character()
    if (!is.null(param$pValueHighlightThresh)){
      settings["P-value threshold:"] = paste("p <=", param$pValThreshGO)
    }
    if (!is.null(param$log2RatioHighlightThresh)){
      settings["Log ratio threshold:"] = paste("log ratio >=", param$log2RatioThreshGO)
    }
    kable(as.data.frame(settings), format="html", 
          col.names="Number", row.names=TRUE) %>%
      kable_styling(bootstrap_options = "striped", full_width = F,
                    position = "left")
    kable(enrichrLinks, escape=FALSE, row.names=TRUE, format = "html") %>%
      kable_styling(bootstrap_options = "striped",
                    full_width = F, position = "left")
  }
}
if(!doEnrichr(param)){
  cat("\n")
  cat(getOrganism(param$ezRef), "is not supported by Enrichr.")
  cat("\n")
}
```

### GO enrichment analysis (goseq) {.tabset}
Maximum number of terms displayed: `r param$maxNumberGroupsDisplayed`.

```{r goseq enrichment, echo=FALSE, warning=FALSE, message=FALSE}
if (doGo(param, enrichInput$seqAnno)){
  goResult = twoGroupsGOSE(param, enrichInput, se)
  goTables = goUpDownTables(param, goResult)
  resFns <- c() ## Provide download links for these results
}
```

#### Tables
```{r goseq interactive table, echo=FALSE, eval=!debug}
if (exists("goTables")){
  kable(goTables$linkTable, escape=FALSE, row.names=TRUE, format = "html") %>%
    kable_styling(bootstrap_options = "striped",
                  full_width = F, position = "left")
}
```

```{r enrichUp, echo=FALSE, eval=!debug}
## The code in a for loop doesn't work.
## TODO: maybe explicit print or tagList method can work.
if (exists("goTables")){
  ktables <- goTables$ktables
  kable(ktables[["enrichUp"]], escape=FALSE, row.names=FALSE, format="html",
        caption="GO categories that are overrepresented among significantly upregulated genes.") %>%
    kable_styling(bootstrap_options = c("striped", "bordered"),
                  full_width = F, position = "left") %>%
    add_header_above(c("Biological Proc. (BP)" = 4, "Molecular Func. (MF)" = 4, 
                       "Cellular Comp. (CC)" = 4))
}
```

```{r enrichDown, echo=FALSE, eval=!debug}
if (exists("ktables")){
  kable(ktables[["enrichDown"]], escape=FALSE, row.names=FALSE, format="html",
        caption="GO categories that are overrepresented among significantly downregulated genes.") %>%
    kable_styling(bootstrap_options = c("striped", "bordered"),
                  full_width = F, position = "left") %>%
    add_header_above(c("Biological Proc. (BP)" = 4, "Molecular Func. (MF)" = 4, 
                       "Cellular Comp. (CC)" = 4))
}
```

```{r enrichBoth, echo=FALSE, eval=!debug}
if (exists("ktables")){
  kable(ktables[["enrichBoth"]], escape=FALSE, row.names=FALSE, format="html",
        caption="GO categories that are overrepresented among all significantly regulated genes.") %>%
    kable_styling(bootstrap_options = c("striped", "bordered"),
                  full_width = F, position = "left") %>%
    add_header_above(c("Biological Proc. (BP)" = 4, "Molecular Func. (MF)" = 4, 
                       "Cellular Comp. (CC)" = 4))
}
```

#### Plots{.tabset}
##### dotplot

Only plotted results with at least a significant gene set (p-value < `r param$pValThreshFisher`). 

```{r dotplot, echo=FALSE, warning=FALSE, message=FALSE, fig.width=15, fig.height=10}
p = list()

if(exists("goResult")){
  for(onto in names(goResult)){
      for (enrichType in names(goResult[[onto]])){
        if(is.null(goResult[[onto]]) || nrow(goTables$ktablesComplete[[enrichType]][[onto]]) == 0L){
          # No significant gene set
          p[paste0(enrichType,'_',onto)] = list(NULL)
        }else{
          enrichResult = goTables$ktablesComplete[[enrichType]][[onto]]
          enrichResult$Term = substr(enrichResult$Term, start = 1, stop = goTermMaxChar) # don't use the full Terms, some are too large
          enrichResult = prepareEnrichResult(enrichResult)
          p[[paste0(enrichType,'_',onto)]] = dotplot(enrichResult, 
                      showCategory=20, 
                      title=paste(onto,enrichType))
          
          resFn = paste(onto, enrichType, "GSEA.txt", sep="_")
          write.table(goResult[[enrichType]][[onto]], file=resFn,
                      quote=FALSE, col.names = TRUE, row.names = FALSE)
          resFns = append(resFns, resFn)
      }
    }
  }
}

ggarrange(plotlist = p, ncol = 3, nrow = 3)
```


##### enrichMap

Only plotted results with at least a significant gene set (p-value < `r param$pValThreshFisher`). 

```{r enrichMap, echo=FALSE, warning=FALSE, message=FALSE, fig.width=15, fig.height=10}
p = list()

if(exists("goResult")){
  for(onto in names(goResult)){
    for(enrichType in names(goResult[[onto]]) ){
      if(is.null(goResult[[onto]]) || nrow(goTables$ktablesComplete[[enrichType]][[onto]]) == 0L){
          # No significant gene set
          p[paste0(enrichType,'_',onto)] = list(NULL)
      }else{
        enrichResult = goTables$ktablesComplete[[enrichType]][[onto]]
        enrichResult$Term = substr(enrichResult$Term, start = 1, stop = goTermMaxChar) # don't use the full Terms, some are too large
        enrichResult = prepareEnrichResult(enrichResult)
        p[[paste0(enrichType,'_',onto)]] = emapplot(enrichResult, showCategory=50) + ggtitle(paste(onto,enrichType))
        resFn <- paste(onto, sig, "hypergeometric.txt", sep="_")
        write.table(enrichResult[[onto]][[sig]], file=resFn,
                    quote=FALSE, col.names = TRUE, row.names = FALSE, sep = "\t")
        resFns <- append(resFns, resFn)
      }
        
    }
  }
}

ggarrange(plotlist = p, ncol = 3, nrow = 3)
```

##### cnetplot

Only plotted results with at least a significant gene set (p-value < `r param$pValThreshFisher`). In this case, we do not show *cnetplot*s involving more than `r goMaxGenesToPlot` genes to avoid overplotting.

```{r cnetplot, echo=FALSE, warning=FALSE, message=FALSE, fig.width=15, fig.height=10}
p=list()

if(exists("goResult")){
  for(onto in names(goResult)){
      for (enrichType in names(goResult[[onto]])){
        nTerms = nrow(goTables$ktablesComplete[[enrichType]][[onto]])
        nTotalGenes = length(unique(unlist(lapply(goTables$ktablesComplete[[enrichType]][[onto]]$geneNames, strsplit, split='/'))))
        if(is.null(goResult[[onto]]) || nTerms == 0L || nTotalGenes > goMaxGenesToPlot){
          # No significant gene set or more than 'goMaxGenesToPlot' genes
          p[paste0(enrichType,'_',onto)] = list(NULL)
        }else{
          # use gene names
          enrichResult = goTables$ktablesComplete[[enrichType]][[onto]]
          enrichResult$geneID = enrichResult$geneNames
          enrichResult = prepareEnrichResult(enrichResult)
          
          p[[paste0(enrichType,'_',onto)]] = cnetplot(enrichResult,foldChange=setNames(rowData(se)$log2Ratio, rowData(se)$gene_name)) + ggtitle(paste(onto,enrichType)) 
      }
    }
  }
}

ggarrange(plotlist = p, ncol=3, nrow = 3)
```

#### Result files
```{r goseq result files, echo=FALSE, results='asis'}
if (exists("goTables")){
  for(resFn in goTables$txtFiles){
    cat("\n")
    cat(paste0("[", resFn, "](", resFn, ")"))
    cat("\n")
  }
}
```

### Webgestalt
[InputFiles](./Webgestalt) for [Webgestalt](http://www.webgestalt.org/)

```{r webgestalt, include=FALSE}
makeWebgestaltFiles(param, resultFiles$resultFile)
if(param$runGSEA){
  gseaFiles = list.files('Webgestalt', pattern = '^GSEA_Input', full.names = TRUE)
  for (i in 1:length(gseaFiles)){
    res = runWebgestaltGSEA(param, gseaFiles[i])
  }
  ##Keep only interactive html report & zip archive:
  ezSystem('mv Webgestalt/GSEA_Results/*/*.html Webgestalt/GSEA_Results')
  ezSystem('mv Webgestalt/GSEA_Results/*/*.zip Webgestalt/GSEA_Results')
  ezSystem('find Webgestalt/GSEA_Results -maxdepth 1 -mindepth 1 -type d -exec rm -Rf {} \\;')
}

files2Zip <- list.files('Webgestalt', pattern = '^GSEA', full.names = TRUE)
zip("Webgestalt/InputFiles_GSEA.zip", files2Zip, zip="/usr/bin/zip")
unlink(files2Zip)
files2Zip <- list.files('Webgestalt', pattern = '^ORA', full.names = TRUE)
zip("Webgestalt/InputFiles_ORA.zip", files2Zip, zip="/usr/bin/zip")
unlink(files2Zip)
```

### Technical bias
We define 4 gene sets 

* high GC: the 5% of the genes with the highest GC content
* low GC: the 5% of the genes with the lowest GC content
* long genes: the 5% of the genes with the biggest length
* short genes: the 5% of the genes with the smalles length

And we test if the up- or down-regulated genes are associated with one of those gene sets. If there is a significant association, some of the significant genes are potentially false positives 
due to a technical bias.

Tests where the association p-value is below 0.001 are highlighted in red.
The column "overlapping/total genes" shows the number of overlapping genes
and the total number of genes in that category.


```{r bias, echo=FALSE, eval=TRUE}
x = rowData(se)[rowData(se)$usedInTest, ]

if(all(c("gc", "featWidth") %in% colnames(x))) {
  if(!all(is.na(x$gc)) & !all(is.na(x$featWidth))){
    gcThresh = quantile(x$gc, c(0.05, 0.95))
    widthThresh = quantile(x$featWidth, c(0.05, 0.95))
    biasTable = data.frame("low GC"=x$gc < gcThresh[1],
                            "high GC"=x$gc > gcThresh[2],
                            "short genes"= x$featWidth < widthThresh[1],
                            "long genes"=x$featWidth > widthThresh[2],
                            check.names=FALSE)
    isUp = x$pValue < param$pValueHighlightThresh & 
      x$log2Ratio > param$log2RatioHighlightThresh
    isDown = x$pValue < param$pValueHighlightThresh & 
      x$log2Ratio < -param$log2RatioHighlightThresh
    sigTable = data.frame("Up-regulation"=isUp,
                           "Down-regulation"=isDown,
                           check.names=FALSE)
    
    tests = expand.grid(sig=names(sigTable), bias=names(biasTable))
    testTable = ezFrame("overlapping/total genes"=character(), "odds ratio"=numeric(), "p-value"=numeric())
    for (i in 1:nrow(tests)){
      testName = paste(tests$bias[i], " -- ", tests$sig[i])
      myBias = biasTable[[tests$bias[i]]]
      mySig = sigTable[[tests$sig[i]]]
      if(any(mySig)){
        res.fisher = fisher.test(myBias, mySig, alternative="greater")
      } else {
        res.fisher = list(estimate=NA, p.value=NA)
      }
      testTable[testName, "overlapping/total genes"] = paste(sum(myBias & mySig), sum(myBias), sep="/")
      testTable[testName, "odds ratio"] = res.fisher$estimate
      testTable[testName, "p-value"] = res.fisher$p.value
    }
    t = kable(format(testTable, digits=3, scientific=-2), "html", 
               caption=paste("Association test:",
                             sum(isUp), "up-regulated and",
                             sum(isDown), "down-regulated genes")) %>%
      kable_styling(bootstrap_options = "striped", full_width = F, 
                    position = "left")
    isSig = testTable$`p-value` < 1e-3
    if(any(isSig, na.rm = TRUE)){
      t = t %>% 
        row_spec(which(isSig), bold = T, color = "white",
                 background = "#D7261E")
    }
    t
  }
}
```

### Input dataset
```{r input, echo=FALSE}
ezInteractiveTableRmd(values=dataset, digits=4)
```

### SessionInfo
```{r, echo=FALSE}
sessionInfo()
```
