---
title: "`r if (exists('reportTitle')) reportTitle else 'SUSHI Report'`"
output: 
  html_document:
    mathjax: https://fgcz-gstore.uzh.ch/reference/mathjax.js
    self_contained: true
    includes:
      in_header: !expr system.file("templates/fgcz_header.html", package="ezRun")
    css: !expr system.file("templates/fgcz.css", package="ezRun")
editor_options: 
  chunk_output_type: inline
---

# {.tabset}

## QC {.tabset}

```{r setup, include=FALSE}
library(Seurat)
library(ggplot2)
library(patchwork)
library(dplyr)
library(RColorBrewer)
library(kableExtra)
library(ezRun)
library(scater)
library(SingleCellExperiment)
library(enrichR)
library(SCpubr)
library(qs2)

library(DT)
library(ggtext)
library(grid) 
library(htmltools)
library(patchwork)
library(scales)
library(UpSetR)

library(SeuratWrappers)
library(Banksy)

library(sf)
library(Matrix)
library(SpotSweeper)
library(SpatialExperiment)

knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, knitr.table.format = "html")
```


```{r}
posMarkers <- readxl::read_xlsx("posMarkers.xlsx")
param <- qs_read("param.qs2")
lambda <- param$lambda  # BANKSY spatial weighting parameter
input <- qs_read("input.qs2")
output <- qs_read("output.qs2")
#scData <- qs_read("scData.qs2")
scData <- qs_read("scData.unfiltered.qs2")

nCountCol <- grep('^nCount_Spatial.*', 
                  colnames(scData@meta.data), 
                  value=TRUE) %>% head(1)

nFeatureCol <- grep('^nFeature_Spatial.*', 
                    colnames(scData@meta.data), 
                    value=TRUE) %>% head(1)

imageName <- names(scData@images)

#allCellsMeta <- qs_read("allCellsMeta.qs2")
#sampleName <- input$getNames()

if (file.exists("cellsPerGeneFraction.qs2")){
  cellsPerGeneFraction <-  qs_read("cellsPerGeneFraction.qs2")
} else {
  cellsPerGeneFraction <- NULL
}

enrichRout <- NULL
aziResults <- NULL

# Process the posMarkers
posMarkers$gene = as.factor(posMarkers$gene)
# make sure the loaded cluster uses proper integer ordering if all levels are integer!
clusterSet <- posMarkers$cluster %>% as.character() %>% as.integer() %>% unique() %>% sort(na.last=TRUE)
if (any(is.na(clusterSet))){
  posMarkers$cluster = as.factor(posMarkers$cluster)
} else {
  posMarkers$cluster = factor(posMarkers$cluster, levels=clusterSet)
}
posMarkers$p_val_adj[posMarkers$p_val_adj==0] <- min(posMarkers$p_val_adj[posMarkers$p_val_adj>0])
```

```{r seurat to spe}

scData_spe <- Seurat_to_SPE(scData, scData[[names(scData@images)]]@boundaries$centroids@coords)
  
colData(scData_spe) <- colData(scData_spe)[, setdiff(names(colData(scData_spe)), c("x","y")), drop = FALSE
  ]

```


### Diagnostic plots
`r paste("Output:", param$binSize)`

::: {.row}
::: {.col-md-6}

```{r,  echo=F, message=F, warning=F}
  
if (param$binSize %in% c("binned_outputs/square_016um",
                         "binned_outputs/square_008um")) {
  
  centroids <- scData[[names(scData@images)]]@boundaries$centroids
  coords <- setNames(as.data.frame(centroids@coords), c("x", "y"))
  
  scData_spe <- Seurat_to_SPE(scData, as.matrix(coords))
  
  colData(scData_spe) <- colData(scData_spe)[
    , setdiff(names(colData(scData_spe)), c("x","y")), drop = FALSE
  ]
  
  lib_cutoff <- if (identical(param$binSize, "binned_outputs/square_016um")) {
    20
  } else if (identical(param$binSize, "binned_outputs/square_008um")) {
    10
  } 
  
  qc_lib_size <- colData(scData_spe)$nCount_Spatial < lib_cutoff
  table(qc_lib_size)
  
  scData_spe$qc_lib_size     <- qc_lib_size
  scData_spe$global_outliers <- qc_lib_size
  
  plotQCmetrics(
    scData_spe, 
    metric   = "percent_mito", 
    outliers = "global_outliers", 
    point_size = 1.1, 
    stroke     = 0.75
  ) +
    coord_flip() + 
    scale_x_reverse() +
    scale_y_continuous(position = "right") +
    labs(title = "Library size outliers") +
    theme(
    plot.title = element_text(size = 8)   
    )
  
}

```
:::

::: {.col-md-6}
```{r, echo=F, message=F, warning=F}

if (param$binSize %in% c("binned_outputs/square_016um",
                         "binned_outputs/square_008um")) {
  
  meta_spe <- as.data.frame(colData(scData_spe))

  filterStats <- list(
    "Total bins/cells (before QC)"          = length(meta_spe$global_outliers),
    "Total removed (library size outliers)" = sum(meta_spe$global_outliers),
    "Bins/cells remaining"                  = sum(!meta_spe$global_outliers)
  )
  
  ezListAsKable(filterStats, col.names = c("", "Number of bins/cells"))
  
}
 
```


:::
:::

::: {.row}
::: {.col-md-6}

```{r, echo=F, message=F, warning=F}

if (param$binSize %in% c("binned_outputs/square_016um",
                         "binned_outputs/square_008um")) {
  
  meta_spe <- as.data.frame(colData(scData_spe))

  qc_cols <- grepl("^qc", colnames(meta_spe)) | colnames(meta_spe) == "global_outliers"
  qcMat   <- meta_spe[ , qc_cols, drop = FALSE]
  
  qcList <- map(
    qcMat,
    ~ rownames(meta_spe)[which(.x)]
  )
  
  qcList <- qcList[lengths(qcList) > 0]
  
  if (length(qcList) > 1) {
    
    UpSetR::upset(
      fromList(qcList),
      nsets = min(5, length(qcList)),
      mainbar.y.label = "bins/cells"
    )
    
  }
  
}
  
```
:::

::: {.col-md-6}

```{r, echo=F, message=F, warning=F}

if (param$binSize %in% c("binned_outputs/square_016um",
                         "binned_outputs/square_008um")) {
  
  meta <- as.data.frame(colData(scData_spe))


pass <- !meta$global_outliers

qcStats <- ezFrame(
  "Number of bins/cells" = numeric(0), 
  "Min Pass Value"       = numeric(0), 
  "Max Pass Value"       = numeric(0), 
  Fraction               = numeric(0)
)

qcStats["Library Size", ] <- c(
  c(sum(meta$qc_lib_size),
    range(meta$nCount_Spatial[pass])) %>% as.integer(),
  round(sum(meta$qc_lib_size) / nrow(meta), 2)
)

qcStats["Expressed genes", ] <- c(
  c(sum(meta$qc.nexprs),
    range(meta$nFeature_Spatial[pass])) %>% as.integer(),
  round(sum(meta$qc.nexprs) / nrow(meta), 2)
)

qcStats["Mitochondrial Percent", ] <- c(
  c(sum(meta$qc.mito),
    range(meta$percent_mito[pass])) %>% as.integer(),
  round(sum(meta$qc.mito) / nrow(meta), 2)
)

qcStats["Ribosomal protein Percent", ] <- c(
  c(sum(meta$qc.ribo),
    range(meta$percent_riboprot[pass])) %>% as.integer(),
  round(sum(meta$qc.ribo) / nrow(meta), 2)
)

ezKable(qcStats)
  
}

```

:::

::: 
```{r, echo=F, message=F, warning=F}

if (param$binSize %in% c("binned_outputs/square_016um",
                         "binned_outputs/square_008um")) {
  global_outliers <- unname(scData_spe$global_outliers)
  scData$global_outliers <- global_outliers

  scData <- subset(scData, subset = !global_outliers)
  
}

```

```{r}
rgb_order <- function(obj, 
                      img_name = Images(obj)[1],
                      eps = 0.02, 
                      margin = 0.01) {
  
  arr <- as.array(obj@images[[img_name]]@image)

  # Normalize if stored as 8/16-bit (no-op if already 0..1)
  mx <- suppressWarnings(max(arr, na.rm = TRUE)); if (!is.finite(mx) || mx == 0) mx <- 1
  if (mx > 1) arr <- arr / mx

  # if RGBA: composite over white, drop alpha
  if (length(dim(arr)) == 3 && dim(arr)[3] == 4) {
    A <- arr[,,4]; RGB <- arr[,,1:3]
    for (k in 1:3) RGB[,,k] <- RGB[,,k]*A + (1 - A)
    arr <- RGB
  }
  stopifnot(length(dim(arr)) == 3, dim(arr)[3] >= 3)
  arr <- arr[,,1:3, drop = FALSE]

  # mask out near-black background; keep pixels with any channel > eps
  mask <- apply(arr > eps, c(1,2), any)
  if (!any(mask)) mask <- matrix(TRUE, nrow = dim(arr)[1], ncol = dim(arr)[2])

  mR <- mean(arr[,,1][mask], na.rm = TRUE)
  mB <- mean(arr[,,3][mask], na.rm = TRUE)

  if (is.finite(mR) && is.finite(mB) && (mB > mR + margin)) {
    arr <- arr[,,c(3,2,1), drop = FALSE]
    chosen <- "BGR->RGB (swapped)"
  } else {
    chosen <- "RGB (kept as-is)"
  }

  obj@images[[img_name]]@image <- arr
  message(sprintf("Channel order decided by means on tissue: R=%.3f, B=%.3f -> %s",
                  mR, mB, chosen))
  obj
}

img_name <- Images(scData)[1]

scData   <- rgb_order(scData, 
                      img_name, 
                      eps = 0.02, 
                      margin = 0.01)

```



<details>
  <summary>Metrics to identify bins/cells of low quality</summary>
  
```{r QC metrics, echo=F, message=F, warning=F}

qcMetrics <- tibble(
  metric = character(),
  interpretation = character()
) |>
  add_row(
    metric = "Library size – total sum of counts across all relevant features for each bin/cell",
    interpretation = "Small library sizes indicate low quality (RNA may have been lost during library preparation)"
  ) |>
  add_row(
    metric = "Number of expressed genes with non-zero counts in each bin/cell",
    interpretation = "Very few expressed genes means poor capture of the transcript population"
  ) |>
  add_row(
    metric = "Mitochondrial proportion – percentage of reads mapping to mitochondrial genes in each bin/cell",
    interpretation = "High mitochondrial proportion indicate poor quality (loss of cytoplasmic RNA from perforated bins) (Islam et al. 2014; Ilicic et al. 2016)"
  )

ezKable(qcMetrics)


```

Evaluation


```{r diagnostics plots, echo=F, message=F, warning=F}

qcDiagnostics <- tibble(
  check = character(),
  interpretation = character()
) |>
  add_row(
    check = "Independence of QC metrics",
    interpretation = "QC metrics should reflect technical quality, not biological state (e.g., low library size or high mitochondrial proportion should not correspond to specific cell types)."
  ) |>
  add_row(
    check = "Distribution of values",
    interpretation = "Ideally, metrics follow a normal distribution, supporting threshold-based outlier detection."
  ) |>
  add_row(
    check = "Secondary modes",
    interpretation = "A large secondary peak (another mode) suggests correlation with biology, risking loss of distinct cell types."
  ) |>
  add_row(
    check = "Violin plots",
    interpretation = "Show bins/cells kept (`FALSE`) vs discarded (`TRUE`) after QC filtering, highlighting potential biases."
  ) |>
  add_row(
    check = "Spatial plots",
    interpretation = "Visualize QC metrics across the tissue to detect spatial patterns of low quality."
  )

ezKable(qcDiagnostics)

```
</details>


```{r template for spatialFeaturePlot}

sp_plot <- function(obj,
                    feature,
                    title = feature,
                    label = feature,
                    pt.size.factor = 2,
                    min.cutoff = "q01",
                    max.cutoff = "q99",
                    legend.pos = "right",
                    palette = "turbo",
                    title_size = 11,             
                    ...) {

  SpatialFeaturePlot(
    object              = obj,
    features            = feature,
    images              = Images(obj),  
    plot_segmentations  = TRUE,
    pt.size.factor      = pt.size.factor,
    min.cutoff          = min.cutoff,
    max.cutoff          = max.cutoff,
    ...
  ) +
    labs(title = title, fill = label) +
    scale_fill_viridis_c(option = palette, na.value = "grey95") +
    theme_void() +
    theme(
      legend.position   = legend.pos,
      plot.title        = element_text(size = title_size, 
                                       face = "bold", 
                                       margin = margin(b = 6)),
      legend.title      = element_text(size = 8),
      legend.text       = element_text(size = 8),
      legend.key.height = unit(10, "pt"),
      legend.key.width  = unit(6, "pt")
    )
}

```





```{r 1st line of plots, fig.width=12, fig.height=4}

plot1 <- plotColData(
  scData_spe, x = "Sample", 
  y = nCountCol, 
  colour_by = "discard"
) +
  scale_y_log10() +
  #labs(title = "UMI counts", y = "UMI counts per bin/cell") +
  theme(
    legend.position = "top",
    axis.title.x = element_blank(),
    axis.ticks.y = element_blank(),
    axis.ticks.x = element_blank()
  )

plot2 <- sp_plot(
  scData, nCountCol,
  title = "UMI per bin/cell",
  label = "UMI counts"
)

plot3 <- sp_plot(
  scData, nCountCol,
  title  = "Raw image",
  label  = NULL,
#  images = img_name,
  alpha  = c(0, 0)
) + guides(fill = "none")



plot1 + plot2 + plot3

```


```{r 2nd line of plots, fig.width=12, fig.height=4}
plot4 <- plotColData(
  scData_spe,
  x = "Sample",
  y = nFeatureCol,
  colour_by = "discard"
) +
  labs(
    title = "Detected genes"#,
    #y = "Number of detected genes"
  ) +
  theme(
    legend.position = "none", 
    axis.title.x = element_blank(),
    axis.ticks.y = element_blank(),
    axis.ticks.x = element_blank()
  )

plot5 <- sp_plot(
  scData, 
  nFeatureCol,
  title = "",
  label = "Genes"
)

plot6 <- plotColData(
  scData_spe,
  x = nCountCol,
  y = nFeatureCol,
  colour_by = "discard"
) +
  scale_x_log10() +
  scale_y_log10() +
  labs(
    title = ""#,
   # x = "UMI counts",
   #  y = "Detected genes"
  ) +
  theme(
    legend.position = "none", 
    axis.ticks.y = element_blank(),
    axis.ticks.x = element_blank()
  )

plot4 + plot5 + plot6

```


```{r 3th line of plots, fig.width=12, fig.height=4}

plot7 <- plotColData(
  scData_spe,
  x = "Sample",
  y = "percent_mito",
  colour_by = "discard"
) +
  labs(
    title = "Mito percent",
    y = "Percent mitochondrial reads"
  ) +
  theme(
    legend.position = "none", 
    axis.title.x = element_blank(),
    axis.ticks.y = element_blank(),
    axis.ticks.x = element_blank(),
    plot.margin = margin(2, 2, 2, 2) 
    )

scData$percent_mito[is.nan(scData$percent_mito)] <- NA_real_

plot8 <- sp_plot(
  scData,
  "percent_mito",
  title      = "",
  label      = "Mito %",
  min.cutoff = NA,
  max.cutoff = NA
)


plot9 <- plotColData(
  scData_spe,
  x = nCountCol,
  y = "percent_mito",
  colour_by = "discard"
) +
  scale_x_log10() +
  labs(
  #   x = "UMI counts",
    y = "Percent mitochondrial reads"
  ) +
  theme(
    legend.position = "none", 
    axis.ticks.y = element_blank(),
    axis.ticks.x = element_blank(),
    plot.margin = margin(2, 2, 2, 2) 
  )



plot7 + plot8 + plot9

```

```{r 4th line of plots, fig.width=12, fig.height=4}

if (!is.null(scData_spe$percent_riboprot)) {

   plot10 <- plotColData(
      scData_spe,
      x = "Sample",
      y = "percent_riboprot",
      colour_by = "discard"
    ) +
      labs(
        title = "Ribosomal percent",
        y = "Percent ribosomal protein reads"
      ) +
      theme(
        legend.position = "none",
        axis.title.x = element_blank(),
        axis.ticks.y = element_blank(),
        axis.ticks.x = element_blank()
      )


   plot11 <- sp_plot(
     scData, "percent_riboprot",
     title = "",
     label = "Ribo %",
     min.cutoff = NA,
     max.cutoff = NA
   )

    plot12 <- plotColData(
      scData_spe,
      x = nCountCol,
      y = "percent_riboprot",
      colour_by = "discard"
    ) +
      scale_x_log10() +
      labs(
        #x = "UMI counts",
        y = "Percent ribosomal protein reads"
      ) +
      theme(
        legend.position = "none",
        axis.ticks.y = element_blank(),
        axis.ticks.x = element_blank()
      )

}

plot10 + plot11 + plot12

```


<details>
  <summary>Filtering rules</summary>

```{r cell filter, echo=F, message=F, warning=F}

cellFilter <- tibble(
  criterion = character(),
  rule = character()
) |>
  add_row(
    criterion = "Assumption — majority of cells are high-quality",
    rule = "Enables data-driven thresholds using QC metrics without detailed protocol knowledge."
  ) |>
  add_row(
    criterion = "Fixed thresholds (if provided)",
    rule = "If `nreads`, `ngenes`, or `perc_mito` are supplied, use those fixed cutoffs for filtering."
  ) |>
  add_row(
    criterion = "Adaptive: library size (nreads)",
    rule = "Exclude cells with library size < median − 3 × MAD (Median Absolute Deviation)"
  ) |>
  add_row(
    criterion = "Adaptive: detected genes (ngenes)",
    rule = "Exclude cells with detected genes < median − 3 × MAD."
  ) |>
  add_row(
    criterion = "Adaptive: mitochondrial proportion (perc_mito)",
    rule = "Exclude cells with mito % > median + 3 × MAD."
  ) |>
  add_row(
    criterion = "Gene-level prevalence filter",
    rule = "Keep genes present in ≥ N cells (or ≥ p% of cells); drop low-prevalence genes."
  )

ezKable(cellFilter)
```
</details>


#### Dimensionality reduction


<details>
  <summary>Background information</summary>

```{r dim_ tbl, echo=F, message=F, warning=F}
dimred_tbl <- tibble(
  topic = character(),
  summary = character()
) |>
  add_row(
    topic   = "Goal",
    summary = "Reduce the number of dimensions by compressing information from many genes into fewer components."
  ) |>
  add_row(
    topic   = "Why it works",
    summary = "Genes affected by the same biological process are correlated, so separate storage per gene is redundant."
  ) |>
  add_row(
    topic   = "Benefits",
    summary = paste(
    "Computational efficiency — fewer dimensions to process.",
    "Noise reduction — averaging across genes sharpens true patterns.",
    "Visualization — enables clear 2D/3D plotting.",
    sep = "<br>"
  )
  ) |>
  add_row(
    topic   = "Method (example)",
    summary = "Principal Component Analysis (PCA) on normalized/centered data to obtain ranked components."
  ) |>
  add_row(
    topic   = "How many PCs?",
    summary = "Typically retain ~10–50 PCs for downstream analyses (dataset-dependent)."
  ) |>
  add_row(
    topic   = "How to choose PCs",
    summary = paste0(
      "Use a scree/variance-explained plot (a.k.a. Elbow plot). ",
      "Rank PCs by % variance explained; select PCs up to the elbow."
    )
  ) |>
  add_row(
    topic   = "Elbow plot logic",
    summary = paste0(
      "Assumption: PCs carrying biological signal explain markedly more variance than the rest. ",
      "Past the last “biological” PC, the variance drops sharply → the elbow indicates a natural cutoff."
    )
  )

ezKable(dimred_tbl)

```
</details>

```{r pca calc,  echo=F, message=F, warning=F}

orig_assay <- DefaultAssay(scData)

scData <- NormalizeData(scData)

scData <- FindVariableFeatures(scData)

scData <- ScaleData(scData)


ncells <- ncol(scData)

if (ncells < 50000) {
  # (no sketch)
  scData <- RunPCA(scData, npcs = param$npcs)
  scData <- FindNeighbors(scData, dims = 1:param$npcs)
  scData <- FindClusters(scData, resolution = param$clusterResolution)
  scData <- RunUMAP(
    scData,
    reduction     = "pca",
    reduction.name = "umap",
    return.model  = TRUE,
    dims          = 1:param$npcs
  )
  
} else {
  #sketch workflow
  scData <- SketchData(
    object         = scData,
    ncells         = 50000,
    method         = "LeverageScore",
    sketched.assay = "sketch",
    features       = VariableFeatures(scData)
  )
  
  DefaultAssay(scData) <- "sketch"
  
  scData <- FindVariableFeatures(scData)
    
  scData <- ScaleData(scData)
  
  scData <- RunPCA(
        scData,
        assay          = "sketch",
        reduction.name = "pca.sketch",
        npcs           = param$npcs
      )
    
  scData <- FindNeighbors(
        scData,
        assay     = "sketch",
        reduction = "pca.sketch",
        dims      = 1:param$npcs,
        verbose   = FALSE
      ) 
  
  scData <- FindClusters(
        scData,
        resolution = param$clusterResolution,
        verbose    = FALSE
      ) 


  scData$seurat_cluster.sketched <- scData$seurat_clusters
  
  scData <- RunUMAP(
      scData,
      reduction      = "pca.sketch",
      reduction.name = "umap.sketch",
      return.model   = TRUE,
      dims           = 1:param$npcs
    )
  

  DefaultAssay(scData) <- orig_assay
  
  sketch_levels <- sort(unique(scData$seurat_cluster.sketched[!is.na(scData$seurat_cluster.sketched)]))

  scData <- ProjectData(
    object            = scData,
    assay             = orig_assay,
    full.reduction    = "full.pca.sketch",
    sketched.assay    = "sketch",
    sketched.reduction = "pca.sketch",
    umap.model        = "umap.sketch",
    dims              = 1:param$npcs,
    refdata           = list(
      seurat_cluster.projected = "seurat_cluster.sketched"
    )
  )
  
  scData$seurat_cluster.projected <- factor(scData$seurat_cluster.projected, levels(scData$seurat_cluster.sketched))
    
    # switch to full dataset
    Idents(scData) <- "seurat_cluster.projected"
    scData$seurat_clusters <- Idents(scData)
    DefaultAssay(scData) <- orig_assay
  
}

if (!("Batch" %in% colnames(scData@meta.data))) {
  scData$Batch <- scData$Sample
}


```


```{r, fig.width=10, echo=F, message=F, warning=F}

pca_name <- if ("pca.sketch" %in% names(scData@reductions)) "pca.sketch" else "pca"

stdev <- scData[[pca_name]]@stdev

n_use <- if (exists("param") && !is.null(param$npcs)) param$npcs else min(30, length(stdev))
stopifnot(n_use >= 1, n_use <= length(stdev))

var_pct <- (stdev^2) / sum(stdev^2) * 100
cum_pct <- cumsum(var_pct)

df <- data.frame(
  PC   = seq_along(stdev),
  perc = var_pct,
  cum  = cum_pct,
  used = seq_along(stdev) <= n_use
)

ggplot(df, 
       aes(x = PC)) +
  
  geom_col(aes(y = perc, 
               fill = used), 
           width = 0.7, 
           show.legend = FALSE) +
  
  scale_fill_manual(values = c(`TRUE` = "grey20", 
                               `FALSE` = "grey75")) +
  
  geom_line(aes(y = cum / max(cum) * max(perc), 
                group = 1), 
            linewidth = 0.5, 
            color = "orange") +
  
  geom_point(aes(y = cum / max(cum) * max(perc)), 
             size = 1, color = "orange") +

  geom_vline(xintercept = n_use, 
             linetype = "dashed", 
             color = "grey40") +
 
  scale_y_continuous(
    name = "Variance explained (%)",
    sec.axis = sec_axis(~ . / max(df$perc) * 100, 
                        name = "Cumulative variance (%)")
  ) +
  
  labs(
    title    = "PCA variance explained",
    subtitle = paste0("PCs used: ", 
                      n_use, 
                      "   |   Cumulative: ", 
                      sprintf('%.2f%%', 
                              df$cum[n_use])),
    x = NULL) +
  
  theme_minimal(base_size = 9) +
  
  theme(
    text               = element_text(face = "bold"),
    axis.title.y.left  = element_text(color = "grey20"),
    axis.title.y.right = element_text(color = "orange"),
    plot.title         = element_text(hjust = 0.5),
    panel.grid.minor   = element_blank()
  )

```



### Segmentation mask

`r {
  if (identical(param$binSize, "segmented_outputs")) {
    n <- nrow(scData@images[[Images(scData)]]@boundaries$segmentation@sf.data)
    paste("N cells:", n)
  } else ""
}`

```{r, fig.height=20, fig.width=25}

sp_plot(
  scData,
  nCountCol,
  label = "UMI counts",
  stroke = 0.2,
  title_size = 16
)

```


### Cropped mask


```{r, fig.width=25, fig.height=20}

sp_plot(
  scData,
  nCountCol,
  pt.size.factor = 5,
  label = "UMI counts",
  stroke = 0.2,
  crop = TRUE,
  title_size = 16
) +
  coord_sf(xlim = c(200, 350), 
           ylim = c(200, 350), expand = T)

```

### Cell size/density

<details>
  <summary>Segmentation QC</summary>
  
```{r}

if (identical(param$binSize, "segmented_outputs")) {

    qc_text_tbl <- tibble(
    topic = c(
      "Cell size distributions (per image)",
      "Image area covered by cells"
    ),
    summary = c(
      paste(
        "Compare the distributions of cell size across individual images.",
        "Differences can indicate segmentation bias (e.g., density-dependent over/under-segmentation)",
        "or genuine biology driven by cell-type composition",
        "(e.g., tumor cells often larger than immune cells).",
        sep = " "
      ),
      paste(
        "Coverage = total cell area ÷ image area (per ROI).",
        "Low coverage flags ROIs with few cells, possibly due to incorrect ROI selection",
        "or non-tissue/artifact regions; review recommended.",
        sep = " "
      )
    )
  )

  ezKable(qc_text_tbl, 
          caption = "QC notes for image-level metrics", 
          escape = FALSE)

}

```
  </details>
  
`r {
  if (identical(param$binSize, "segmented_outputs")) {
    d <- dim(scData@images[[Images(scData)[1]]]@image)
    paste("Image dimension:", paste(d, collapse = " × "))
  } else "This tab is only for *segmented outputs* and isn’t applicable to bin-based results"
}`




##### Cell size

::: {.row}
::: {.col-md-6}

```{r cell area plot}

if (identical(param$binSize, "segmented_outputs")) {

  sfPolys <- scData@images[[Images(scData)]]@boundaries$segmentation@sf.data
  areasFR  <- st_area(sfPolys)   # FULL-RES px²
  
  lo <- scData@images[[Images(scData)]]@scale.factors$hires
  
  areasLO <- areasFR * (lo^2)
  
  barcodes  <- sfPolys$barcodes

  scData <- AddMetaData(scData, 
                        metadata = setNames(areasLO, barcodes),
                        col.name = "areaPX2hires")

  scSub <- subset(scData, cells = barcodes)
  Idents(scSub) <- factor(rep(Images(scData), ncol(scSub)))


  VlnPlot(scSub, 
          features = "areaPX2hires", 
          pt.size = 0,
          cols = "#93AECA") +
  
    labs(y = expression("cell area, " * px^2),  # "Area, px²"
        subtitle = "HIRES pixel space")  +  
  
    theme_minimal(base_size = 12) +
  
    theme(legend.position = "top",
          legend.justification = "left",
          axis.title.x = element_blank(),
          axis.text.x = element_blank(),
          plot.title = element_blank()
          )
  
} 

```

<br>
<br>

```{r cell area stats}
if (identical(param$binSize, "segmented_outputs")) {
  vals <- scSub$areaPX2hires

  qs  <- quantile(vals, 
                  probs = c(0, .25, .5, .75, 1), 
                  names = FALSE, 
                  na.rm = TRUE)

  mn  <- mean(vals, na.rm = TRUE)

  N   <- length(vals)

  qcArea <- ezFrame(
    "N cells" = integer(0),
    "Min"     = numeric(0),
    "1st Qu." = numeric(0),
    "Median"  = numeric(0),
    "Mean"    = numeric(0),
    "3rd Qu." = numeric(0),
    "Max"     = numeric(0)
  )

  qcArea[ Images(scData), ] <- c(N, 
                           qs[1], 
                           qs[2], 
                           qs[3], 
                           mn, 
                           qs[4], 
                           qs[5]) |> round(0)

  ezKable(qcArea)
}
```
:::
::: {.col-md-6}

##### Cell density


```{r}

if (identical(param$binSize, "segmented_outputs")) {
 
  sfp <- scData@images[[Images(scData)]]@boundaries$segmentation@sf.data
  lo  <- scData@images[[Images(scData)]]@scale.factors$lowres

  W <- dim(scData@images[[Images(scData)]]@image)[2]/lo
  H <- dim(scData@images[[Images(scData)]]@image)[1]/lo
  covered <- sum(st_area(sfp)) / (W * H)

  ggplot(data.frame(sample=Images(scData), 
                    covered=covered),
         aes(sample, 
             covered)) +
  
    geom_point(size = 3) + 
  
    theme_minimal(base_size = 12) +
  
    ylim(0,1) +
  
    labs(y="% covered area", 
         x = "")
  
} 

```
:::
:::


## Clusters  {.tabset}

### Clustering

<details>
  <summary>KNN → communities → clusters</summary>

```{r, echo=F}
npcs_txt <- sprintf("%s PCs", param$npcs)

cluster_tbl <- tibble(
  Step = character(),
  Details = character()
) |>
  add_row(
    Step = "Build KNN graph",
    Details = paste(
      "Each node = bin/cell.",
      sprintf("Connect each bin/cell to its k nearest neighbors in %s space.", npcs_txt),
      "Distance usually Euclidean (on PCs) or cosine.",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Edge weighting",
    Details = paste(
      "Edges weighted by similarity (e.g., shared nearest neighbors/Jaccard).",
      "Higher weight = more similar bins/cells.",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Community detection",
    Details = paste(
      "Apply a community detection algorithm (e.g., Leiden/Louvain) on the KNN graph.",
      "Find groups more connected internally than externally.",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Cluster labels",
    Details = paste(
      "Each community becomes a cluster ID per bin/cell.",
      "Used for downstream interpretation (markers, enrichment, etc.).",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Visualization",
    Details = paste(
      "Plot clusters on UMAP and in image space to assess structure.",
      "Do not run statistical analyses directly on UMAP coordinates;",
      "use them for QC/visual inspection (e.g., neighboring subclusters, potential splits).",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Best practices & caveats",
    Details = paste(
      sprintf("Tune parameters: k (neighbors), resolution (Leiden/Louvain), and %s.", npcs_txt),
      "Check stability (seeds/subsampling) and biological plausibility.",
      "Beware tiny clusters (may be noise) and batch/spatial artifacts.",
      sep = "\n"
    )
  )

ezKable(cluster_tbl)

```
</details>
`r paste("Resolution:", param$clusterResolution)`

<br>


```{r, fig.height=6, fig.width=12}

n_clusters <- nlevels(Idents(scData))
show_leg   <- n_clusters <= 20

namedPalette <- setNames(
  DiscretePalette(length(levels(Idents(scData))
                         ), 
                  palette = "polychrome"), 
  levels(Idents(scData))
)

p1 <- DimPlot(scData,
              label = FALSE,
              pt.size = 0.5) +
  labs(color = "Clusters") +
  theme_void() +
  guides(color = if (show_leg) guide_legend(title = "Clusters") else "none") +
  ggtitle("UMAP") +
  theme(legend.position = "none")

p1 <- Seurat::LabelClusters(
  plot     = p1, 
  repel = T,
  box = T,
  id       = "ident",
  fontface = "bold",
  color    = "white",
  size     = 4
)


p2 <- SpatialDimPlot(
  scData,
  images = Images(scData),
  label              = T,
  label.size         = 4,
  repel              = T,        
  plot_segmentations = T,
  pt.size.factor     = 2
) +
  labs(fill = "Clusters") +
  guides(fill = if (show_leg) guide_legend(title = "Clusters") else "none")


(p1 + p2) +
  plot_layout(nrow = 1,
              guides = if (show_leg) "collect" else "keep")



```

<br>

::: {.row}
::: {.col-md-9}
```{r number of cells in each cluster, fig.width=12, fig.height=6}
# if(!('Batch' %in% colnames(scData@meta.data))){
#     scData@meta.data$Batch <- scData@meta.data$Sample
# }

cellIdents_perSample <- scData@meta.data[,c('seurat_clusters', 'Sample')]
#cellIdents_perSample$Batch <- factor(cellIdents_perSample$Sample)


# if (!exists("pal")) pal <- scales::hue_pal()(nlevels(plot_df$Batch))
# if (is.null(names(pal)) || !all(levels(plot_df$Batch) %in% names(pal))) {
#   pal <- setNames(pal, levels(plot_df$Batch))
# }
# 
# 
# lvls <- levels(factor(plot_df$Batch))  # or cellIdents_perSample$Batch
# pal  <- setNames(viridisLite::viridis(length(lvls), option = "D"), lvls)
# # pals::glasbey, pals::alphabet, RColorBrewer::brewer.pal

ggplot(cellIdents_perSample, aes(x = seurat_clusters, 
                    fill = Sample)) +
  geom_bar(fill = "#93AECA") +
#  scale_fill_manual(values = pal) +
  labs(title = "Bins/cells per cluster and sample (counts)",
       x = NULL, 
       y = "bins/cells"
  ) + 
  theme_minimal()+
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) + ## make sure the y axis is not expanded at the bottom
  theme(legend.position="top", 
        legend.justification = "left",
        panel.grid.minor=element_blank(),
        panel.grid.major=element_blank(),
        scale_y_continuous(expand = expansion(mult = c(0.02, 0.15))),
        axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)
  )

```
:::

::: {.col-md-3}
```{r, echo=FALSE}

df <- cellsProportion(scData, groupVar1 = "seurat_clusters", groupVar2 = "Sample") 
df <- df |> as.data.frame(check.names = FALSE, stringsAsFactors = FALSE) |>
  dplyr::rename("Cluster"="seurat_clusters")



is_pct_col <- grepl("_fraction$", colnames(df))
colnames(df) <- colnames(df) |> str_replace_all("_fraction$", " (%)")
is_count_col <- !is_pct_col & colnames(df) != "Cluster"
colnames(df)[is_count_col] <- colnames(df)[is_count_col] |> paste("(n)")

ezInteractiveTableRmd(df, rowNames = FALSE, title="number of bins/cells", filter="none")|>
  DT::formatPercentage(columns = is_pct_col, digits = 2) 


```
:::
:::

<br/>


### Cluster assessment

<details>
  <summary>Technical vs. biological clustering driver</summary>

```{r, echo=FALSE}

driver_qc_tbl <- tibble(
  Item    = character(),
  Details = character()
) |>
  add_row(
    Item    = "Purpose",
    Details = "Check whether clusters are driven by technical artifacts or uninteresting biology (cell cycle, mitochondrial/ribosomal content, library size)."
  ) |>
  add_row(
    Item    = "Potential confounders",
    Details = paste(
      "Cell cycle phase composition (G1/S/G2M).",
      "Mitochondrial % and ribosomal %.",
      "Library size (UMIs) and genes detected.",
      sep = "\n"
    )
  ) |>
  add_row(
    Item    = "Diagnostics",
    Details = paste(
      "Per-cluster phase distribution (bar charts) — look for clusters dominated by a single phase.",
      "Box/violin plots per cluster for UMIs, genes, mito%, ribo%.",
      "Statistical checks (e.g., Kruskal-Wallis/ANOVA across clusters).",
      sep = "\n"
    )
  ) |>
  add_row(
    Item    = "Mitigations",
    Details = paste(
      "Regress out cell cycle / mito% / ribo% in scaling/normalization (e.g., Seurat ScaleData/SCTransform vars.to.regress).",
      "Adjust clustering parameters (PCs, k, resolution) after normalization.",
      sep = "\n"
    )
  ) |>
  add_row(
    Item    = "Decision rule",
    Details = paste(
      "If a cluster is mainly explained by confounders, flag it and re-evaluate after regression/normalization.",
      "If differences are modest and later cell-type labels explain them, proceed with interpretation.",
      sep = "\n"
    )
  )

ezKable(driver_qc_tbl)
```

</details> 



```{r uninteresting variation, fig.height=16, fig.width=12}

plot1 <- VlnPlot(scData,
                 nCountCol,
                 group.by = "seurat_clusters",
                 pt.size = 0,          
                 raster = T) +
  
  ggtitle("Number of UMIs vs cluster") +
  
  ylab(nCountCol) +
  
  theme_minimal(base_size = 12) +
  
  theme(legend.position = "none",
        axis.title.x = element_blank()) +
  
  scale_y_log10(
    breaks = log_breaks(base = 10),
    labels = label_number()
  )

plot2 <- VlnPlot(scData,
                 nFeatureCol,     
                 group.by = "seurat_clusters",
                 pt.size  = 0,
                 raster   = T) +
  
  ggtitle("Number of genes vs cluster") +
  
  ylab(nFeatureCol) +
  
  theme_minimal(base_size = 12) +
  
  theme(legend.position = "none",
        axis.title.x = element_blank()) +
  
  scale_y_log10(
    breaks = log_breaks(base = 10),
    labels = label_number()
  )


plot3 <- VlnPlot(scData,
                 "percent_mito",     
                 group.by = "seurat_clusters",
                 pt.size = 0,
                 raster = T) +
  ggtitle("Mitochondrial percentage vs cluster") +
  xlab("Cluster") +
  ylab("percent_mito") +
  theme_minimal(base_size = 12) +
  theme(legend.position = "none")

plot1 + plot2 + plot3 + plot_layout(nrow = 3, ncol = 1)

```


### Cluster markers

<details>
  <summary>Positive marker detection</summary>

```{r wilcoxon test, eval=(param$DE.method=="wilcox"), results='asis'}
marker_tbl <- tibble(
  Step = character(),
  Details = character()
) |>
  add_row(
    Step = "Goal",
    Details = paste(
      "Identify genes that are significantly higher in a given cluster compared to all other bins/cells (\"positive markers\").",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Test",
    Details = paste(
      "Wilcoxon Rank Sum test (cluster vs. all other bins/cells).",
      "Non-parametric; robust to non-normal distributions.",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Effect size filter",
    Details = paste(
      "Average log-fold change ≥ 0.25 (log-scale).",
      "Ensures selected markers have a meaningful up-regulation.",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Significance threshold",
    Details = paste(
      "Adjusted p-value < 0.05.",
      "Controls for multiple testing across genes.",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Direction",
    Details = paste(
      "Keep only **up-regulated** genes in the target cluster (\"positive\" markers).",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Outputs",
    Details = paste(
      "For each cluster: gene list with log2FC, pct.1 (in-cluster detection), pct.2 (out-of-cluster), p_val_adj, etc.",
      "Significant markers satisfy both effect-size and adjusted p-value criteria.",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Notes",
    Details = paste(
      "Inspect pct.1 vs pct.2 to confirm specificity.",
      "Very small p-values should be displayed in scientific notation; export raw values to avoid rounding to 0 in Excel.",
      sep = "\n"
    )
  )

ezKable(marker_tbl)
```

Marker detection summary

```{r LR test, eval=(param$DE.method=="LR"), results='asis'}

marker_desc <- tibble(
  Item    = c("Test", "Covariate", "Effect size", "Significance", "Definition"),
  Details = c(
    "Logistic regression (cluster vs all other bins/cells).",
    "Cell cycle included as a batch effect in the model.",
    "Average log-fold change ≥ 0.25 (log scale).",
    "Adjusted p-value < 0.05.",
    "Genes meeting both thresholds are called significant positive markers."
  )
)

ezKable(marker_desc)
```
  
 </details>



```{r pos markers}
ezInteractiveTableRmd(posMarkers, digits=3, rowNames=FALSE)
```
 

### Marker plots

```{r marker plot setup}
top5 <- posMarkers  |> 
  group_by(cluster) |> 
  slice_max(n = 5, order_by = tibble(diff_pct, avg_log2FC))

genesToPlot <- c(gsub("_", "-", param$controlSeqs), unique(as.character(top5$gene)))

genesToPlot <- intersect(genesToPlot, rownames(scData))
```


#### DotPlot

Visualization of the top 5 markers in each cluster. If a gene is a top marker for multiple clusters it is shown only once.


```{r dotplot, fig.width  = 15, fig.height = 30}

DotPlot(scData, features=rev(genesToPlot)) + 
  coord_flip() +
  scale_y_discrete(limits = as.character(sort(as.integer(levels(Idents(scData)))))
                   ) +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))

```


```{r plot of user genes, fig.width=12, fig.height=shrinkToRange(length(param$controlSeqs)/5, c(6, 12)), eval=ezIsSpecified(param$controlSeqs)}
genesToPlot <- intersect(param$controlSeqs, rownames(scData))

if (length(genesToPlot) > 0){
  DoHeatmap(scData, features=unique(genesToPlot))
  DotPlot(scData, features=genesToPlot) + coord_flip() +
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
} else { 
  cat("controlseqs not found")
}
```



### EnrichR

<details>
  <summary>Cell type scoring (Enrichr)</summary>
  
```{r, echo=FALSE}

enrichr_tbl <- tibble(
  Item    = character(),
  Details = character()
) |>
  add_row(
    Item    = "Goal",
    Details = "Score clusters by cell-type/pathway activity via gene set enrichment of their positive markers."
  ) |>
  add_row(
    Item    = "Input",
    Details = "Per-cluster marker genes (upregulated vs. other clusters)."
  ) |>
  add_row(
    Item    = "Method",
    Details = paste(
      "Use Enrichr to perform over-representation analysis on each cluster’s marker list.",
      "Enriched terms reflect pathways/processes relatively active in that cluster.",
      sep = "\n"
    )
  ) |>
  add_row(
    Item    = "Databases",
    Details = "Choose relevant libraries (e.g., cell-type signatures, GO, KEGG, Reactome, custom sets)."
  ) |>
  add_row(
    Item    = "Outputs",
    Details = paste(
      "Per cluster: ranked terms with enrichment score, p-value, adjusted p-value.",
      "Top terms guide cell-type naming and pathway interpretation.",
      sep = "\n"
    )
  ) |>
  add_row(
    Item    = "Notes",
    Details = paste(
      "Use adjusted p-values; prefer specific cell-type libraries for labeling.",
      "Cross-check terms with marker expression and spatial context.",
      sep = "\n"
    )
  )

ezKable(enrichr_tbl)
```
  
</details> 
<br>

```{r query online enrichR version, echo=FALSE, results='asis'}
markersPerClusterTable <- c()

eachCluster <- 0

for (eachCluster in levels(posMarkers$cluster)) {
  markersPerCluster <- dplyr::filter(posMarkers,
                                     cluster == eachCluster) |>
    dplyr::arrange(desc(avg_log2FC))

  markersPerCluster <- head(markersPerCluster,
                            min(nrow(markersPerCluster), 500)
                            )

  markersPerClusterTable <- rbind(markersPerClusterTable,
                                  markersPerCluster)
}

genesPerCluster <- split(markersPerClusterTable$gene,
                         markersPerClusterTable$cluster)

jsCall = paste0('enrich({list: "',
                sapply(genesPerCluster,
                       paste,
                       collapse="\\n"),
                '", popup: true});')

enrichrCalls <- paste0("<a href='javascript:void(0)' onClick='",
                       jsCall,
                       # "'>Analyse at Enrichr website</a>"
                       "'>Open</a>")



```


```{r enrichr markers, echo=FALSE, results='asis'}
enrichrTable <- tibble(Cluster=names(genesPerCluster),
                         # "# of posMarkers"=lengths(genesPerCluster),
                         "N posMarkers"=lengths(genesPerCluster),
                         "Enrichr link"=enrichrCalls)

if (!is.null(enrichRout)){
  enrichRTerm <- as.data.frame(do.call(rbind,
                                       lapply(enrichRout, as.vector)))

  enrichRTerm <- map_df(enrichRTerm, 
                        ~ map_df(.x, 
                                 ~ replace(.x, is.null(.x), NA)), 
                        .id = "database")

  enrichRTerm <- enrichRTerm |>
    group_by(., Cluster, database) |>
    summarise(topTerms = paste(Term, collapse = "; ")) |>
    as.data.frame()

  enrichRTerm <- dcast(enrichRTerm, ... ~ database)

  enrichrTable <- merge(enrichrTable, enrichRTerm, by = "Cluster")
}

## settings needed to make sure links remain links
ezKable(enrichrTable, escape=FALSE, format="html", format.args=list())

```



## Niches {.tabset}


```{r runBanksy, echo=F, message=F, warning=F}

scData <- RunBanksy(scData,
                    lambda = lambda, 
                    verbose = TRUE,
                    assay = DefaultAssay(scData), 
                    slot = "data",
                    features = "variable",
                    k_geom = 30 #Local neighborhood size. Larger values will yield larger domains
                    )


```

```{r banksy PCA, echo=F, message=F, warning=F}

DefaultAssay(scData) <- "BANKSY"

scData <- RunPCA(scData, 
                 assay = "BANKSY", 
                 reduction.name = "pca.banksy", 
                 features = rownames(scData), 
                 npcs = param$npcs)


```

```{r neighbors, echo=F, message=F, warning=F}

scData <- FindNeighbors(scData, 
                           reduction = "pca.banksy", 
                           dims = 1:12)

```

```{r find clusters, echo=F, message=F, warning=F}
scData <- FindClusters(scData,
                          cluster.name = "banksy_cluster",
                          resolution = param$Niche_resolution,
                          verbose = F)
```

```{r compute banksy markers, echo=F, message=F, warning=F}
# Compute positive markers for BANKSY clusters
Idents(scData) <- "banksy_cluster"
vars.to.regress <- NULL

markers_banksy <- FindAllMarkers(
  object = scData,
  test.use = param$DE.method,
  only.pos = TRUE,
  latent.vars = vars.to.regress,
  min.pct = param$min.pct,
  return.thresh = param$pvalue_allMarkers,
  logfc.threshold = param$logfc.threshold
)

# Process markers (same as classical markers)
posMarkersBanksy <- markers_banksy[, c("gene", "cluster", "pct.1", "pct.2", "avg_log2FC", "p_val_adj")]
posMarkersBanksy$cluster <- as.factor(posMarkersBanksy$cluster)
diff_pct <- abs(posMarkersBanksy$pct.1 - posMarkersBanksy$pct.2)
posMarkersBanksy$diff_pct <- diff_pct
posMarkersBanksy <- posMarkersBanksy[order(posMarkersBanksy$diff_pct, decreasing = TRUE), ] %>%
  mutate_if(is.numeric, round, digits = 30)
posMarkersBanksy <- posMarkersBanksy[posMarkersBanksy$p_val_adj < param$pvalue_allMarkers, ]
rownames(posMarkersBanksy) <- NULL

# Make sure the loaded cluster uses proper integer ordering if all levels are integer!
clusterSet_banksy <- posMarkersBanksy$cluster %>% as.character() %>% as.integer() %>% unique() %>% sort(na.last = TRUE)
if (any(is.na(clusterSet_banksy))) {
  posMarkersBanksy$cluster <- as.factor(posMarkersBanksy$cluster)
} else {
  posMarkersBanksy$cluster <- factor(posMarkersBanksy$cluster, levels = clusterSet_banksy)
}
posMarkersBanksy$p_val_adj[posMarkersBanksy$p_val_adj == 0] <- min(posMarkersBanksy$p_val_adj[posMarkersBanksy$p_val_adj > 0])

# Save to Excel
writexl::write_xlsx(posMarkersBanksy, path = "posMarkersBanksy.xlsx")

# Save to TSV for download
write.table(posMarkersBanksy, file = "cluster_markers_banksy.tsv", sep = "\t",
            row.names = FALSE, quote = FALSE)
```

### Spatial clustering 

#### Communities of spatially adjacent bins/cells

<details>
  <summary>Niche defining</summary>

```{r}
banksy_niches <- tibble(
  Concept = character(),
  Definition = character(),
  `Key params` = character(),
  `Practical tip` = character()
) |>
  add_row(
    Concept = "Niche (BANKSY cluster)",
    Definition = "Community of spatially adjacent bins/cells with neighborhood-smoothed expression.",
    `Key params` = "k_geom, λ",
    `Practical tip` = "Represents a tissue microenvironment."
  ) |>
  add_row(
    Concept = "k_geom (local neighborhood size)",
    Definition = "How many nearest spatial neighbors define a bin’s/cell's niche.",
    `Key params` = "Integer (e.g., 6–12 for HD bins/cells)",
    `Practical tip` = "↑k = smoother/merge risk; ↓k = sharper/border-preserving."
  ) |>
  add_row(
    Concept = "λ (neighbor influence)",
    Definition = "How strongly neighbors affect each bin’s/cell's expression.",
    `Key params` = "0–1 (start ≈ 0.4)",
    `Practical tip` = "↑λ = denoise/over-smooth risk; ↓λ = crisp/possibly noisy."
  ) |>
  add_row(
    Concept = "Outcome",
    Definition = "Denoised matrix and niches that align with histology.",
    `Key params` = "features = 'variable'",
    `Practical tip` = "Validate on image & markers; adjust k_geom/λ as needed."
  )

ezKable(banksy_niches)
```

</details>

`r paste("Resolution:", param$Niche_resolution)`


```{r banksy plot spatial, fig.width=12, fig.height=6}
Idents(scData) <- "banksy_cluster"

n_clusters_banksy <- nlevels(Idents(scData))
show_leg_banksy   <- n_clusters <= 20

p1 <- DimPlot(scData,
              label = FALSE,
              pt.size = 0.5) +
  labs(color = "Clusters") +
  theme_void() +
  guides(color = if (show_leg) guide_legend(title = "Clusters") else "none") +
  ggtitle("UMAP") +
  theme(legend.position = "none")

p1 <- Seurat::LabelClusters(
  plot     = p1,
  id       = "ident",
  fontface = "bold",
  box = T,
  color    = "white",
  size     = 4
)

p_spatialNiches <- SpatialDimPlot(scData, 
                    group.by = "banksy_cluster", 
                    label = T, 
                    plot_segmentations = T,
                    repel = T, 
                    label.size = 4
                    # ,
                    # interactive = T #to check on segmentation 
                    ) +
  
  labs(fill = "Clusters") +
  guides(fill = if (show_leg_banksy) guide_legend(title = "Clusters") else "none")

(p1 + p_spatialNiches) +
  plot_layout(nrow = 1, guides = if (show_leg) "collect" else "keep") 
```

```{r, fig.width=20, fig.height=20, dpi=300}
# banksy_cells <- CellsByIdentities(scData)
# 
# SpatialDimPlot(scData, 
#                cells.highlight = banksy_cells[setdiff(names(banksy_cells), "NA")], 
#                            cols.highlight = c("#FFFF00", 
#                                               "grey50"), 
#                            facet.highlight = T, 
#                            combine = T) + 
#   NoLegend() 

```

<br>

::: {.row}
::: {.col-md-9}

```{r number of cells in each cluster banksy, fig.width=18, fig.height=10}
# if(!('Batch' %in% colnames(scData@meta.data))){
#     scData@meta.data$Batch <- scData@meta.data$Sample
# }

cellIdents_perSample <- scData@meta.data[,c('banksy_cluster', 'Sample')]
#cellIdents_perSample$Batch <- factor(cellIdents_perSample$Batch)



ggplot(cellIdents_perSample, aes(x = banksy_cluster, 
                    fill = Sample)) +
  geom_bar(fill = "#93AECA") +
#  scale_fill_manual(values = pal) +
  labs(title = "Bins/cells per cluster and sample (counts)",
       x = NULL, 
       y = "bins/cells"
  ) + 
  theme_minimal()+
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) + 
  theme(legend.position="top", 
        panel.grid.minor=element_blank(),
        panel.grid.major=element_blank(),
        scale_y_continuous(expand = expansion(mult = c(0.02, 0.15))),
        axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)
  )

```

:::

::: {.col-md-3}
```{r, echo=FALSE}

df <- cellsProportion(scData, groupVar1 = "banksy_cluster", groupVar2 = "Sample") 
df <- df |> as.data.frame(check.names = FALSE, stringsAsFactors = FALSE) |>
  dplyr::rename("Cluster"="banksy_cluster")



is_pct_col <- grepl("_fraction$", colnames(df))
colnames(df) <- colnames(df) |> str_replace_all("_fraction$", " (%)")
is_count_col <- !is_pct_col & colnames(df) != "Cluster"
colnames(df)[is_count_col] <- colnames(df)[is_count_col] |> paste("(n)")

ezInteractiveTableRmd(df, rowNames = FALSE, title="number of bins/cells", filter="none")|>
  DT::formatPercentage(columns = is_pct_col, digits = 2) 


```

:::
:::


### Niches assessment


```{r uninteresting variation banksy, fig.height=16, fig.width=18}
plot1 <- VlnPlot(scData,
                 nCountCol,
                 group.by = "banksy_cluster",
                 pt.size = 0,          
                 raster = T) +
  
  ggtitle("Number of UMIs vs cluster") +
  
  ylab(nCountCol) +
  
  theme_minimal(base_size = 12) +
  
  theme(legend.position = "none",
        axis.title.x = element_blank()) +
  
  scale_y_log10(
    breaks = log_breaks(base = 10),
    labels = label_number()
  )

plot2 <- VlnPlot(scData,
                 nFeatureCol,     
                 group.by = "banksy_cluster",
                 pt.size  = 0,
                 raster   = T) +
  
  ggtitle("Number of genes vs cluster") +
  
  ylab(nFeatureCol) +
  
  theme_minimal(base_size = 12) +
  
  theme(legend.position = "none",
        axis.title.x = element_blank()) +
  
  scale_y_log10(
    breaks = log_breaks(base = 10),
    labels = label_number()
  )


plot3 <- VlnPlot(scData,
                 "percent_mito",     
                 group.by = "banksy_cluster",
                 pt.size = 0,
                 raster = T) +
  ggtitle("Mitochondrial percentage vs cluster") +
  xlab("Cluster") +
  ylab("percent_mito") +
  theme_minimal(base_size = 12) +
  theme(legend.position = "none")

plot1 + plot2 + plot3 + plot_layout(nrow = 3, ncol = 1)

```

### Niches markers

<details>
  <summary>Positive marker detection for BANKSY niches</summary>

```{r wilcoxon test banksy, eval=(param$DE.method=="wilcox"), results='asis'}
marker_tbl <- tibble(
  Step = character(),
  Details = character()
) |>
  add_row(
    Step = "Goal",
    Details = paste(
      "Identify genes that are significantly higher in a given BANKSY niche compared to all other bins/cells (\"positive markers\").",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Test",
    Details = paste(
      "Wilcoxon Rank Sum test (niche vs. all other bins/cells).",
      "Non-parametric; robust to non-normal distributions.",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Effect size filter",
    Details = paste(
      "Average log-fold change ≥ 0.25 (log-scale).",
      "Ensures selected markers have a meaningful up-regulation.",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Significance threshold",
    Details = paste(
      "Adjusted p-value < 0.05.",
      "Controls for multiple testing across genes.",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Direction",
    Details = paste(
      "Keep only **up-regulated** genes in the target niche (\"positive\" markers).",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Outputs",
    Details = paste(
      "For each niche: gene list with log2FC, pct.1 (in-niche detection), pct.2 (out-of-niche), p_val_adj, etc.",
      "Significant markers satisfy both effect-size and adjusted p-value criteria.",
      sep = "\n"
    )
  ) |>
  add_row(
    Step = "Notes",
    Details = paste(
      "Inspect pct.1 vs pct.2 to confirm specificity.",
      "Very small p-values should be displayed in scientific notation; export raw values to avoid rounding to 0 in Excel.",
      sep = "\n"
    )
  )

ezKable(marker_tbl)
```

Marker detection summary

```{r LR test banksy, eval=(param$DE.method=="LR"), results='asis'}

marker_desc <- tibble(
  Item    = c("Test", "Covariate", "Effect size", "Significance", "Definition"),
  Details = c(
    "Logistic regression (niche vs all other bins/cells).",
    "Cell cycle included as a batch effect in the model.",
    "Average log-fold change ≥ 0.25 (log scale).",
    "Adjusted p-value < 0.05.",
    "Genes meeting both thresholds are called significant positive markers."
  )
)

ezKable(marker_desc)
```

 </details>



```{r pos markers banksy}

ezInteractiveTableRmd(posMarkersBanksy, digits=3, rowNames=FALSE)

```


### Marker plots

```{r marker plot setup banksy}
top5 <- posMarkersBanksy %>%
  group_by(cluster) %>%
  slice_max(n = 5, order_by = tibble(diff_pct, avg_log2FC))
genesToPlot <- c(gsub("_", "-", param$controlSeqs), unique(as.character(top5$gene)))
genesToPlot <- intersect(genesToPlot, rownames(scData))
```


#### DotPlot

Visualization of the top 5 markers in each cluster. If a gene is a top marker for multiple clusters it is shown only once.


```{r dotplot banksy, fig.width  = 20, fig.height = 30}

DotPlot(scData, features=rev(genesToPlot)) + 
  coord_flip() +
  scale_y_discrete(limits = as.character(sort(as.integer(levels(Idents(scData)))
                                              )
                                         )
                   ) +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
```

### EnrichR
```{r query online enrichR version banksy, echo=FALSE, results='asis'}
markersPerClusterTable <- c()

eachCluster <- 0

for (eachCluster in levels(posMarkersBanksy$cluster)) {
  markersPerCluster <- dplyr::filter(posMarkersBanksy,
                                     cluster == eachCluster) |>
    dplyr::arrange(desc(avg_log2FC))

  markersPerCluster <- head(markersPerCluster,
                            min(nrow(markersPerCluster), 500)
                            )

  markersPerClusterTable <- rbind(markersPerClusterTable,
                                  markersPerCluster)
}

genesPerCluster <- split(markersPerClusterTable$gene,
                         markersPerClusterTable$cluster)

jsCall = paste0('enrich({list: "',
                sapply(genesPerCluster,
                       paste,
                       collapse="\\n"),
                '", popup: true});')

enrichrCalls <- paste0("<a href='javascript:void(0)' onClick='",
                       jsCall,
                       # "'>Analyse at Enrichr website</a>"
                       "'>Open</a>")



```


```{r enrichr markers banksy, echo=FALSE, results='asis'}
enrichrTable1 <- tibble(Cluster=names(genesPerCluster),
                         # "# of posMarkers"=lengths(genesPerCluster),
                         "N posMarkers"=lengths(genesPerCluster),
                         "Enrichr link"=enrichrCalls)

if (!is.null(enrichRout)){
  enrichRTerm <- as.data.frame(do.call(rbind,
                                       lapply(enrichRout, as.vector)))

  enrichRTerm <- map_df(enrichRTerm, 
                        ~ map_df(.x, 
                                 ~ replace(.x, is.null(.x), NA)), 
                        .id = "database")

  enrichRTerm <- enrichRTerm |>
    group_by(., Cluster, database) |>
    summarise(topTerms = paste(Term, collapse = "; ")) |>
    as.data.frame()

  enrichRTerm <- dcast(enrichRTerm, ... ~ database)

  enrichrTable1 <- merge(enrichrTable1, enrichRTerm, by = "Cluster")
}

## settings needed to make sure links remain links
ezKable(enrichrTable1, escape=FALSE, format="html", format.args=list())

```

## Links

### Data files

##### Aggregated expression of every gene across the bins/cells in each cluster

[geneExprPerCluster](bulkSignalPerCluster.tsv)

##### Aggregated expression of every gene across all the bins/cells

[geneExprPerSample](bulkSignalPerSample.tsv)

##### Positive markers of each cluster

[posMarkers](cluster_markers.tsv)

##### Positive markers of each BANKSY niche

[posMarkersBanksy](cluster_markers_banksy.tsv)


##### The final Seurat Object is [here](scData.qs2)

## Parameters

### Parameters used

```{r report parameters, echo=FALSE}

ezListAsKable(param[c("binSize",
        "npcs",
        "clusterResolution",
        "Niche_resolution",
        "lambda",
        "DE.method",
        "nUMIs",
        "nmad")],
        col.names=c("Parameter", "Value"),
        caption="Parameters used")

  
```

### Session Info

```{r, echo=FALSE}


format(Sys.time(), '%Y-%m-%d %H:%M:%S')
ezSessionInfo()
```

