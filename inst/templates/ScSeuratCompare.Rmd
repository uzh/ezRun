---
title: "`r if (exists('reportTitle')) reportTitle else 'SUSHI Report'`"
output: 
  html_document:
    mathjax: https://fgcz-gstore.uzh.ch/reference/mathjax.js
    self_contained: true
    includes:
      in_header: !expr system.file("templates/fgcz_header.html", package="ezRun")
    css: !expr system.file("templates/fgcz.css", package="ezRun")
editor_options: 
  chunk_output_type: inline
---

# {.tabset}


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, knitr.table.format = "html")
library(ggridges)
library(cowplot)
library(kableExtra)
library(tidyverse)
library(ezRun)
library(Seurat)
library(SCpubr)
library(qs2)
library(dittoSeq)
library(sccomp)
library(cmdstanr)
library(ComplexHeatmap)
library(circlize)
library(clusterProfiler)
cache_stan_model <- system.file("stan", package="sccomp", mustWork = TRUE)
## matches path in installation script
cmdstanr::set_cmdstan_path("/misc/ngseq12/src/CmdStan/cmdstan-2.36.0/cmdstan-2.36.0")

```

```{r load rds and qs}
# Always load param.rds first since it's guaranteed
param = readRDS("param.rds")

# Then try to load the other files with error handling
tryCatch({
  scData <- qs_read('scData.qs2', nthreads=param$cores)
}, error = function(e) {
  message("Could not load scData.qs2, trying scData.rds instead")
  tryCatch({
    scData <- readRDS("scData.rds")
  }, error = function(e) {
    message("Could not load scData.rds either: ", e$message)
  })
})

tryCatch({
  sccomp_res <- readRDS("sccomp_results.rds")
}, error = function(e) {
  message("Could not load sccomp_results.rds: ", e$message)
})
```

```{r set idents}
Idents(scData) <- scData@meta.data[[param$grouping]]
scData <- subset(scData, idents=c(param$sampleGroup, param$refGroup))
#values need to be re-scaled after subsetting for plotting purposes
# Scale all features to ensure conserved markers are available for DoHeatmap
scData <- ScaleData(scData, features = rownames(scData))
Idents(scData) <- scData@meta.data[[param$CellIdentity]]
clusterNames <- sort(unique(Idents(scData)))
var_heigth <- 1

# Determine sample column for pseudobulk aggregation
sample_col <- if (ezIsSpecified(param$replicateGrouping) &&
                  param$replicateGrouping != "") {
  param$replicateGrouping
} else {
  "Sample"
}

# Check we have sample-level replication for PCA/MSE
samples <- unique(scData@meta.data[[sample_col]])
n_samples <- length(samples)
has_replicates <- n_samples >= 3

# Species for clusterProfiler
species <- getSpecies(param$refBuild)
```



```{r load conserved and diff genes}
conservedMarkers <- readxl::read_xlsx("consMarkers.xlsx")
conservedMarkersPresent <- !is.null(conservedMarkers) && nrow(conservedMarkers) > 0
diffGenes <- readxl::read_xlsx("diffGenes.xlsx")
diffGenesPresent <- !is.null(diffGenes) && nrow(diffGenes) > 0
```

```{r dim plot explanation, results='asis'}
cat("## Dim Plot")
cat("\n")
cat(sprintf("We first plot a dimensionality plot of the data after subsetting the original integrated data to cells originating from only samples '%s' and '%s'. The plot colors the cells by the Seurat '%s' metadata column, and splits the plot by sample. Gray cells indicate cells absent from this sample, but present in the other.", param$sampleGroup, param$refGroup, param$CellIdentity))
cat("\n\n")
```

```{r dim plot, fig.width=14, fig.height=6+round(length(clusterNames)/10)}
# Fix UMAP coordinate naming before plotting
if("umap" %in% names(scData@reductions)) {
  # Get the current UMAP embeddings
  umap_coords <- Embeddings(scData, reduction = "umap")
  
  # Add these coordinates to metadata with the exact names SCpubr expects
  scData$UMAP_1 <- umap_coords[, 1]
  scData$UMAP_2 <- umap_coords[, 2]
}

# Now try the SCpubr function
tryCatch({
  p <- do_DimPlot(scData, 
                  split.by = param$grouping, 
                  group.by = param$CellIdentity, 
                  font.size = 10)
  print(p)
}, error = function(e) {
  # Fall back to standard DimPlot if do_DimPlot still fails
  message("Note: SCpubr do_DimPlot failed with error: ", e$message)
  
  p1 <- DimPlot(scData, 
                reduction = "umap",
                group.by = param$CellIdentity, 
                split.by = param$grouping,
                label = TRUE, 
                repel = TRUE, 
                label.size = 4) + 
    ggtitle(paste("Cells colored by", param$CellIdentity, 
                  "and split by", param$grouping))
  print(p1)
})
```

```{r pseudobulk-pca-setup, eval=has_replicates, include=FALSE}
# Build sample -> condition mapping
sample_meta <- scData@meta.data[, c(sample_col, param$grouping)] |>
  dplyr::distinct()
colnames(sample_meta) <- c("SampleID", "Condition")

min_cells_per_sample <- 5

# Helper: compute pseudobulk matrix (sum of counts per sample)
compute_pseudobulk <- function(obj, group_col) {
  counts <- GetAssayData(obj, assay = "RNA", layer = "counts")
  groups <- unique(obj@meta.data[[group_col]])
  pb <- sapply(groups, function(g) {
    cells <- which(obj@meta.data[[group_col]] == g)
    if (length(cells) == 0) {
      rep(0, nrow(counts))
    } else if (length(cells) == 1) {
      as.numeric(counts[, cells])
    } else {
      Matrix::rowSums(counts[, cells, drop = FALSE])
    }
  })
  colnames(pb) <- groups
  pb
}

# Helper: run PCA on pseudobulk and return plot-ready dataframe
run_pseudobulk_pca <- function(pb_matrix) {
  # Filter zero-variance genes
  gene_vars <- apply(pb_matrix, 1, var)
  pb_filtered <- pb_matrix[gene_vars > 0, ]

  pca_result <- prcomp(t(pb_filtered), center = TRUE, scale. = TRUE)

  var_explained <- pca_result$sdev^2 / sum(pca_result$sdev^2)
  var_pct <- round(var_explained * 100, 1)

  n_dims <- min(2, ncol(pca_result$x))
  pca_df <- data.frame(
    PC1 = pca_result$x[, 1],
    PC2 = if (n_dims >= 2) pca_result$x[, 2] else 0,
    SampleID = rownames(pca_result$x)
  )

  list(pca_df = pca_df, var_pct = var_pct, n_dims = n_dims)
}
```

```{r pseudobulk-pca-explanation, eval=has_replicates, results='asis'}
cat("## Pseudobulk PCA\n")
cat("\n")
cat("Pseudobulk PCA aggregates single-cell expression profiles by sample (sum of raw counts) to visualize sample-level relationships in principal component space. This helps assess whether samples separate by condition and whether there are outlier samples.\n")
cat("\n")
```

```{r pseudobulk-pca-all, eval=has_replicates, fig.width=10, fig.height=7}
pb_matrix <- compute_pseudobulk(scData, sample_col)
pca_res <- run_pseudobulk_pca(pb_matrix)
pca_df <- dplyr::left_join(pca_res$pca_df, sample_meta, by = "SampleID")

if (pca_res$n_dims >= 2) {
  p <- ggplot(pca_df, aes(x = PC1, y = PC2,
                           color = Condition, label = SampleID)) +
    geom_point(size = 4) +
    ggrepel::geom_text_repel(size = 3, max.overlaps = 20) +
    labs(title = "Pseudobulk PCA - All Cells",
         x = paste0("PC1 (", pca_res$var_pct[1], "%)"),
         y = paste0("PC2 (", pca_res$var_pct[2], "%)")) +
    coord_fixed() +
    theme_bw()
  print(p)
} else {
  p <- ggplot(pca_df, aes(x = PC1, y = PC2,
                           color = Condition, label = SampleID)) +
    geom_point(size = 4) +
    ggrepel::geom_text_repel(size = 3, max.overlaps = 20) +
    labs(title = "Pseudobulk PCA - All Cells (1 PC)",
         x = paste0("PC1 (", pca_res$var_pct[1], "%)"), y = "") +
    theme_bw()
  print(p)
}
```

```{r pseudobulk-pca-per-cluster-header, eval=has_replicates, results='asis'}
cat("### Per-cluster Pseudobulk PCA {.tabset}\n\n")
cat("PCA computed separately within each cluster/cell type to visualize sample-level variation for each cell population.\n\n")
```

```{r pseudobulk-pca-per-cluster, eval=has_replicates, fig.width=9, fig.height=6, results='asis'}
for (cl in clusterNames) {
  cells_cl <- WhichCells(scData, idents = cl)
  sample_counts <- table(scData@meta.data[cells_cl, sample_col])
  valid_samples <- names(sample_counts[sample_counts >= min_cells_per_sample])

  if (length(valid_samples) < 3) next

  cat(paste0("\n\n#### ", cl, "\n\n"))

  tryCatch({
    scData_cl <- subset(scData, cells = cells_cl)
    scData_cl <- subset(scData_cl,
                        cells = colnames(scData_cl)[
                          scData_cl@meta.data[[sample_col]] %in% valid_samples
                        ])

    pb_cl_matrix <- compute_pseudobulk(scData_cl, sample_col)
    pca_cl <- run_pseudobulk_pca(pb_cl_matrix)
    pca_df_cl <- dplyr::left_join(pca_cl$pca_df, sample_meta, by = "SampleID")

    if (pca_cl$n_dims >= 2) {
      p_cl <- ggplot(pca_df_cl, aes(x = PC1, y = PC2,
                                     color = Condition,
                                     label = SampleID)) +
        geom_point(size = 4) +
        ggrepel::geom_text_repel(size = 3, max.overlaps = 20) +
        labs(title = paste0("Pseudobulk PCA - ", cl),
             x = paste0("PC1 (", pca_cl$var_pct[1], "%)"),
             y = paste0("PC2 (", pca_cl$var_pct[2], "%)")) +
        coord_fixed() +
        theme_bw()
      print(p_cl)
    }
  }, error = function(e) {
    message("Skipping PCA for cluster ", cl, ": ", e$message)
  })
}
```

```{r mse-explanation, eval=has_replicates, results='asis'}
cat("## Sample MSE Distance\n")
cat("\n")
cat("Mean Squared Error (MSE) distance quantifies the transcriptional divergence between pseudobulk sample profiles using the top highly variable genes. Lower MSE indicates more similar expression profiles. The heatmap is colored by log-transformed MSE to improve visualization of relative differences.\n")
cat("\n")
```

```{r mse-global, eval=has_replicates, fig.width=10, fig.height=8}
# Get HVGs
hvgs <- VariableFeatures(scData)
if (length(hvgs) == 0) {
  scData <- FindVariableFeatures(scData, assay = "RNA", verbose = FALSE)
  hvgs <- VariableFeatures(scData)
}
hvgs <- head(hvgs, 2000)
hvgs <- hvgs[hvgs %in% rownames(scData)]

# Extract expression data
expr_mat <- GetAssayData(scData, assay = "RNA", layer = "data")[hvgs, ]

# Compute pseudobulk mean per sample
pb_means <- sapply(samples, function(s) {
  cells_s <- which(scData@meta.data[[sample_col]] == s)
  if (length(cells_s) == 0) {
    rep(0, nrow(expr_mat))
  } else if (length(cells_s) == 1) {
    as.numeric(expr_mat[, cells_s])
  } else {
    Matrix::rowMeans(expr_mat[, cells_s, drop = FALSE])
  }
})
colnames(pb_means) <- samples

# Pairwise MSE
mse_mat <- matrix(0, nrow = n_samples, ncol = n_samples,
                  dimnames = list(samples, samples))
for (i in seq_along(samples)) {
  for (j in seq_along(samples)) {
    if (i != j) {
      mse_mat[i, j] <- mean((pb_means[, i] - pb_means[, j])^2)
    }
  }
}

# Annotation
sample_condition_map <- setNames(sample_meta$Condition, sample_meta$SampleID)
condition_levels <- unique(sample_meta$Condition)
n_conditions <- length(condition_levels)
condition_colors <- setNames(
  scales::hue_pal()(n_conditions),
  condition_levels
)
anno_colors <- list(Condition = condition_colors)

ha <- HeatmapAnnotation(
  Condition = sample_condition_map[samples],
  col = anno_colors
)
ra <- rowAnnotation(
  Condition = sample_condition_map[samples],
  col = anno_colors, show_legend = FALSE
)

ht <- Heatmap(
  log1p(mse_mat),
  name = "log(1+MSE)",
  col = viridis::magma(100),
  top_annotation = ha,
  left_annotation = ra,
  column_title = paste0("MSE Distance Between Samples (All Cells, ",
                         length(hvgs), " HVGs)"),
  show_row_names = TRUE, show_column_names = TRUE,
  row_names_gp = gpar(fontsize = 9),
  column_names_gp = gpar(fontsize = 9)
)
draw(ht)
```

```{r mse-per-cluster-header, eval=has_replicates, results='asis'}
cat("### Per-cluster MSE Distance {.tabset}\n\n")
cat("MSE distance computed within each cluster/cell type separately.\n\n")
```

```{r mse-per-cluster, eval=has_replicates, fig.width=9, fig.height=7, results='asis'}
for (cl in clusterNames) {
  cells_cl <- WhichCells(scData, idents = cl)
  sample_counts <- table(scData@meta.data[cells_cl, sample_col])
  valid_samples <- names(sample_counts[sample_counts >= min_cells_per_sample])

  if (length(valid_samples) < 3) next

  cat(paste0("\n\n#### ", cl, "\n\n"))

  tryCatch({
    pb_cl_means <- sapply(valid_samples, function(s) {
      cells_s <- intersect(
        cells_cl,
        colnames(scData)[scData@meta.data[[sample_col]] == s]
      )
      if (length(cells_s) == 0) {
        rep(0, nrow(expr_mat))
      } else if (length(cells_s) == 1) {
        as.numeric(expr_mat[, cells_s])
      } else {
        Matrix::rowMeans(expr_mat[, cells_s, drop = FALSE])
      }
    })

    n_valid <- length(valid_samples)
    mse_cl <- matrix(0, nrow = n_valid, ncol = n_valid,
                     dimnames = list(valid_samples, valid_samples))
    for (i in seq_along(valid_samples)) {
      for (j in seq_along(valid_samples)) {
        if (i != j) {
          mse_cl[i, j] <- mean(
            (pb_cl_means[, i] - pb_cl_means[, j])^2
          )
        }
      }
    }

    ha_cl <- HeatmapAnnotation(
      Condition = sample_condition_map[valid_samples],
      col = anno_colors,
      show_legend = (cl == clusterNames[1])
    )

    ht_cl <- Heatmap(
      log1p(mse_cl),
      name = "log(1+MSE)",
      col = viridis::magma(100),
      top_annotation = ha_cl,
      column_title = paste0("MSE Distance - ", cl),
      show_row_names = TRUE, show_column_names = TRUE,
      row_names_gp = gpar(fontsize = 9),
      column_names_gp = gpar(fontsize = 9)
    )
    draw(ht_cl)
  }, error = function(e) {
    message("Skipping MSE for cluster ", cl, ": ", e$message)
  })
}
```

```{r consMarkers table, eval=conservedMarkersPresent, results='asis'}
cat("## Conserved Markers")
cat("\n")
cat("Identify cell type marker genes that are conserved across conditions. Differential gene expression tests are performed for each group and then, the p-values are combined using meta-analysis methods.")
cat("\n\n")
cat("### Conserved cell type markers \n")
cat("\n")
ezInteractiveTableRmd(conservedMarkers, digits = 3)
```

```{r subset conserved top5, eval=conservedMarkersPresent}
top5 <- conservedMarkers %>% 
  mutate(cluster = as.numeric(as.character(cluster))) %>% group_by(cluster)
top5 <- slice_max(top5, n = 5, order_by = avg_avg_fc)
var_heigth <- nrow(top5)*0.2
```

```{r consMarkers plots, eval=conservedMarkersPresent, results='asis', fig.width=12, fig.height=var_heigth}
cat("## Conserved Markers - Plots\n")
cat("\n")
cat("Here, we use a heatmap and a dotplot to visualize simultaneously the top 5 conserved markers in each cluster (with highest average fold change across the two groups). Be aware that some genes may be in the top markers for different clusters.\n")
cat("\n")

# Use simple tryCatch to handle potential errors in DoHeatmap
tryCatch({
  DoHeatmap(scData, features=top5$gene)
}, error = function(e) {
  if (grepl("No requested features found in the scale.data (slot|layer)", e$message)) {
    message("Note: Could not generate heatmap because the requested features were not found in the scale.data layer.")
  } else {
    # Re-throw any other errors
    stop(e)
  }
})

# Use simple tryCatch for the DotPlot as well
tryCatch({
  DotPlot(scData, features=unique(top5$gene)) + 
    coord_flip() + 
    theme(axis.text.x = element_text(angle = 45, hjust=1))
}, error = function(e) {
  if (grepl("No requested features found", e$message)) {
    message("Note: Could not generate dotplot because the requested features were not found in the data.")
  } else {
    # Re-throw any other errors
    stop(e)
  }
})
```

```{r diffGenes table, eval=diffGenesPresent, results='asis'}
cat("## Differential Expression")
cat("\n")

cat(paste0("After identifying common cell types across conditions, we can look for genes that change in different conditions for cells of the same type. The interactive table can help you to explore the more relevant genes (maximum 1000 genes with the biggest diff_pct). The full list of tested genes is in the Data availability section of this report. The comparison made was ", paste(c(param$sampleGroup, param$refGroup), collapse = " vs ")))

cat("\n")

diffGenesTable <- diffGenes[!is.na(diffGenes$p_val_adj) & diffGenes$p_val_adj<0.05,]  #too many genes make the interactive table slow
diffGenesTable <- diffGenesTable[order(abs(diffGenesTable$avg_log2FC), decreasing = TRUE), ]
cutoff <- 1000

if(nrow(diffGenesTable) > cutoff) {
  diffGenesTable <- diffGenesTable[1:cutoff, ]
}

cat("\n")
cat("### Differential expressed genes per cluster")
cat("\n")
ezInteractiveTableRmd(as.data.frame(diffGenesTable), digits=3) %>% DT::formatSignif("p_val")
```

```{r diffGenes heatmap, eval=diffGenesPresent, results='asis', fig.height=6, fig.width=12, fig.align='center'}
cat("## Differential Expression - Plots\n")
cat("\n")
cat("The top 5 dysregulated genes (by log2FC) between the two conditions for each cluster can be visualised as a global summary. ")
cat("\n")
top5 <- diffGenes %>% group_by(cluster)
top5 <- slice_max(top5, n = 5, order_by = avg_log2FC)
scData$cluster.group <- paste0(scData@meta.data[[param$CellIdentity]], "--", scData@meta.data[[param$grouping]])
do_DotPlot(scData, features = top5$gene, group.by = param$grouping)
do_ExpressionHeatmap(scData, features = top5$gene, group.by = "cluster.group", font.size = 8)
```

```{r diffGenes volcano plots, eval=diffGenesPresent}
Idents(scData) <- scData@meta.data[[param$grouping]]
for (clusterName in clusterNames) {
  dt <- diffGenes %>% filter(cluster == clusterName)
  scd <- scData[, scData@meta.data[[param$CellIdentity]] == clusterName]
  if (nrow(dt) > 0) {
    dt <- dt[order(dt$p_val_adj), ]
    upGenes <- dt[dt$avg_log2FC > 0, ] %>% slice_max( n=20, order_by = avg_log2FC) %>% pull("gene")
    downGenes <- dt[dt$avg_log2FC < 0, ] %>% slice_min( n=20, order_by = avg_log2FC) %>% pull("gene")
    
    genesToPlot <- c(upGenes, downGenes)
    print(DoHeatmap(subset(scd, downsample = 2000), genesToPlot, slot="scale.data") + ggtitle(paste0("Cell type: ", clusterName)))
  }
  p <- do_VolcanoPlot(scData, dt, plot.title = clusterName, FC_cutoff = 0.5, add_gene_tags = TRUE, order_tags_by = "pvalue")
  print(p)
}
```

```{r enrichment-setup, eval=diffGenesPresent, include=FALSE}
orgDb_name <- switch(species,
  "Human" = "org.Hs.eg.db",
  "Mouse" = "org.Mm.eg.db",
  NULL
)
kegg_org <- switch(species, "Human" = "hsa", "Mouse" = "mmu", NULL)
has_orgDb <- !is.null(orgDb_name)
```

```{r enrichment-header, eval=diffGenesPresent, results='asis'}
cat("## Pathway Enrichment\n")
cat("\n")
cat(sprintf("Gene set enrichment analysis of differentially expressed genes between %s and %s, split by cluster. GO Biological Process and KEGG pathway enrichment are shown as bubble plots where dot size indicates gene count and color indicates adjusted p-value.\n", param$sampleGroup, param$refGroup))
cat("\n")
```

```{r enrichment-go-bp, eval=diffGenesPresent && has_orgDb, fig.width=12, fig.height=10, results='asis'}
library(orgDb_name, character.only = TRUE)

sig_degs <- diffGenes |>
  dplyr::filter(!is.na(p_val_adj), p_val_adj < 0.05)

for (direction in c("Upregulated", "Downregulated")) {
  if (direction == "Upregulated") {
    gene_set <- sig_degs |> dplyr::filter(avg_log2FC > 0.25)
  } else {
    gene_set <- sig_degs |> dplyr::filter(avg_log2FC < -0.25)
  }

  if (nrow(gene_set) == 0) next

  genes_by_cluster <- split(gene_set$gene, gene_set$cluster)
  genes_by_cluster <- genes_by_cluster[lengths(genes_by_cluster) >= 5]

  if (length(genes_by_cluster) == 0) next

  cat(paste0("\n\n### GO BP - ", direction, " in ", param$sampleGroup,
             " vs ", param$refGroup, "\n\n"))

  ck <- tryCatch({
    compareCluster(
      geneClusters = genes_by_cluster,
      fun = "enrichGO",
      OrgDb = get(orgDb_name),
      keyType = "SYMBOL",
      ont = "BP",
      pAdjustMethod = "BH",
      pvalueCutoff = 0.05,
      qvalueCutoff = 0.2
    )
  }, error = function(e) {
    message("GO BP enrichment failed for ", direction, ": ", e$message)
    NULL
  })

  if (!is.null(ck) && nrow(as.data.frame(ck)) > 0) {
    p <- dotplot(ck, showCategory = 5) +
      ggtitle(paste0("GO BP - ", direction, " genes")) +
      theme(axis.text.y = element_text(size = 8))
    print(p)
  } else {
    cat("No significant GO BP enrichments found.\n\n")
  }
}
```

```{r enrichment-kegg, eval=diffGenesPresent && has_orgDb, fig.width=12, fig.height=10, results='asis'}
for (direction in c("Upregulated", "Downregulated")) {
  if (direction == "Upregulated") {
    gene_set <- sig_degs |> dplyr::filter(avg_log2FC > 0.25)
  } else {
    gene_set <- sig_degs |> dplyr::filter(avg_log2FC < -0.25)
  }

  if (nrow(gene_set) == 0) next

  # Map gene symbols to Entrez IDs for KEGG
  gene_mapping <- tryCatch({
    bitr(unique(gene_set$gene),
         fromType = "SYMBOL",
         toType = "ENTREZID",
         OrgDb = get(orgDb_name))
  }, error = function(e) {
    message("Gene ID mapping failed: ", e$message)
    NULL
  })

  if (is.null(gene_mapping) || nrow(gene_mapping) == 0) next

  gene_set_mapped <- gene_set |>
    dplyr::inner_join(gene_mapping, by = c("gene" = "SYMBOL"))

  genes_by_cluster <- split(gene_set_mapped$ENTREZID,
                             gene_set_mapped$cluster)
  genes_by_cluster <- genes_by_cluster[lengths(genes_by_cluster) >= 5]

  if (length(genes_by_cluster) == 0) next

  cat(paste0("\n\n### KEGG - ", direction, " in ", param$sampleGroup,
             " vs ", param$refGroup, "\n\n"))

  ck_kegg <- tryCatch({
    compareCluster(
      geneClusters = genes_by_cluster,
      fun = "enrichKEGG",
      organism = kegg_org,
      pvalueCutoff = 0.05,
      qvalueCutoff = 0.2
    )
  }, error = function(e) {
    message("KEGG enrichment failed for ", direction, ": ", e$message)
    NULL
  })

  if (!is.null(ck_kegg) && nrow(as.data.frame(ck_kegg)) > 0) {
    p <- dotplot(ck_kegg, showCategory = 5) +
      ggtitle(paste0("KEGG - ", direction, " genes")) +
      theme(axis.text.y = element_text(size = 8))
    print(p)
  } else {
    cat("No significant KEGG enrichments found.\n\n")
  }
}
```

```{r enrichment-no-orgdb, eval=diffGenesPresent && !has_orgDb, results='asis'}
cat("Pathway enrichment analysis (GO and KEGG) is currently only supported for Human and Mouse species.\n")
```

## Barplots of proportions
`r format(Sys.time(), '%Y-%m-%d %H:%M:%S')`

```{r barplots, results='asis', fig.width=8, fig.height=7}
cat("\n")
cat("The barplots show the proportion of cells from each sample in each cluster. The barplots are split by the Seurat metadata column '", param$CellIdentity, "'.")
cat("\n\n")

# This plot should always work as param$grouping is required
dittoSeq::dittoBarPlot(scData, group.by = param$grouping, var = param$CellIdentity)

# Only run the second plot if replicateGrouping exists AND is not an empty string
if(!is.null(param$replicateGrouping) && param$replicateGrouping != "") {
  cat("\n\nAdditional barplot showing proportions by replicate groups:\n\n")
  dittoSeq::dittoBarPlot(scData, group.by = param$replicateGrouping, var = param$CellIdentity)
}
```

## Cell Type Composition Analysis

```{r intervals analysis, results='asis', fig.width=9, fig.height=7}
if(exists('sccomp_res')){
  cat("\n\n### Intervals\n")
  cat("The error bars represent 95% credible intervals. The dashed lines represent the minimal effect that the hypothesis test is based on. An effect is labelled as significant if it exceeds the minimal effect according to the 95% credible interval.\n\n")
  
  # Get both conditions
  all_conditions <- sccomp_res %>% attributes %>% .$count_data %>%
    dplyr::pull(param$grouping) %>%
    unique()
  
  # Create title
  plot_title <- unique(sccomp_res$parameter[grep('(Intercept)',sccomp_res$parameter, invert = TRUE)])
  
  # Use in plot
  sccomp_res |> 
    plot_1D_intervals() +
    ggtitle(plot_title) +
    theme(
      axis.text.y = element_text(size = 12), 
      plot.title = element_text(size = 13)
    )
}
```

```{r composition analysis, results='asis', fig.width=10, fig.height=11, message=FALSE, warning=FALSE}
if(exists('sccomp_res')){
  cat("### Differential Cell Type Composition\n")
  cat("\nWe used [sccomp](https://github.com/MangiolaLaboratory/sccomp) to analyze differences in cell type composition between conditions. The analysis takes into account the count nature of the data and models both changes in proportion and variability.\n\n")
  
  # Create interactive table of significant results
  # First get the plot object
  invisible(capture.output(
    p <- sccomp_res |> 
      sccomp_boxplot(
        factor = param$grouping
      ) + 
      theme(
        strip.text = element_text(size = 20, face = "bold"),
        axis.title = element_text(size = 12),
        axis.text = element_text(size = 12)
      )
  ))
  print(p)
}
```

```{r composition analysis table, results='asis', fig.width=10, fig.height=11, message=FALSE, warning=FALSE}
if(exists('sccomp_res')){
  df_sccomp <- data.frame(sccomp_res)[,1:11]
  finalTable <- df_sccomp[grep('Intercept', df_sccomp$parameter,invert = TRUE),]
  DT::datatable(finalTable, rownames = FALSE, options = list(pageLength = 10, scrollX = TRUE))
}
```


## Data availability

### Conserved markers

[conservedMarkers](consMarkers.xlsx)

### Differentially expressed genes

[diffGenes](diffGenes.xlsx)

## Parameters
```{r report parameters, echo=FALSE}
param[c("DE.method", "DE.regress", "grouping", "sampleGroup", "refGroup", "CellIdentity", "pseudoBulkMode", "replicateGrouping", "sccomp.variability")]
```

## SessionInfo
```{r, echo=FALSE}
ezSessionInfo()
```
